import { BatchUploader } from '../../utils/batch-uploader';
import { TodoSizeCalculator } from '../../utils/todo-size-calculator';
import { WalrusStorage } from '../../utils/walrus-storage';
import { Todo, TodoList } from '../../types/todo';
import { CLIError } from '../../types/error';

// Mock the WalrusStorage class
jest.mock('../../utils/walrus-storage');

describe('BatchUploader', () => {
  // Sample test data
  const sampleTodos: Todo[] = [
    {
      id: '1',
      title: 'First Todo',
      description: 'This is the first test todo',
      completed: false,
      priority: 'high',
      tags: ['test', 'important'],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      private: false
    },
    {
      id: '2',
      title: 'Second Todo',
      description: 'This is the second test todo',
      completed: true,
      priority: 'medium',
      tags: ['test'],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      private: false
    },
    {
      id: '3',
      title: 'Third Todo',
      description: 'This is the third test todo with a longer description to test variable sizes',
      completed: false,
      priority: 'low',
      tags: ['test', 'optional', 'later'],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      private: true
    }
  ];
  
  const sampleTodoList: TodoList = {
    id: 'list-1',
    name: 'Test List',
    owner: 'test-user',
    todos: sampleTodos,
    version: 1,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };

  // Mock implementation of WalrusStorage
  let mockWalrusStorage: jest.Mocked<WalrusStorage>;
  let batchUploader: BatchUploader;

  beforeEach(() => {
    // Setup mock implementations
    mockWalrusStorage = new WalrusStorage('testnet', true) as jest.Mocked<WalrusStorage>;
    
    // Mock the storage methods
    mockWalrusStorage.ensureStorageAllocated = jest.fn().mockResolvedValue({
      id: { id: 'mock-storage-id' },
      storage_size: '1000000',
      used_size: '0',
      start_epoch: 100,
      end_epoch: 200
    });

    mockWalrusStorage.storeTodo = jest.fn().mockImplementation((todo: Todo) => 
      Promise.resolve(`blob-${todo.id}`)
    );

    mockWalrusStorage.storeTodoList = jest.fn().mockResolvedValue('list-blob-123');

    batchUploader = new BatchUploader(mockWalrusStorage);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('uploadBatch', () => {
    it('should upload a batch of todos successfully', async () => {
      const results = await batchUploader.uploadBatch(sampleTodos);

      expect(mockWalrusStorage.storeTodo).toHaveBeenCalledTimes(3);
      expect(results).toHaveLength(3);
      
      // Check each result
      results.forEach((result, index) => {
        expect(result.success).toBe(true);
        expect(result.todoId).toBe(sampleTodos[index].id);
        expect(result.blobId).toBe(`blob-${sampleTodos[index].id}`);
        expect(result.error).toBeUndefined();
      });
    });

    it('should handle partial failures in batch upload', async () => {
      // Make the second todo fail
      mockWalrusStorage.storeTodo = jest.fn()
        .mockImplementation((todo: Todo) => {
          if (todo.id === '2') {
            return Promise.reject(new Error('Upload failed'));
          }
          return Promise.resolve(`blob-${todo.id}`);
        });

      const results = await batchUploader.uploadBatch(sampleTodos);

      expect(results).toHaveLength(3);
      expect(results[0].success).toBe(true);
      expect(results[1].success).toBe(false);
      expect(results[1].error).toBe('Upload failed');
      expect(results[2].success).toBe(true);
    });

    it('should handle empty batch', async () => {
      const results = await batchUploader.uploadBatch([]);
      expect(results).toHaveLength(0);
      expect(mockWalrusStorage.storeTodo).not.toHaveBeenCalled();
    });

    it('should handle progress callback', async () => {
      const progressCallback = jest.fn();
      await batchUploader.uploadBatch(sampleTodos, progressCallback);

      expect(progressCallback).toHaveBeenCalledTimes(sampleTodos.length);
      sampleTodos.forEach((todo, index) => {
        expect(progressCallback).toHaveBeenCalledWith({
          completed: index + 1,
          total: sampleTodos.length,
          percentage: ((index + 1) / sampleTodos.length) * 100,
          currentTodo: todo
        });
      });
    });
  });

  describe('uploadBatchWithRetries', () => {
    it('should retry failed uploads', async () => {
      let attempts = 0;
      mockWalrusStorage.storeTodo = jest.fn()
        .mockImplementation((todo: Todo) => {
          if (todo.id === '2' && attempts++ < 2) {
            return Promise.reject(new Error('Temporary failure'));
          }
          return Promise.resolve(`blob-${todo.id}`);
        });

      const results = await batchUploader.uploadBatchWithRetries(sampleTodos, 3);

      expect(results.successful).toHaveLength(3);
      expect(results.failed).toHaveLength(0);
      expect(mockWalrusStorage.storeTodo).toHaveBeenCalledTimes(5); // 3 todos + 2 retries for todo 2
    });

    it('should report permanently failed uploads', async () => {
      mockWalrusStorage.storeTodo = jest.fn()
        .mockImplementation((todo: Todo) => {
          if (todo.id === '2') {
            return Promise.reject(new Error('Permanent failure'));
          }
          return Promise.resolve(`blob-${todo.id}`);
        });

      const results = await batchUploader.uploadBatchWithRetries(sampleTodos, 3);

      expect(results.successful).toHaveLength(2);
      expect(results.failed).toHaveLength(1);
      expect(results.failed[0].todoId).toBe('2');
      expect(results.failed[0].error).toBe('Permanent failure');
      expect(results.failed[0].attempts).toBe(3);
    });
  });

  describe('uploadTodoList', () => {
    it('should upload a complete todo list', async () => {
      const result = await batchUploader.uploadTodoList(sampleTodoList);

      expect(mockWalrusStorage.storeTodoList).toHaveBeenCalledWith(sampleTodoList);
      expect(result).toBe('list-blob-123');
    });

    it('should handle list upload failure', async () => {
      mockWalrusStorage.storeTodoList = jest.fn()
        .mockRejectedValue(new Error('List upload failed'));

      await expect(batchUploader.uploadTodoList(sampleTodoList))
        .rejects.toThrow('List upload failed');
    });
  });

  describe('size calculations', () => {
    it('should calculate batch size correctly', () => {
      const size = batchUploader.calculateBatchSize(sampleTodos);
      expect(size).toBeGreaterThan(0);
      
      // Verify it's calculating size for each todo
      const individualSizes = sampleTodos.map(todo => 
        TodoSizeCalculator.calculateTodoSize(todo)
      );
      expect(size).toBe(individualSizes.reduce((a, b) => a + b, 0));
    });

    it('should calculate optimal batch size', () => {
      const batches = batchUploader.optimizeBatchSize(sampleTodos, 200); // Small batch size for testing
      
      expect(batches.length).toBeGreaterThan(1);
      batches.forEach(batch => {
        const batchSize = batchUploader.calculateBatchSize(batch);
        expect(batchSize).toBeLessThanOrEqual(200);
      });
    });
  });

  describe('ensureStorageAllocated', () => {
    it('should ensure adequate storage before upload', async () => {
      const storage = await batchUploader.ensureStorageAllocated();

      expect(mockWalrusStorage.ensureStorageAllocated).toHaveBeenCalled();
      expect(storage).toBeDefined();
      expect(storage.id.id).toBe('mock-storage-id');
    });

    it('should handle storage allocation failure', async () => {
      mockWalrusStorage.ensureStorageAllocated = jest.fn()
        .mockRejectedValue(new CLIError('Failed to allocate storage', 'ALLOCATION_ERROR'));

      await expect(batchUploader.ensureStorageAllocated())
        .rejects.toThrow('Failed to allocate storage');
    });
  });
});