This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
__tests__/
  components/
    SessionTimeoutWarning.test.tsx
    TransactionHistory.test.tsx
    WalletConnectButton.test.tsx
  contexts/
    WalletContext.test.tsx
  hooks/
    useInactivityTimer.test.tsx
  integration/
    WalletIntegration.test.tsx
docs/
  FIXING_BROWSER_ERRORS.md
  FRONTEND_FIXES.md
public/
  images/
    ocean-wave.svg
src/
  app/
    blockchain/
      page.tsx
    dashboard/
      page.tsx
    examples/
      page.tsx
      wallet-usage.tsx
    layout.tsx
    page.tsx
  components/
    ClipboardErrorModal.tsx
    context-warning.tsx
    create-todo-form.tsx
    ErrorBoundary.tsx
    ErrorHandlingProvider.tsx
    navbar.tsx
    SessionTimeoutWarning.tsx
    StorageContextWarning.tsx
    todo-list.tsx
    TransactionHistory.tsx
    WalletConnectButton.tsx
    WalletErrorModal.tsx
    WalletStatus.tsx
  contexts/
    SimpleWalletContext.tsx
    WalletContext.tsx
  lib/
    clipboard.ts
    safe-storage.ts
    storage-utils.ts
    sui-client.ts
    todo-service.ts
    wallet-errors.ts
    walletContext.tsx
  styles/
    globals.css
  types/
    wallet.ts
    window.d.ts
.env.local.example
.eslintrc.js
.gitignore
.npmrc
enable-simple-wallet.sh
fix-all.sh
fix-dev-server.sh
INSTALLATION.md
jest.setup.js
next.config.js
package.json
postcss.config.js
README.md
reset-next.sh
tailwind.config.js
tsconfig.json
WALLET_INTEGRATION.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__tests__/components/SessionTimeoutWarning.test.tsx">
import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { SessionTimeoutWarning } from '../../src/components/SessionTimeoutWarning';
import { useWalletContext } from '../../src/contexts/WalletContext';

// Mock wallet context
jest.mock('../../src/contexts/WalletContext', () => ({
  useWalletContext: jest.fn()
}));

// Constants from the component
const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
const WARNING_THRESHOLD = 5 * 60 * 1000; // 5 minutes

describe('SessionTimeoutWarning', () => {
  // Mock current time for consistent testing
  let mockNow = Date.now();
  const originalNow = Date.now;
  
  // Timer mocking
  let timerCallback: Function;
  
  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();
    
    // Restore and re-mock Date.now for each test
    global.Date.now = originalNow;
    mockNow = originalNow();
    global.Date.now = jest.fn(() => mockNow);
    
    // Mock setInterval to capture the callback for testing
    jest.spyOn(global, 'setInterval').mockImplementation((callback: any, ms: number) => {
      timerCallback = callback;
      return 1 as any; // Timer ID
    });
    
    // Default context values
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: true,
      lastActivity: mockNow - (SESSION_TIMEOUT - WARNING_THRESHOLD - 1000), // Just before warning threshold
      resetActivityTimer: jest.fn()
    });
  });
  
  afterEach(() => {
    jest.useRealTimers();
    global.Date.now = originalNow;
  });
  
  it('does not show warning when user is active', () => {
    render(<SessionTimeoutWarning />);
    
    // Warning should not be visible
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });
  
  it('shows warning when approaching timeout threshold', () => {
    // Set activity time to be within warning threshold
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: true,
      lastActivity: mockNow - (SESSION_TIMEOUT - WARNING_THRESHOLD / 2), // Middle of warning period
      resetActivityTimer: jest.fn()
    });
    
    render(<SessionTimeoutWarning />);
    
    // Warning should now be visible
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
    
    // Call the timer callback directly to simulate interval trigger
    act(() => {
      timerCallback();
    });
    
    // Warning should be visible after timer callback
    expect(screen.getByText(/Session Timeout Warning/)).toBeInTheDocument();
    expect(screen.getByText(/Your wallet session will expire in/)).toBeInTheDocument();
  });
  
  it('does not show warning when not connected', () => {
    // Set connected to false
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: false,
      lastActivity: mockNow - (SESSION_TIMEOUT - WARNING_THRESHOLD / 2), // Middle of warning period
      resetActivityTimer: jest.fn()
    });
    
    render(<SessionTimeoutWarning />);
    
    // Call the timer callback
    act(() => {
      timerCallback();
    });
    
    // Warning should still not be visible
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });
  
  it('calls resetActivityTimer when "Stay Active" is clicked', () => {
    // Set activity time to be within warning threshold
    const mockResetActivityTimer = jest.fn();
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: true,
      lastActivity: mockNow - (SESSION_TIMEOUT - WARNING_THRESHOLD / 2), // Middle of warning period
      resetActivityTimer: mockResetActivityTimer
    });
    
    render(<SessionTimeoutWarning />);
    
    // Call the timer callback to show warning
    act(() => {
      timerCallback();
    });
    
    // Warning should be visible
    const stayActiveButton = screen.getByText('Stay Active');
    expect(stayActiveButton).toBeInTheDocument();
    
    // Click "Stay Active"
    fireEvent.click(stayActiveButton);
    
    // Should call resetActivityTimer
    expect(mockResetActivityTimer).toHaveBeenCalledTimes(1);
    
    // Warning should be dismissed
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });
  
  it('dismisses warning when "Dismiss" is clicked', () => {
    // Set activity time to be within warning threshold
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: true,
      lastActivity: mockNow - (SESSION_TIMEOUT - WARNING_THRESHOLD / 2), // Middle of warning period
      resetActivityTimer: jest.fn()
    });
    
    render(<SessionTimeoutWarning />);
    
    // Call the timer callback to show warning
    act(() => {
      timerCallback();
    });
    
    // Warning should be visible
    const dismissButton = screen.getByText('Dismiss');
    expect(dismissButton).toBeInTheDocument();
    
    // Click "Dismiss"
    fireEvent.click(dismissButton);
    
    // Warning should be dismissed
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });
  
  it('formats countdown timer correctly', () => {
    // Set activity time to exactly 2 minutes before timeout
    const timeRemaining = 2 * 60 * 1000; // 2 minutes
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: true,
      lastActivity: mockNow - (SESSION_TIMEOUT - timeRemaining),
      resetActivityTimer: jest.fn()
    });
    
    render(<SessionTimeoutWarning />);
    
    // Call the timer callback to show warning
    act(() => {
      timerCallback();
    });
    
    // Warning should show the formatted time remaining (2:00)
    expect(screen.getByText(/Your wallet session will expire in 2:00/)).toBeInTheDocument();
    
    // Advance time by 30 seconds
    mockNow += 30 * 1000;
    
    // Call the timer callback again to update the display
    act(() => {
      timerCallback();
    });
    
    // Warning should now show 1:30
    expect(screen.getByText(/Your wallet session will expire in 1:30/)).toBeInTheDocument();
  });
  
  it('hides warning when timeout period is over', () => {
    // Set activity time to be within warning threshold
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: true,
      lastActivity: mockNow - (SESSION_TIMEOUT - WARNING_THRESHOLD / 2), // Middle of warning period
      resetActivityTimer: jest.fn()
    });
    
    render(<SessionTimeoutWarning />);
    
    // Call the timer callback to show warning
    act(() => {
      timerCallback();
    });
    
    // Warning should be visible
    expect(screen.getByText(/Session Timeout Warning/)).toBeInTheDocument();
    
    // Advance time beyond the timeout
    mockNow += SESSION_TIMEOUT;
    
    // Call the timer callback again
    act(() => {
      timerCallback();
    });
    
    // Warning should no longer be visible
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });
});
</file>

<file path="__tests__/components/TransactionHistory.test.tsx">
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { TransactionHistory } from '../../src/components/TransactionHistory';
import { useWalletContext } from '../../src/contexts/WalletContext';
import type { TransactionRecord } from '../../src/contexts/WalletContext';

// Mock wallet context
jest.mock('../../src/contexts/WalletContext', () => ({
  useWalletContext: jest.fn()
}));

// Mock Intl.RelativeTimeFormat for consistent testing
const mockFormatFn = jest.fn(value => `${Math.abs(value)} time units ago`);
global.Intl.RelativeTimeFormat = jest.fn().mockImplementation(() => ({
  format: mockFormatFn
})) as any;

describe('TransactionHistory', () => {
  // Sample transaction records for testing
  const mockTransactions: TransactionRecord[] = [
    {
      id: 'tx1',
      status: 'success',
      timestamp: Date.now() - 60000, // 1 minute ago
      type: 'Transfer',
      hash: '0xabc123def456'
    },
    {
      id: 'tx2',
      status: 'pending',
      timestamp: Date.now() - 300000, // 5 minutes ago
      type: 'Swap'
    },
    {
      id: 'tx3',
      status: 'error',
      timestamp: Date.now() - 3600000, // 1 hour ago
      type: 'Mint',
      message: 'Transaction failed: insufficient funds'
    },
    {
      id: 'tx4',
      status: 'success',
      timestamp: Date.now() - 86400000, // 1 day ago
      type: 'Stake',
      hash: '0x789012345abc'
    },
    {
      id: 'tx5',
      status: 'success',
      timestamp: Date.now() - 172800000, // 2 days ago
      type: 'Claim',
      hash: '0xdef456789abc'
    },
    {
      id: 'tx6',
      status: 'success',
      timestamp: Date.now() - 604800000, // 7 days ago
      type: 'Vote',
      hash: '0x123def789abc'
    }
  ];

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Default to empty transactions
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: []
    });
  });

  it('displays message when no transactions exist', () => {
    render(<TransactionHistory />);
    
    expect(screen.getByText('No transactions yet')).toBeInTheDocument();
  });

  it('displays transactions with correct status icons', () => {
    // Use a subset of mock transactions with different statuses
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: mockTransactions.slice(0, 3) // Success, Pending, Error
    });
    
    render(<TransactionHistory />);
    
    // Check transaction types are displayed
    expect(screen.getByText('Transfer')).toBeInTheDocument();
    expect(screen.getByText('Swap')).toBeInTheDocument();
    expect(screen.getByText('Mint')).toBeInTheDocument();
    
    // Check hash is displayed for the success transaction
    expect(screen.getByText(/0xabc123/)).toBeInTheDocument();
    
    // Check error message is displayed
    expect(screen.getByText(/insufficient funds/)).toBeInTheDocument();
  });

  it('limits transactions to maxItems by default', () => {
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: mockTransactions // All 6 transactions
    });
    
    // Default maxItems is 5
    render(<TransactionHistory />);
    
    // Should show the 5 most recent transactions
    expect(screen.getByText('Transfer')).toBeInTheDocument();
    expect(screen.getByText('Swap')).toBeInTheDocument();
    expect(screen.getByText('Mint')).toBeInTheDocument();
    expect(screen.getByText('Stake')).toBeInTheDocument();
    expect(screen.getByText('Claim')).toBeInTheDocument();
    
    // Should not show the oldest transaction
    expect(screen.queryByText('Vote')).not.toBeInTheDocument();
    
    // Should show a "Show all" button
    expect(screen.getByText('Show all (6)')).toBeInTheDocument();
  });

  it('expands to show all transactions when "Show all" is clicked', () => {
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: mockTransactions // All 6 transactions
    });
    
    render(<TransactionHistory />);
    
    // Initially, should not show the oldest transaction
    expect(screen.queryByText('Vote')).not.toBeInTheDocument();
    
    // Click "Show all"
    fireEvent.click(screen.getByText('Show all (6)'));
    
    // Now should show all transactions, including the oldest
    expect(screen.getByText('Vote')).toBeInTheDocument();
    
    // Button should now say "Show less"
    expect(screen.getByText('Show less')).toBeInTheDocument();
  });

  it('collapses back when "Show less" is clicked', () => {
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: mockTransactions // All 6 transactions
    });
    
    render(<TransactionHistory />);
    
    // Click "Show all"
    fireEvent.click(screen.getByText('Show all (6)'));
    
    // Now should show all transactions
    expect(screen.getByText('Vote')).toBeInTheDocument();
    
    // Click "Show less"
    fireEvent.click(screen.getByText('Show less'));
    
    // Should hide the oldest transaction again
    expect(screen.queryByText('Vote')).not.toBeInTheDocument();
  });

  it('respects custom maxItems prop', () => {
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: mockTransactions // All 6 transactions
    });
    
    // Set maxItems to 2
    render(<TransactionHistory maxItems={2} />);
    
    // Should only show the 2 most recent transactions
    expect(screen.getByText('Transfer')).toBeInTheDocument();
    expect(screen.getByText('Swap')).toBeInTheDocument();
    
    // Should not show the rest
    expect(screen.queryByText('Mint')).not.toBeInTheDocument();
    expect(screen.queryByText('Stake')).not.toBeInTheDocument();
    expect(screen.queryByText('Claim')).not.toBeInTheDocument();
    expect(screen.queryByText('Vote')).not.toBeInTheDocument();
  });

  it('uses Intl.RelativeTimeFormat for time formatting', () => {
    // Set up a single transaction for simplicity
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: [mockTransactions[0]] // Just the first transaction (1 minute ago)
    });
    
    render(<TransactionHistory />);
    
    // Check that Intl.RelativeTimeFormat was used
    expect(global.Intl.RelativeTimeFormat).toHaveBeenCalledWith('en', { numeric: 'auto' });
    
    // Check that format function was called with expected value
    // The first parameter should be negative, representing time in the past
    expect(mockFormatFn).toHaveBeenCalledWith(expect.any(Number), expect.any(String));
    
    // The result of the format function should be in the document
    expect(screen.getByText('1 time units ago')).toBeInTheDocument();
  });

  it('falls back to manual formatting when Intl.RelativeTimeFormat is not available', () => {
    // Temporarily remove Intl.RelativeTimeFormat
    const originalIntl = global.Intl;
    delete (global as any).Intl.RelativeTimeFormat;
    
    // Set up a single transaction for simplicity
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: [
        {
          ...mockTransactions[0],
          timestamp: Date.now() - 60000 // 1 minute ago
        }
      ]
    });
    
    render(<TransactionHistory />);
    
    // Should use fallback formatting
    expect(screen.getByText('1 minute ago')).toBeInTheDocument();
    
    // Restore Intl
    global.Intl = originalIntl;
  });
});
</file>

<file path="__tests__/components/WalletConnectButton.test.tsx">
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { WalletConnectButton } from '../../src/components/WalletConnectButton';
import { useWalletContext } from '../../src/contexts/WalletContext';
import { WalletError } from '../../src/lib/wallet-errors';
import { ClipboardError } from '../../src/lib/clipboard';

// Mock the entire wallet context
jest.mock('../../src/contexts/WalletContext', () => ({
  useWalletContext: jest.fn()
}));

// Mock the clipboard utilities
jest.mock('../../src/lib/clipboard', () => ({
  copyToClipboard: jest.fn(),
  getClipboardCapabilities: jest.fn(() => ({
    hasModernApi: true,
    hasLegacySupport: true
  })),
  ClipboardError: class MockClipboardError extends Error {
    constructor(message: string) {
      super(message);
      this.name = 'ClipboardError';
    }
  }
}));

// Mock the ErrorBoundary component
jest.mock('../../src/components/ErrorBoundary', () => ({
  ErrorBoundary: ({ children }: { children: React.ReactNode }) => <>{children}</>
}));

// Mock the WalletErrorModal and ClipboardErrorModal components
jest.mock('../../src/components/WalletErrorModal', () => ({
  WalletErrorModal: ({ error, onDismiss }: any) => (
    <div data-testid="wallet-error-modal">
      {error && <div data-testid="wallet-error-message">{error.message}</div>}
      <button data-testid="dismiss-wallet-error" onClick={onDismiss}>
        Dismiss
      </button>
    </div>
  )
}));

jest.mock('../../src/components/ClipboardErrorModal', () => ({
  ClipboardErrorModal: ({ error, onDismiss, onTryAlternative }: any) => (
    <div data-testid="clipboard-error-modal">
      {error && <div data-testid="clipboard-error-message">{error.message}</div>}
      <button data-testid="dismiss-clipboard-error" onClick={onDismiss}>
        Dismiss
      </button>
      <button data-testid="try-alternative" onClick={onTryAlternative}>
        Try Alternative
      </button>
    </div>
  )
}));

describe('WalletConnectButton', () => {
  // Default mock values for wallet context
  const mockDisconnect = jest.fn().mockResolvedValue(undefined);
  const mockConnect = jest.fn().mockResolvedValue(undefined);
  const mockSwitchNetwork = jest.fn().mockResolvedValue(undefined);
  const mockSetError = jest.fn();
  
  // Default props for disconnected state
  const disconnectedProps = {
    connected: false,
    connecting: false,
    disconnect: mockDisconnect,
    connect: mockConnect,
    address: null,
    name: null,
    chainId: null,
    error: null,
    setError: mockSetError,
    switchNetwork: mockSwitchNetwork,
    transactions: [],
    trackTransaction: jest.fn(),
    lastActivity: Date.now(),
    resetActivityTimer: jest.fn()
  };
  
  // Default props for connected state
  const connectedProps = {
    ...disconnectedProps,
    connected: true,
    address: '0x123456789abcdef123456789abcdef123456789a',
    name: 'Test Wallet',
    chainId: 'testnet'
  };
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Default to disconnected state
    (useWalletContext as jest.Mock).mockReturnValue(disconnectedProps);
  });
  
  it('renders connect button when disconnected', () => {
    render(<WalletConnectButton />);
    
    // Should show connect button
    const connectButton = screen.getByText('Connect Wallet');
    expect(connectButton).toBeInTheDocument();
    
    // Should not show disconnect button
    expect(screen.queryByText('Disconnect')).not.toBeInTheDocument();
  });
  
  it('renders connecting state correctly', () => {
    (useWalletContext as jest.Mock).mockReturnValue({
      ...disconnectedProps,
      connecting: true
    });
    
    render(<WalletConnectButton />);
    
    // Should show connecting message
    expect(screen.getByText('Connecting...')).toBeInTheDocument();
    
    // Should not show connect or disconnect buttons
    expect(screen.queryByText('Connect Wallet')).not.toBeInTheDocument();
    expect(screen.queryByText('Disconnect')).not.toBeInTheDocument();
  });
  
  it('renders connected state with wallet info', () => {
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    render(<WalletConnectButton />);
    
    // Should show wallet info
    expect(screen.getByText(/Test Wallet:/)).toBeInTheDocument();
    expect(screen.getByText(/0x1234/)).toBeInTheDocument(); // Truncated address
    
    // Should show network
    expect(screen.getByText('Testnet')).toBeInTheDocument();
    
    // Should show disconnect button
    expect(screen.getByText('Disconnect')).toBeInTheDocument();
    
    // Should show change network button
    expect(screen.getByText('(change)')).toBeInTheDocument();
  });
  
  it('connects wallet when connect button is clicked', async () => {
    render(<WalletConnectButton />);
    
    // Click connect button
    fireEvent.click(screen.getByText('Connect Wallet'));
    
    // Check if connect was called
    expect(mockConnect).toHaveBeenCalledTimes(1);
  });
  
  it('disconnects wallet when disconnect button is clicked', async () => {
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    render(<WalletConnectButton />);
    
    // Click disconnect button
    fireEvent.click(screen.getByText('Disconnect'));
    
    // Check if disconnect was called
    expect(mockDisconnect).toHaveBeenCalledTimes(1);
  });
  
  it('shows network options when change button is clicked', () => {
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    render(<WalletConnectButton />);
    
    // Initially, network options should not be visible
    expect(screen.queryByText('Mainnet')).not.toBeInTheDocument();
    
    // Click change button
    fireEvent.click(screen.getByText('(change)'));
    
    // Now network options should be visible
    expect(screen.getByText('Mainnet')).toBeInTheDocument();
    expect(screen.getByText('Testnet')).toBeInTheDocument();
    expect(screen.getByText('Devnet')).toBeInTheDocument();
  });
  
  it('triggers network switch when a network option is clicked', async () => {
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    render(<WalletConnectButton />);
    
    // Click change button to show options
    fireEvent.click(screen.getByText('(change)'));
    
    // Click a network option
    fireEvent.click(screen.getByText('Mainnet'));
    
    // Check if switchNetwork was called with correct parameter
    expect(mockSwitchNetwork).toHaveBeenCalledWith('mainnet');
  });
  
  it('shows error modal when there is an error', () => {
    const error = new WalletError('Test wallet error');
    
    (useWalletContext as jest.Mock).mockReturnValue({
      ...disconnectedProps,
      error
    });
    
    render(<WalletConnectButton />);
    
    // Error modal should be visible with error message
    expect(screen.getByTestId('wallet-error-modal')).toBeInTheDocument();
    expect(screen.getByTestId('wallet-error-message')).toHaveTextContent('Test wallet error');
  });
  
  it('clears error when dismiss is clicked', () => {
    const error = new WalletError('Test wallet error');
    
    (useWalletContext as jest.Mock).mockReturnValue({
      ...disconnectedProps,
      error
    });
    
    render(<WalletConnectButton />);
    
    // Click dismiss button
    fireEvent.click(screen.getByTestId('dismiss-wallet-error'));
    
    // Check if setError was called with null
    expect(mockSetError).toHaveBeenCalledWith(null);
  });
  
  it('handles copy functionality for connected wallet address', async () => {
    // Mock copyToClipboard to succeed
    const { copyToClipboard } = require('../../src/lib/clipboard');
    copyToClipboard.mockResolvedValue({ success: true });
    
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    render(<WalletConnectButton />);
    
    // Find and click copy button (it's an SVG icon)
    const copyButton = screen.getByTitle('Copy address');
    fireEvent.click(copyButton);
    
    // Should have called copyToClipboard with the address
    expect(copyToClipboard).toHaveBeenCalledWith(connectedProps.address);
    
    // Wait for success message
    await waitFor(() => {
      expect(screen.getByText('Address copied to clipboard!')).toBeInTheDocument();
    });
  });
  
  it('handles copy failures and shows error message', async () => {
    // Mock copyToClipboard to fail
    const { copyToClipboard } = require('../../src/lib/clipboard');
    copyToClipboard.mockResolvedValue({ 
      success: false, 
      error: new ClipboardError('Failed to copy to clipboard') 
    });
    
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    render(<WalletConnectButton />);
    
    // Find and click copy button
    const copyButton = screen.getByTitle('Copy address');
    fireEvent.click(copyButton);
    
    // Should show clipboard error modal
    await waitFor(() => {
      expect(screen.getByTestId('clipboard-error-modal')).toBeInTheDocument();
      expect(screen.getByTestId('clipboard-error-message')).toHaveTextContent('Failed to copy to clipboard');
    });
  });
  
  it('disables network switching buttons during switch', async () => {
    // Start with connected state
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    // Mock switchNetwork to delay resolution
    mockSwitchNetwork.mockImplementation(() => new Promise(resolve => {
      setTimeout(resolve, 100);
    }));
    
    render(<WalletConnectButton />);
    
    // Click change button to show options
    fireEvent.click(screen.getByText('(change)'));
    
    // Click a network option
    fireEvent.click(screen.getByText('Mainnet'));
    
    // Check that "switching..." text appears
    await waitFor(() => {
      // This will pass once the component re-renders with isNetworkSwitching=true
      // We can't directly check for it since it's a state inside the component
      expect(screen.queryByText('(change)')).not.toBeInTheDocument();
      expect(screen.getByText('(switching...)')).toBeInTheDocument();
    });
    
    // Network options should be hidden during switching
    expect(screen.queryByText('Mainnet')).not.toBeInTheDocument();
    
    // Disconnect button should be disabled during switching
    expect(screen.getByText('Disconnect')).toBeDisabled();
  });
});
</file>

<file path="__tests__/contexts/WalletContext.test.tsx">
import React from 'react';
import { render, screen, waitFor, act, renderHook } from '@testing-library/react';
import { AppWalletProvider, useWalletContext } from '../../src/contexts/WalletContext';
import { nanoid } from 'nanoid';

// Mock the nanoid package
jest.mock('nanoid', () => ({
  nanoid: jest.fn(() => 'mocked-nanoid-value')
}));

// Mock the Suiet wallet kit
jest.mock('@suiet/wallet-kit', () => {
  const mockWalletHook = {
    connected: false,
    connecting: false,
    account: null,
    wallet: null,
    networkId: null,
    select: jest.fn(),
    connect: jest.fn(),
    disconnect: jest.fn(),
    executeMoveCall: jest.fn(),
    executeSerializedMoveCall: jest.fn(),
    signMessage: jest.fn(),
    signAndExecuteTransaction: jest.fn(),
    signTransaction: jest.fn(),
    on: jest.fn(),
    verifySignedMessage: jest.fn()
  };

  return {
    useWallet: jest.fn(() => mockWalletHook),
    WalletProvider: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
    AllDefaultWallets: ['mock-wallet-1', 'mock-wallet-2']
  };
});

// Mock window.localStorage
const localStorageMock = (() => {
  let store: Record<string, string> = {};
  return {
    getItem: jest.fn((key: string) => store[key] || null),
    setItem: jest.fn((key: string, value: string) => {
      store[key] = value;
    }),
    removeItem: jest.fn((key: string) => {
      delete store[key];
    }),
    clear: jest.fn(() => {
      store = {};
    })
  };
})();
Object.defineProperty(window, 'localStorage', { value: localStorageMock });

// Create a wrapper for testing hooks with the provider
const wrapper = ({ children }: { children: React.ReactNode }) => (
  <AppWalletProvider>{children}</AppWalletProvider>
);

describe('WalletContext', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    localStorageMock.clear();
  });

  it('should provide initial values', () => {
    const { result } = renderHook(() => useWalletContext(), { wrapper });
    
    // Check initial values
    expect(result.current.connected).toBe(false);
    expect(result.current.connecting).toBe(false);
    expect(result.current.address).toBeNull();
    expect(result.current.chainId).toBeNull();
    expect(result.current.name).toBeNull();
    expect(result.current.error).toBeNull();
    expect(result.current.transactions).toEqual([]);
    expect(result.current.lastActivity).toBeDefined();
    
    // Check that functions are defined
    expect(typeof result.current.connect).toBe('function');
    expect(typeof result.current.disconnect).toBe('function');
    expect(typeof result.current.switchNetwork).toBe('function');
    expect(typeof result.current.trackTransaction).toBe('function');
    expect(typeof result.current.setError).toBe('function');
    expect(typeof result.current.resetActivityTimer).toBe('function');
  });

  it('should maintain stable function references between renders', async () => {
    const { result, rerender } = renderHook(() => useWalletContext(), { wrapper });
    
    // Capture initial function references
    const initialConnect = result.current.connect;
    const initialDisconnect = result.current.disconnect;
    const initialSwitchNetwork = result.current.switchNetwork;
    const initialTrackTransaction = result.current.trackTransaction;
    
    // Force a re-render
    rerender();
    
    // Check that function references haven't changed
    expect(result.current.connect).toBe(initialConnect);
    expect(result.current.disconnect).toBe(initialDisconnect);
    expect(result.current.switchNetwork).toBe(initialSwitchNetwork);
    expect(result.current.trackTransaction).toBe(initialTrackTransaction);
  });

  it('should track transactions correctly', async () => {
    const { result } = renderHook(() => useWalletContext(), { wrapper });
    
    // Mock transaction promise
    const mockTransaction = Promise.resolve({ digest: 'mock-tx-hash' });
    
    // Track the transaction
    let txResult;
    await act(async () => {
      txResult = await result.current.trackTransaction(mockTransaction, 'TestTransaction');
    });
    
    // Check result
    expect(txResult).toEqual({ digest: 'mock-tx-hash' });
    
    // Check transaction was added to history
    expect(result.current.transactions).toHaveLength(1);
    expect(result.current.transactions[0]).toEqual(expect.objectContaining({
      id: 'mocked-nanoid-value',
      status: 'success',
      type: 'TestTransaction',
      hash: 'mock-tx-hash'
    }));
  });
  
  it('should handle failed transactions', async () => {
    const { result } = renderHook(() => useWalletContext(), { wrapper });
    
    // Mock failed transaction promise
    const mockError = new Error('Transaction failed');
    const mockFailedTransaction = Promise.reject(mockError);
    
    // Track the transaction (expecting it to fail)
    await act(async () => {
      try {
        await result.current.trackTransaction(mockFailedTransaction, 'FailedTransaction');
      } catch (error) {
        // Expected to fail
      }
    });
    
    // Check transaction was added to history with error status
    expect(result.current.transactions).toHaveLength(1);
    expect(result.current.transactions[0]).toEqual(expect.objectContaining({
      id: 'mocked-nanoid-value',
      status: 'error',
      type: 'FailedTransaction',
      message: 'Transaction failed'
    }));
  });

  it('should handle error states', async () => {
    const { result } = renderHook(() => useWalletContext(), { wrapper });
    
    // Set an error
    act(() => {
      result.current.setError(new Error('Test error'));
    });
    
    // Check error state
    expect(result.current.error).toEqual(new Error('Test error'));
    
    // Clear error
    act(() => {
      result.current.setError(null);
    });
    
    // Check error cleared
    expect(result.current.error).toBeNull();
  });

  it('should update lastActivity on resetActivityTimer', async () => {
    const { result } = renderHook(() => useWalletContext(), { wrapper });
    
    // Get initial lastActivity value
    const initialLastActivity = result.current.lastActivity;
    
    // Wait a bit to ensure time difference
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Reset activity timer
    act(() => {
      result.current.resetActivityTimer();
    });
    
    // Check lastActivity was updated
    expect(result.current.lastActivity).not.toBe(initialLastActivity);
    expect(result.current.lastActivity).toBeGreaterThan(initialLastActivity);
  });
  
  // Tests for localStorage persistence would go here, but they require more complex mocking
  // of the useWallet hook from @suiet/wallet-kit
});
</file>

<file path="__tests__/hooks/useInactivityTimer.test.tsx">
import { renderHook, act } from '@testing-library/react';
import { useInactivityTimer } from '../../src/contexts/WalletContext'; // Import the hook from actual file

// Mock the Date.now function
const mockDateNow = jest.fn(() => 1621234567890); // Fixed timestamp for testing
global.Date.now = mockDateNow;

describe('useInactivityTimer', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();
    mockDateNow.mockReturnValue(1621234567890); // Reset timestamp
    
    // Mock event listeners
    window.addEventListener = jest.fn();
    window.removeEventListener = jest.fn();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it('should initialize with current timestamp', () => {
    const onTimeout = jest.fn();
    const { result } = renderHook(() => useInactivityTimer(true, onTimeout));
    
    expect(result.current.lastActivity).toBe(1621234567890);
  });

  it('should not set up event listeners when not connected', () => {
    const onTimeout = jest.fn();
    renderHook(() => useInactivityTimer(false, onTimeout));
    
    expect(window.addEventListener).not.toHaveBeenCalled();
  });

  it('should set up event listeners when connected', () => {
    const onTimeout = jest.fn();
    renderHook(() => useInactivityTimer(true, onTimeout));
    
    // Check for 3 event listeners: mousedown, keydown, touchstart
    expect(window.addEventListener).toHaveBeenCalledTimes(3);
    expect(window.addEventListener).toHaveBeenCalledWith('mousedown', expect.any(Function));
    expect(window.addEventListener).toHaveBeenCalledWith('keydown', expect.any(Function));
    expect(window.addEventListener).toHaveBeenCalledWith('touchstart', expect.any(Function));
  });

  it('should reset lastActivity when resetActivityTimer is called', () => {
    const onTimeout = jest.fn();
    const { result } = renderHook(() => useInactivityTimer(true, onTimeout));
    
    // Update the mocked Date.now return value
    mockDateNow.mockReturnValue(1621234667890); // 100s later
    
    // Call resetActivityTimer
    act(() => {
      result.current.resetActivityTimer();
    });
    
    // Check if lastActivity was updated
    expect(result.current.lastActivity).toBe(1621234667890);
  });

  it('should call onTimeout when session times out', () => {
    const onTimeout = jest.fn();
    renderHook(() => useInactivityTimer(true, onTimeout));
    
    // Move time forward by less than timeout (29 min)
    mockDateNow.mockReturnValue(1621234567890 + 29 * 60 * 1000); 
    jest.advanceTimersByTime(60000); // Check every minute
    
    // onTimeout should not be called yet
    expect(onTimeout).not.toHaveBeenCalled();
    
    // Move time forward beyond timeout (31 min)
    mockDateNow.mockReturnValue(1621234567890 + 31 * 60 * 1000);
    jest.advanceTimersByTime(60000); // Another minute
    
    // onTimeout should be called
    expect(onTimeout).toHaveBeenCalledTimes(1);
  });

  it('should clean up event listeners on unmount', () => {
    const onTimeout = jest.fn();
    const { unmount } = renderHook(() => useInactivityTimer(true, onTimeout));
    
    unmount();
    
    // Check for 3 event listeners being removed
    expect(window.removeEventListener).toHaveBeenCalledTimes(3);
    expect(window.removeEventListener).toHaveBeenCalledWith('mousedown', expect.any(Function));
    expect(window.removeEventListener).toHaveBeenCalledWith('keydown', expect.any(Function));
    expect(window.removeEventListener).toHaveBeenCalledWith('touchstart', expect.any(Function));
  });

  it('should reset timer on user activity', () => {
    const onTimeout = jest.fn();
    renderHook(() => useInactivityTimer(true, onTimeout));
    
    // Capture the callback function registered with the event listener
    const handleActivity = (window.addEventListener as jest.Mock).mock.calls[0][1];
    
    // Mock Date.now to return a new value
    mockDateNow.mockReturnValue(1621234667890); // 100s later
    
    // Simulate user activity
    act(() => {
      handleActivity();
    });
    
    // Move time forward to what would have been a timeout from the original time
    mockDateNow.mockReturnValue(1621234567890 + 31 * 60 * 1000);
    jest.advanceTimersByTime(60000);
    
    // onTimeout should not be called because we reset the timer
    expect(onTimeout).not.toHaveBeenCalled();
    
    // But if we move time forward from the new activity time, it should trigger
    mockDateNow.mockReturnValue(1621234667890 + 31 * 60 * 1000);
    jest.advanceTimersByTime(60000);
    
    // Now onTimeout should be called
    expect(onTimeout).toHaveBeenCalledTimes(1);
  });
});
</file>

<file path="__tests__/integration/WalletIntegration.test.tsx">
import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { AppWalletProvider } from '../../src/contexts/WalletContext';
import { WalletConnectButton } from '../../src/components/WalletConnectButton';
import { TransactionHistory } from '../../src/components/TransactionHistory';
import { SessionTimeoutWarning } from '../../src/components/SessionTimeoutWarning';

// Mock the suiet wallet kit
jest.mock('@suiet/wallet-kit', () => {
  // We'll use this object to control the mock wallet behavior during tests
  const mockWalletState = {
    connected: false,
    connecting: false,
    account: null,
    wallet: null,
    networkId: null,
    error: null,
    
    // Methods that can be called to modify the mock state
    setConnected(value: boolean) {
      this.connected = value;
      if (value) {
        this.account = {
          address: '0x123456789abcdef123456789abcdef123456789a'
        };
        this.wallet = {
          name: 'Mock Sui Wallet',
          switchChain: jest.fn().mockImplementation(({ chainId }) => {
            mockWalletState.networkId = chainId;
            return Promise.resolve();
          })
        };
        this.networkId = 'testnet';
      } else {
        this.account = null;
        this.wallet = null;
        this.networkId = null;
      }
    },
    
    setConnecting(value: boolean) {
      this.connecting = value;
    },
    
    // Mock implementation will call these functions after a delay
    simulateConnect() {
      return new Promise<void>((resolve) => {
        this.setConnecting(true);
        
        setTimeout(() => {
          this.setConnecting(false);
          this.setConnected(true);
          resolve();
        }, 100);
      });
    },
    
    simulateDisconnect() {
      return new Promise<void>((resolve) => {
        setTimeout(() => {
          this.setConnected(false);
          resolve();
        }, 100);
      });
    }
  };
  
  // The exported hook that our components will call
  const useWallet = jest.fn(() => ({
    connected: mockWalletState.connected,
    connecting: mockWalletState.connecting,
    account: mockWalletState.account,
    wallet: mockWalletState.wallet,
    networkId: mockWalletState.networkId,
    error: mockWalletState.error,
    
    // Function implementations
    select: jest.fn(),
    connect: jest.fn().mockImplementation(() => mockWalletState.simulateConnect()),
    disconnect: jest.fn().mockImplementation(() => mockWalletState.simulateDisconnect()),
    on: jest.fn()
  }));
  
  return {
    useWallet,
    WalletProvider: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
    AllDefaultWallets: ['mock-wallet-1', 'mock-wallet-2'],
    
    // Expose the mock state for test manipulation
    __mockWalletState: mockWalletState
  };
});

// Mock nanoid for consistent transaction IDs
jest.mock('nanoid', () => ({
  nanoid: jest.fn(() => 'mocked-nanoid-value')
}));

// Test the entire wallet flow with multiple components
describe('Wallet Integration', () => {
  // Helper to get the mock wallet state
  const getMockWalletState = () => {
    return require('@suiet/wallet-kit').__mockWalletState;
  };
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Reset mock wallet to initial state
    const mockWalletState = getMockWalletState();
    mockWalletState.setConnected(false);
    mockWalletState.setConnecting(false);
    mockWalletState.error = null;
    
    // Mock Date.now for consistent testing
    jest.spyOn(Date, 'now').mockImplementation(() => 1621234567890);
    
    // Mock timers
    jest.useFakeTimers();
  });
  
  afterEach(() => {
    jest.useRealTimers();
  });

  // Test App component to wrap everything
  const TestApp = () => (
    <AppWalletProvider>
      <div>
        <WalletConnectButton />
        <TransactionHistory />
        <SessionTimeoutWarning />
      </div>
    </AppWalletProvider>
  );

  it('shows connect button when wallet is not connected', () => {
    render(<TestApp />);
    
    // Should show connect button
    expect(screen.getByText('Connect Wallet')).toBeInTheDocument();
    
    // Should not show transaction history (no content)
    expect(screen.getByText('No transactions yet')).toBeInTheDocument();
    
    // Should not show timeout warning
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });

  it('shows connecting UI during connection', async () => {
    render(<TestApp />);
    
    // Click connect
    fireEvent.click(screen.getByText('Connect Wallet'));
    
    // Should show connecting state
    expect(screen.getByText('Connecting...')).toBeInTheDocument();
    
    // Wait for connection to complete
    await act(async () => {
      jest.advanceTimersByTime(100);
    });
  });

  it('shows wallet info after successful connection', async () => {
    render(<TestApp />);
    
    // Click connect
    fireEvent.click(screen.getByText('Connect Wallet'));
    
    // Wait for connection to complete
    await act(async () => {
      jest.advanceTimersByTime(100);
    });
    
    // Should show wallet info
    expect(screen.getByText(/Mock Sui Wallet:/)).toBeInTheDocument();
    expect(screen.getByText(/Testnet/)).toBeInTheDocument();
    
    // Should show disconnect button
    expect(screen.getByText('Disconnect')).toBeInTheDocument();
  });

  it('changes network when network is selected', async () => {
    render(<TestApp />);
    
    // Connect wallet
    fireEvent.click(screen.getByText('Connect Wallet'));
    
    // Wait for connection to complete
    await act(async () => {
      jest.advanceTimersByTime(100);
    });
    
    // Click change network
    fireEvent.click(screen.getByText('(change)'));
    
    // Should show network options
    expect(screen.getByText('Mainnet')).toBeInTheDocument();
    
    // Select a different network
    fireEvent.click(screen.getByText('Mainnet'));
    
    // Should show switching indicator
    expect(screen.getByText('(switching...)')).toBeInTheDocument();
    
    // Mock the switchChain completion
    await act(async () => {
      // The network switching is handled by the mock implementation
      jest.advanceTimersByTime(100);
    });
    
    // Check if network was updated in the UI
    expect(screen.getByText('Mainnet')).toBeInTheDocument();
  });

  it('adds transactions to history when using trackTransaction', async () => {
    // This requires access to context directly, which isn't easy in this integration test
    // Typically would be separate component that uses the useWalletContext hook
    // For now, we'll skip actual transaction creation in this test
  });

  it('disconnects wallet when disconnect button is clicked', async () => {
    render(<TestApp />);
    
    // Connect wallet
    fireEvent.click(screen.getByText('Connect Wallet'));
    
    // Wait for connection to complete
    await act(async () => {
      jest.advanceTimersByTime(100);
    });
    
    // Should show wallet info
    expect(screen.getByText(/Mock Sui Wallet:/)).toBeInTheDocument();
    
    // Click disconnect
    fireEvent.click(screen.getByText('Disconnect'));
    
    // Wait for disconnection to complete
    await act(async () => {
      jest.advanceTimersByTime(100);
    });
    
    // Should show connect button again
    expect(screen.getByText('Connect Wallet')).toBeInTheDocument();
  });

  it('shows timeout warning when approaching session timeout', async () => {
    render(<TestApp />);
    
    // Connect wallet
    fireEvent.click(screen.getByText('Connect Wallet'));
    
    // Wait for connection to complete
    await act(async () => {
      jest.advanceTimersByTime(100);
    });
    
    // Set lastActivity to approach warning threshold
    const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
    const WARNING_THRESHOLD = 5 * 60 * 1000; // 5 minutes
    
    // Modify Date.now to simulate time passing to within warning period
    jest.spyOn(Date, 'now').mockImplementation(() => 
      1621234567890 + (SESSION_TIMEOUT - WARNING_THRESHOLD + 1000)
    );
    
    // Trigger the check interval
    await act(async () => {
      jest.advanceTimersByTime(30000); // 30 seconds (interval check)
    });
    
    // Warning should be visible
    expect(screen.getByText(/Session Timeout Warning/)).toBeInTheDocument();
    
    // Click "Stay Active"
    fireEvent.click(screen.getByText('Stay Active'));
    
    // Warning should be dismissed
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });
});
</file>

<file path="docs/FIXING_BROWSER_ERRORS.md">
# Fixing Browser Context and Security Errors

This guide addresses common browser security and context errors that may occur when running the Walrus Todo frontend application.

## Common Errors and Solutions

### 1. Storage Access Errors

**Error**: `Access to storage is not allowed from this context`

**Causes**:
- Application is running in an iframe with restricted permissions
- Browser privacy settings blocking third-party storage
- Application served over HTTP instead of HTTPS
- Content Security Policy restrictions

**Solutions**:

1. **Use HTTPS locally**:
   ```bash
   # Create a local certificate
   openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes
   
   # Update package.json to use HTTPS
   "scripts": {
     "dev": "next dev --experimental-https",
     "dev:https": "next dev --experimental-https-key key.pem --experimental-https-cert cert.pem"
   }
   ```

2. **Configure browser settings**:
   - Chrome: Settings → Privacy and security → Cookies → Allow all cookies
   - Firefox: Settings → Privacy & Security → Cookies and Site Data → Accept all cookies
   - Safari: Preferences → Privacy → Uncheck "Prevent cross-site tracking"

3. **Use the storage fallback**:
   The application now includes an in-memory fallback when localStorage is unavailable.

### 2. Wallet Connection Errors

**Error**: `WalletNotSelectedError`

**Causes**:
- Wallet extension not installed
- Wallet not initialized before connection attempt
- Page loaded before wallet injection

**Solutions**:

1. **Install required wallet extensions**:
   - For Sui: Install Sui Wallet, Suiet, or Martian
   - For Solana: Install Phantom wallet

2. **Wait for wallet initialization**:
   The application now includes proper wallet detection and error messages.

3. **Refresh the page**:
   Sometimes wallet extensions need a page refresh to properly inject.

### 3. Clipboard Access Errors

**Error**: `Copy to clipboard is not supported in this browser`

**Causes**:
- Non-secure context (HTTP instead of HTTPS)
- Browser doesn't support clipboard API
- Permissions not granted

**Solutions**:

1. **Use HTTPS**:
   Clipboard API requires a secure context (HTTPS or localhost)

2. **Grant permissions**:
   When prompted, allow clipboard access

3. **Use fallback method**:
   The application now includes a fallback clipboard method for older browsers

## Recommended Development Setup

### 1. Using Local HTTPS

```bash
# Install mkcert for local certificates
brew install mkcert # macOS
mkcert -install

# Create certificates
cd packages/frontend-v2
mkcert localhost 127.0.0.1 ::1

# Update next.config.js
module.exports = {
  server: {
    https: {
      key: fs.readFileSync('./localhost-key.pem'),
      cert: fs.readFileSync('./localhost.pem'),
    },
  },
}
```

### 2. Using Environment Variables

Create a `.env.local` file:

```bash
# Copy example configuration
cp .env.local.example .env.local

# Update values as needed
NEXT_PUBLIC_ENABLE_WALLET_WARNING=true
NEXT_PUBLIC_ENABLE_STORAGE_FALLBACK=true
```

### 3. Using Docker for HTTPS

```dockerfile
# Dockerfile
FROM node:18-alpine
WORKDIR /app
COPY . .
RUN npm install
RUN npm run build

# Use nginx for HTTPS
FROM nginx:alpine
COPY --from=0 /app/.next/static /usr/share/nginx/html/_next/static
COPY nginx.conf /etc/nginx/nginx.conf
COPY cert.pem /etc/nginx/cert.pem
COPY key.pem /etc/nginx/key.pem
```

## Testing in Different Contexts

### 1. Direct Browser Access
```bash
# HTTP (may have restrictions)
http://localhost:3001

# HTTPS (recommended)
https://localhost:3001
```

### 2. Iframe Testing
```html
<!-- test-iframe.html -->
<iframe src="http://localhost:3001" 
        allow="clipboard-read; clipboard-write; storage-access"
        width="100%" 
        height="600">
</iframe>
```

### 3. Cross-Origin Testing
```javascript
// Set CORS headers in next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: '/api/:path*',
        headers: [
          { key: 'Access-Control-Allow-Origin', value: '*' },
          { key: 'Access-Control-Allow-Methods', value: 'GET,POST,PUT,DELETE' },
        ],
      },
    ]
  },
}
```

## Browser-Specific Solutions

### Chrome/Edge
- Enable clipboard: `chrome://flags/#clipboard-unsanitized-content`
- Allow storage: `chrome://settings/content/cookies`

### Firefox
- Enable clipboard: `about:config` → `dom.allow_cut_copy` → true
- Allow storage: `about:preferences#privacy`

### Safari
- Enable clipboard: Preferences → Websites → Use of clipboard
- Allow storage: Preferences → Privacy → Website tracking

## Production Deployment

For production, ensure:

1. **Use HTTPS**: Deploy to a service that provides HTTPS by default (Vercel, Netlify, etc.)
2. **Set proper headers**: Configure Content Security Policy and CORS headers
3. **Handle errors gracefully**: Implement proper error boundaries and fallbacks
4. **Test across browsers**: Verify functionality in all target browsers

## Environment Detection

The application now includes automatic detection of:
- Storage availability
- Secure context
- Iframe context
- Clipboard support

A warning banner will appear when running in a restricted context, providing guidance to users.

## Troubleshooting

1. **Check browser console**: Look for specific error messages
2. **Verify wallet installation**: Ensure wallet extensions are properly installed
3. **Test in incognito mode**: Rule out extension conflicts
4. **Check network tab**: Verify all resources load correctly
5. **Use browser developer tools**: Check storage, cookies, and permissions

## Additional Resources

- [MDN: Secure Contexts](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts)
- [Chrome Storage Access API](https://developers.google.com/web/updates/2020/07/storage-access-api)
- [Clipboard API](https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API)
- [Wallet Adapter Documentation](https://github.com/solana-labs/wallet-adapter)
</file>

<file path="docs/FRONTEND_FIXES.md">
# Frontend Fixes Made

## Date: May 19, 2025

## Issue: Wallet Integration Problems

The frontend was encountering issues with the wallet integration due to conflicting implementations:

1. **Multiple wallet context implementations**:
   - `lib/walletContext.tsx` - Complex implementation with StashedWalletAdapter
   - `contexts/WalletContext.tsx` - Implementation using Suiet wallet integration
   - `contexts/SimpleWalletContext.tsx` - Simplified implementation for development

2. **StashedWalletAdapter missing**:
   - The `lib/walletContext.tsx` file was trying to use a StashedWalletAdapter that was no longer available
   - This caused import errors when trying to run the application

## Solutions Applied:

1. **Enable Simple Wallet Context**:
   - Ran the `enable-simple-wallet.sh` script to switch to the simplified wallet implementation
   - This fixed the import issues by using a simple wallet implementation that doesn't require external wallet adapters

2. **Fixed Manual Import Updates**:
   - The script didn't fully update all imports, so manual fixes were needed:
     - Updated import in `src/app/layout.tsx` to import SimpleWalletProvider
     - Updated import in `src/components/WalletConnectButton.tsx` to use the SimpleWalletContext

3. **Package.json Script Fix**:
   - Fixed the `dev:clean` script which was using yarn instead of pnpm:
     - Changed `"dev:clean": "yarn clean && next dev"` to `"dev:clean": "pnpm run clean && next dev"`

## Verification:

The application now successfully builds and runs in development mode. The wallet integration works correctly with the simplified implementation, allowing development to continue without external wallet dependencies.

## Implementation Details:

The `SimpleWalletContext` provides:
- A mock wallet address (0x7a40eb2bb8dcf8abe508e3f0dc49bade2935bd8c)
- Connect/disconnect functionality
- Network switching (mainnet, testnet, devnet)
- Mock transaction tracking
- Proper error handling

This implementation is perfect for development purposes, and when ready for production, the more complex wallet integrations can be re-enabled.
</file>

<file path="public/images/ocean-wave.svg">
<?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1440 320">
  <defs>
    <linearGradient id="oceanGradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:#0077b6;stop-opacity:0.7" />
      <stop offset="50%" style="stop-color:#48bfe3;stop-opacity:0.7" />
      <stop offset="100%" style="stop-color:#90e0ef;stop-opacity:0.7" />
    </linearGradient>
  </defs>
  <path fill="url(#oceanGradient)" fill-opacity="1" d="M0,192L48,181.3C96,171,192,149,288,154.7C384,160,480,192,576,202.7C672,213,768,203,864,181.3C960,160,1056,128,1152,138.7C1248,149,1344,203,1392,229.3L1440,256L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"></path>
</svg>
</file>

<file path="src/app/blockchain/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import Navbar from '@/components/navbar'
import { getTodosFromBlockchain } from '@/lib/sui-client'

export default function BlockchainPage() {
  const [nftTodos, setNftTodos] = useState<any[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState('')

  useEffect(() => {
    // Client-side code only
    const loadBlockchainTodos = async () => {
      try {
        setIsLoading(true)
        const todos = await getTodosFromBlockchain()
        setNftTodos(todos)
        setIsLoading(false)
      } catch (err) {
        console.error('Error loading blockchain todos:', err)
        setError('Failed to load NFT todos')
        setIsLoading(false)
      }
    }

    // Only run in browser environment
    if (typeof window !== 'undefined') {
      loadBlockchainTodos()
    }
  }, [])

  return (
    <div className="max-w-6xl mx-auto">
      <Navbar currentPage="blockchain" />
      
      <div className="mb-8">
        <h1 className="text-3xl font-bold mb-4 text-ocean-deep dark:text-ocean-foam">NFT Todos</h1>
        <p className="text-ocean-medium dark:text-ocean-light">
          Manage your blockchain-stored todo NFTs
        </p>
      </div>

      <div className="ocean-card">
        {isLoading ? (
          <div className="flex justify-center py-12">
            <div className="w-12 h-12 rounded-full border-4 border-ocean-light border-t-ocean-deep animate-spin"></div>
          </div>
        ) : error ? (
          <div className="text-center py-8 text-red-500">
            {error}
          </div>
        ) : nftTodos.length === 0 ? (
          <div className="text-center py-12">
            <p className="text-ocean-medium dark:text-ocean-light mb-4">No NFT todos found.</p>
            <p className="text-sm text-ocean-medium/70 dark:text-ocean-light/70 max-w-md mx-auto">
              You can create NFT todos by clicking "Store on Blockchain" for any of your existing todos in the dashboard.
            </p>
            <button 
              className="mt-6 ocean-button"
              onClick={() => window.location.href = '/dashboard'}
            >
              Go to Dashboard
            </button>
          </div>
        ) : (
          <div className="space-y-4">
            <h2 className="text-xl font-semibold mb-4 text-ocean-deep dark:text-ocean-foam">
              Your NFT Todos
            </h2>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {nftTodos.map((todo) => (
                <div 
                  key={todo.id} 
                  className="p-4 rounded-lg bg-white/30 dark:bg-ocean-deep/40 backdrop-blur-md border border-ocean-foam/50 dark:border-ocean-light/20 shadow-dreamy"
                >
                  <div className="flex items-start gap-3">
                    <div className="mt-1 w-5 h-5 rounded-full flex-shrink-0 border-2 border-dream-purple bg-dream-purple/20">
                      <span className="sr-only">NFT</span>
                    </div>
                    
                    <div className="flex-grow">
                      <div className="flex items-start justify-between">
                        <h3 className="font-medium text-ocean-deep dark:text-ocean-foam">
                          {todo.title}
                        </h3>
                        
                        <span className="text-xs px-2 py-0.5 rounded-full bg-dream-purple/20 text-dream-purple">
                          NFT
                        </span>
                      </div>
                      
                      {todo.description && (
                        <p className="mt-1 text-sm text-ocean-medium dark:text-ocean-light/80">
                          {todo.description}
                        </p>
                      )}
                      
                      <div className="mt-2 text-xs text-ocean-medium dark:text-ocean-light flex flex-col">
                        <span className="font-mono">Object ID: {todo.objectId || 'Unknown'}</span>
                        <span>Status: {todo.completed ? 'Completed' : 'Pending'}</span>
                      </div>
                    </div>
                  </div>
                  
                  <div className="mt-3 pt-3 border-t border-ocean-light/20 dark:border-ocean-medium/20 flex justify-end gap-2">
                    <button className="text-xs text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam transition-colors">
                      View on Explorer
                    </button>
                    <button className="text-xs text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam transition-colors">
                      Transfer
                    </button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/app/dashboard/page.tsx">
'use client'

import { useState } from 'react'
import Navbar from '@/components/navbar'
import TodoList from '@/components/todo-list'
import CreateTodoForm from '@/components/create-todo-form'

export default function Dashboard() {
  const [selectedList, setSelectedList] = useState('default')
  
  // Mock data - will be replaced with actual data from backend
  const mockLists = ['default', 'work', 'personal', 'shopping']
  
  return (
    <div className="max-w-6xl mx-auto">
      <Navbar currentPage="dashboard" />
      
      <div className="mb-8">
        <h1 className="text-3xl font-bold mb-4 text-ocean-deep dark:text-ocean-foam">Dashboard</h1>
        <p className="text-ocean-medium dark:text-ocean-light">Manage your todos across different lists</p>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
        <div className="md:col-span-1">
          <div className="ocean-card h-full">
            <h2 className="text-xl font-semibold mb-4 text-ocean-deep dark:text-ocean-foam">Your Lists</h2>
            
            <ul className="space-y-2">
              {mockLists.map((list) => (
                <li key={list} className="mb-1">
                  <button
                    className={`w-full text-left px-3 py-2 rounded-lg transition-colors ${
                      selectedList === list 
                        ? 'bg-ocean-medium text-white font-medium' 
                        : 'hover:bg-ocean-light/30 dark:hover:bg-ocean-medium/30'
                    }`}
                    onClick={() => setSelectedList(list)}
                  >
                    {list.charAt(0).toUpperCase() + list.slice(1)}
                  </button>
                </li>
              ))}
            </ul>
            
            <div className="mt-6">
              <button className="ocean-button w-full">
                <span>Create New List</span>
              </button>
            </div>
          </div>
        </div>
        
        <div className="md:col-span-3">
          <div className="ocean-card mb-6">
            <h2 className="text-xl font-semibold mb-4 text-ocean-deep dark:text-ocean-foam">
              Add New Todo
            </h2>
            <CreateTodoForm listName={selectedList} />
          </div>
          
          <div className="ocean-card">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-semibold text-ocean-deep dark:text-ocean-foam">
                {selectedList.charAt(0).toUpperCase() + selectedList.slice(1)} List
              </h2>
              
              <div className="flex space-x-2">
                <button className="px-3 py-1 text-sm bg-ocean-light/50 dark:bg-ocean-medium/50 rounded-lg hover:bg-ocean-light dark:hover:bg-ocean-medium transition-colors">
                  All
                </button>
                <button className="px-3 py-1 text-sm bg-ocean-light/30 dark:bg-ocean-medium/30 rounded-lg hover:bg-ocean-light dark:hover:bg-ocean-medium transition-colors">
                  Pending
                </button>
                <button className="px-3 py-1 text-sm bg-ocean-light/30 dark:bg-ocean-medium/30 rounded-lg hover:bg-ocean-light dark:hover:bg-ocean-medium transition-colors">
                  Completed
                </button>
              </div>
            </div>
            
            <TodoList listName={selectedList} />
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/examples/page.tsx">
import Navbar from '@/components/navbar';
import WalletUsageExample from './wallet-usage';

export default function ExamplesPage() {
  return (
    <>
      <Navbar currentPage="examples" />
      
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-3xl font-bold text-ocean-deep dark:text-ocean-foam mb-8">
          Code Examples
        </h1>
        
        <div className="grid gap-8">
          <div className="ocean-card">
            <WalletUsageExample />
          </div>
        </div>
      </div>
    </>
  );
}
</file>

<file path="src/app/examples/wallet-usage.tsx">
'use client';

/**
 * Example: How to use the updated wallet integration in components
 */

import { useState } from 'react';
import { useWalletContext } from '@/contexts/WalletContext';
import { storeTodoOnBlockchain } from '@/lib/todo-service';
import { TransactionHistory } from '@/components/TransactionHistory';

export default function WalletUsageExample() {
  const {
    connected,
    address,
    chainId,
    name: walletName,
    connect,
    disconnect,
    switchNetwork,
    trackTransaction
  } = useWalletContext();

  const [transactionStatus, setTransactionStatus] = useState<'idle' | 'pending' | 'success' | 'error'>('idle');
  const [transactionId, setTransactionId] = useState<string | null>(null);

  // Example of how to store a todo on blockchain with transaction tracking
  const handleStoreOnBlockchain = async (listName: string, todoId: string) => {
    if (!connected) {
      alert('Please connect your wallet first');
      return;
    }

    setTransactionStatus('pending');

    try {
      // Use trackTransaction to track the transaction progress
      const result = await trackTransaction(
        storeTodoOnBlockchain(listName, todoId), 
        'StoreTodo'
      );

      console.log('Todo stored with ID:', result);
      setTransactionStatus('success');
      setTransactionId(result.objectId);
    } catch (error) {
      console.error('Transaction failed:', error);
      setTransactionStatus('error');
    }
  };

  return (
    <div className="p-4 ocean-card">
      <h2 className="text-xl font-bold mb-4">Wallet Usage Example</h2>
      
      <div className="space-y-4">
        <div className="p-4 bg-ocean-deep/10 rounded-lg">
          <p><span className="font-medium">Connected:</span> {connected ? 'Yes' : 'No'}</p>
          <p><span className="font-medium">Wallet:</span> {walletName || 'None'}</p>
          <p><span className="font-medium">Address:</span> {address || 'Not connected'}</p>
          <p><span className="font-medium">Network:</span> {chainId || 'Unknown'}</p>
        </div>

        {/* Wallet connection controls */}
        <div className="flex gap-4 flex-wrap">
          {!connected ? (
            <button
              onClick={() => connect()}
              className="px-4 py-2 bg-ocean-deep text-white rounded-lg hover:bg-ocean-deep/80"
            >
              Connect Wallet
            </button>
          ) : (
            <button
              onClick={() => disconnect()}
              className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600"
            >
              Disconnect
            </button>
          )}

          {/* Network switching example */}
          {connected && (
            <div className="flex gap-2">
              <button
                onClick={() => switchNetwork('mainnet')}
                className={`px-4 py-2 rounded-lg ${
                  chainId === 'mainnet' 
                    ? 'bg-green-500 text-white' 
                    : 'bg-gray-200 hover:bg-gray-300'
                }`}
              >
                Mainnet
              </button>
              <button
                onClick={() => switchNetwork('testnet')}
                className={`px-4 py-2 rounded-lg ${
                  chainId === 'testnet' 
                    ? 'bg-green-500 text-white' 
                    : 'bg-gray-200 hover:bg-gray-300'
                }`}
              >
                Testnet
              </button>
              <button
                onClick={() => switchNetwork('devnet')}
                className={`px-4 py-2 rounded-lg ${
                  chainId === 'devnet' 
                    ? 'bg-green-500 text-white' 
                    : 'bg-gray-200 hover:bg-gray-300'
                }`}
              >
                Devnet
              </button>
            </div>
          )}
        </div>

        {/* Transaction example section */}
        <div className="mt-6">
          <h3 className="text-lg font-medium mb-2">Transaction Example</h3>
          <div className="flex gap-4 items-center">
            <button
              onClick={() => handleStoreOnBlockchain('default', '123')}
              disabled={!connected || transactionStatus === 'pending'}
              className="px-4 py-2 bg-blue-500 text-white rounded disabled:bg-gray-300 disabled:cursor-not-allowed"
            >
              {transactionStatus === 'pending' ? 'Processing...' : 'Store Todo on Blockchain'}
            </button>
            
            {/* Transaction status indicator */}
            {transactionStatus === 'pending' && (
              <div className="text-yellow-600">Transaction in progress...</div>
            )}
            {transactionStatus === 'success' && (
              <div className="text-green-600">
                Transaction successful! Object ID: {transactionId}
              </div>
            )}
            {transactionStatus === 'error' && (
              <div className="text-red-600">Transaction failed. Please try again.</div>
            )}
          </div>
        </div>
        
        {/* Transaction History */}
        <div className="mt-6">
          <h3 className="text-lg font-medium mb-2">Transaction History</h3>
          <TransactionHistory maxItems={3} />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/layout.tsx">
import '@/styles/globals.css'
import type { Metadata } from 'next'
import { SimpleWalletProvider } from '@/contexts/SimpleWalletContext'
import { ContextWarning } from '@/components/context-warning'
import { ErrorBoundary } from '@/components/ErrorBoundary'
import { SessionTimeoutWarning } from '@/components/SessionTimeoutWarning'

// Using system fonts to avoid network issues with Google Fonts

export const metadata: Metadata = {
  title: 'Walrus Todo - Web3 Task Management',
  description: 'A blockchain-powered todo application with oceanic design',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className="font-sans wave-animation">
        <ErrorBoundary>
          <SimpleWalletProvider>
            <ContextWarning />
            <main className="container mx-auto px-4 py-8">
              {children}
            </main>
            <footer className="mt-auto py-6 text-center text-sm text-ocean-deep dark:text-ocean-foam">
              <p>Powered by Sui Blockchain and Walrus Storage</p>
            </footer>
            <SessionTimeoutWarning />
          </SimpleWalletProvider>
        </ErrorBoundary>
      </body>
    </html>
  )
}
</file>

<file path="src/app/page.tsx">
'use client'

import { useState } from 'react'
import Link from 'next/link'
import Navbar from '@/components/navbar'

export default function Home() {
  const [isConnecting, setIsConnecting] = useState(false)

  const handleConnect = async () => {
    setIsConnecting(true)
    // Connection logic will be added later
    setTimeout(() => setIsConnecting(false), 1500)
  }

  return (
    <>
      <Navbar currentPage="home" />
      <div className="flex flex-col items-center justify-center min-h-[80vh] text-center">
      <div className="floating-element mb-8">
        <div className="relative w-32 h-32 md:w-48 md:h-48 mx-auto">
          {/* Replace with your app logo */}
          <div className="w-full h-full rounded-full bg-gradient-to-br from-ocean-light to-dream-teal shadow-dreamy flex items-center justify-center text-4xl md:text-6xl text-white font-bold">
            WT
          </div>
        </div>
      </div>
      
      <h1 className="text-4xl md:text-6xl font-bold mb-4 text-ocean-deep dark:text-ocean-foam">
        <span className="inline-block animate-float">Walrus</span> <span className="inline-block animate-float animation-delay-300">Todo</span>
      </h1>
      
      <p className="text-xl mb-8 max-w-2xl text-ocean-medium dark:text-ocean-light">
        A dreamy, oceanic Web3 task management experience powered by Sui blockchain and Walrus decentralized storage
      </p>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-12">
        <div className="ocean-card max-w-sm transform transition-all hover:scale-105">
          <h2 className="text-2xl font-semibold mb-3 text-ocean-deep dark:text-ocean-foam">Decentralized Tasks</h2>
          <p className="text-ocean-medium dark:text-ocean-light mb-4">
            Store your todos securely on the blockchain as NFTs that can be transferred and shared.
          </p>
        </div>
        
        <div className="ocean-card max-w-sm transform transition-all hover:scale-105">
          <h2 className="text-2xl font-semibold mb-3 text-ocean-deep dark:text-ocean-foam">AI-Powered</h2>
          <p className="text-ocean-medium dark:text-ocean-light mb-4">
            Get intelligent suggestions, categorization, and prioritization for your tasks.
          </p>
        </div>
      </div>
      
      <button 
        className="ocean-button group relative overflow-hidden"
        onClick={handleConnect}
        disabled={isConnecting}
      >
        <span className="relative z-10">
          {isConnecting ? 'Connecting...' : 'Connect Wallet to Begin'}
        </span>
        <span className="absolute inset-0 bg-gradient-to-r from-dream-teal to-dream-purple opacity-0 group-hover:opacity-30 transition-opacity duration-300"></span>
      </button>
      
      <div className="mt-12 flex gap-6">
        <Link href="/about" className="text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam transition-colors">
          Learn More
        </Link>
        <Link href="/dashboard" className="text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam transition-colors">
          View Dashboard
        </Link>
      </div>
    </div>
    </>
  )
}
</file>

<file path="src/components/ClipboardErrorModal.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { ClipboardError, getClipboardCapabilities } from '@/lib/clipboard';

interface ClipboardErrorModalProps {
  error: ClipboardError | null;
  onDismiss: () => void;
  onTryAlternative?: () => void;
}

export function ClipboardErrorModal({ 
  error, 
  onDismiss,
  onTryAlternative 
}: ClipboardErrorModalProps) {
  const [isVisible, setIsVisible] = useState(false);
  
  useEffect(() => {
    if (error) {
      setIsVisible(true);
    } else {
      setIsVisible(false);
    }
  }, [error]);
  
  if (!error || !isVisible) {
    return null;
  }
  
  const capabilities = getClipboardCapabilities();
  
  // Determine title and message based on error type
  const getErrorInfo = () => {
    const errorName = error.name;
    
    if (errorName === 'ClipboardApiNotSupportedError') {
      return {
        title: 'Clipboard Not Supported',
        message: 'Your browser does not support clipboard operations.',
        suggestion: capabilities.hasLegacySupport 
          ? 'Try using keyboard shortcuts instead (Ctrl+C/Cmd+C)'
          : 'Try using a different browser with clipboard support.'
      };
    }
    
    if (errorName === 'ClipboardPermissionDeniedError') {
      return {
        title: 'Permission Denied',
        message: 'The browser denied permission to access the clipboard.',
        suggestion: 'Try again after clicking somewhere on the page, or use keyboard shortcuts instead.'
      };
    }
    
    if (errorName === 'InsecureContextError') {
      return {
        title: 'Secure Context Required',
        message: 'Clipboard access requires a secure context (HTTPS).',
        suggestion: 'Try accessing this site over HTTPS instead.'
      };
    }
    
    if (errorName === 'ClipboardPolyfillError') {
      return {
        title: 'Clipboard Fallback Failed',
        message: 'The clipboard fallback mechanism failed.',
        suggestion: 'Try using keyboard shortcuts to copy text manually.'
      };
    }
    
    // Default case
    return {
      title: 'Clipboard Error',
      message: error.message || 'An error occurred while accessing the clipboard.',
      suggestion: 'Try using keyboard shortcuts instead (Ctrl+C/Cmd+C).'
    };
  };
  
  const { title, message, suggestion } = getErrorInfo();
  
  const handleDismiss = () => {
    setIsVisible(false);
    onDismiss();
  };
  
  return (
    <div className="fixed inset-0 flex items-center justify-center p-4 bg-black/50 z-50">
      <div className="max-w-md w-full rounded-lg bg-white dark:bg-gray-800 shadow-lg overflow-hidden transform transition-all">
        <div className="p-4">
          <div className="flex items-start">
            <div className="flex-shrink-0">
              <svg className="w-6 h-6 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
              </svg>
            </div>
            <div className="ml-3 flex-1">
              <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                {title}
              </h3>
              <div className="mt-2">
                <p className="text-sm text-gray-700 dark:text-gray-300">
                  {message}
                </p>
                {suggestion && (
                  <p className="text-sm text-gray-600 dark:text-gray-400 mt-2">
                    <strong>Suggestion:</strong> {suggestion}
                  </p>
                )}
              </div>
              <div className="mt-4 flex justify-end space-x-3">
                {onTryAlternative && (
                  <button
                    type="button"
                    onClick={() => {
                      handleDismiss();
                      onTryAlternative();
                    }}
                    className="inline-flex justify-center px-4 py-2 text-sm font-medium text-ocean-deep bg-ocean-light/30 rounded-md hover:bg-ocean-light/50 focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-ocean-light"
                  >
                    Try Alternative
                  </button>
                )}
                <button
                  type="button"
                  onClick={handleDismiss}
                  className="inline-flex justify-center px-4 py-2 text-sm font-medium text-white bg-ocean-medium rounded-md hover:bg-ocean-deep focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-ocean-light"
                >
                  Got it
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/context-warning.tsx">
'use client';

import { useEffect, useState } from 'react';

export function ContextWarning() {
  const [showWarning, setShowWarning] = useState(false);
  const [warnings, setWarnings] = useState<string[]>([]);

  useEffect(() => {
    // Only run in browser environment
    if (typeof window === 'undefined') return;

    const detectedWarnings: string[] = [];

    // Check if storage is blocked - using safer approach
    try {
      const testKey = '__test__';
      // Try-catch each storage operation individually
      try {
        localStorage.setItem(testKey, testKey);
        try {
          localStorage.removeItem(testKey);
        } catch (removeErr) {
          console.warn('Error removing test key from localStorage:', removeErr);
        }
      } catch (e) {
        detectedWarnings.push('Storage access is restricted. Some features may not work properly.');
      }
    } catch (outerErr) {
      // Catch any errors from accessing localStorage itself
      console.warn('Error accessing localStorage:', outerErr);
      detectedWarnings.push('Storage access is restricted. Some features may not work properly.');
    }

    // Check if in secure context - using safer approach
    try {
      if (!window.isSecureContext) {
        detectedWarnings.push('This app is not running in a secure context (HTTPS). Some features like clipboard access may be limited.');
      }
    } catch (e) {
      console.warn('Error checking for secure context:', e);
    }

    // Check if in iframe - using safer approach
    try {
      let isInIframe = false;
      try {
        isInIframe = window.self !== window.top;
      } catch (frameErr) {
        // If this errors, we're probably in a cross-origin iframe
        isInIframe = true;
      }
      
      if (isInIframe) {
        detectedWarnings.push('This app is running in an iframe. Some features may be restricted.');
      }
    } catch (e) {
      console.warn('Error checking for iframe context:', e);
    }

    if (detectedWarnings.length > 0) {
      setWarnings(detectedWarnings);
      setShowWarning(true);
    }
  }, []);

  if (!showWarning || warnings.length === 0) return null;

  return (
    <div className="fixed top-0 left-0 right-0 z-50 bg-yellow-50 dark:bg-yellow-900 border-b border-yellow-200 dark:border-yellow-700">
      <div className="container mx-auto px-4 py-3">
        <div className="flex items-start justify-between">
          <div className="flex-1">
            <p className="text-sm font-medium text-yellow-800 dark:text-yellow-200">
              Security Context Warning
            </p>
            <ul className="mt-1 text-sm text-yellow-700 dark:text-yellow-300">
              {warnings.map((warning, index) => (
                <li key={index} className="list-disc list-inside">
                  {warning}
                </li>
              ))}
            </ul>
            <p className="mt-2 text-xs text-yellow-600 dark:text-yellow-400">
              For the best experience, access this app via HTTPS at{' '}
              <code>https://localhost:3001</code> or deploy to a secure domain.
            </p>
          </div>
          <button
            onClick={() => setShowWarning(false)}
            className="ml-4 text-yellow-800 dark:text-yellow-200 hover:text-yellow-900 dark:hover:text-yellow-100"
            aria-label="Dismiss"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/create-todo-form.tsx">
'use client'

import { useState } from 'react'

type CreateTodoFormProps = {
  listName: string
}

export default function CreateTodoForm({ listName }: CreateTodoFormProps) {
  const [title, setTitle] = useState('')
  const [description, setDescription] = useState('')
  const [priority, setPriority] = useState<'low' | 'medium' | 'high'>('medium')
  const [tags, setTags] = useState('')
  const [dueDate, setDueDate] = useState('')
  const [useAI, setUseAI] = useState(false)
  const [isSubmitting, setIsSubmitting] = useState(false)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!title.trim()) return
    
    setIsSubmitting(true)
    
    // Will be replaced with actual API call
    await new Promise(resolve => setTimeout(resolve, 1000))
    
    // Reset form
    setTitle('')
    setDescription('')
    setPriority('medium')
    setTags('')
    setDueDate('')
    setUseAI(false)
    setIsSubmitting(false)
    
    // Toast or notification would be added here
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <input
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="What needs to be done?"
          className="ocean-input w-full"
          required
        />
      </div>
      
      <div>
        <textarea
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          placeholder="Add a description (optional)"
          className="ocean-input w-full h-20 resize-none"
        />
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div>
          <label className="block text-sm text-ocean-medium dark:text-ocean-light mb-1">
            Priority
          </label>
          <select
            value={priority}
            onChange={(e) => setPriority(e.target.value as 'low' | 'medium' | 'high')}
            className="ocean-input w-full"
          >
            <option value="low">Low</option>
            <option value="medium">Medium</option>
            <option value="high">High</option>
          </select>
        </div>
        
        <div>
          <label className="block text-sm text-ocean-medium dark:text-ocean-light mb-1">
            Tags (comma separated)
          </label>
          <input
            type="text"
            value={tags}
            onChange={(e) => setTags(e.target.value)}
            placeholder="work, important, etc."
            className="ocean-input w-full"
          />
        </div>
        
        <div>
          <label className="block text-sm text-ocean-medium dark:text-ocean-light mb-1">
            Due Date (optional)
          </label>
          <input
            type="date"
            value={dueDate}
            onChange={(e) => setDueDate(e.target.value)}
            className="ocean-input w-full"
          />
        </div>
      </div>
      
      <div className="flex items-center">
        <input
          type="checkbox"
          id="useAI"
          checked={useAI}
          onChange={(e) => setUseAI(e.target.checked)}
          className="w-4 h-4 rounded text-ocean-medium focus:ring-ocean-light"
        />
        <label htmlFor="useAI" className="ml-2 text-sm text-ocean-medium dark:text-ocean-light">
          Use AI to suggest tags and priority
        </label>
      </div>
      
      <div className="flex justify-between items-center pt-2">
        <div className="text-sm text-ocean-medium dark:text-ocean-light">
          Adding to: <span className="font-medium">{listName}</span>
        </div>
        
        <button
          type="submit"
          disabled={isSubmitting || !title.trim()}
          className={`ocean-button ${
            (isSubmitting || !title.trim()) ? 'opacity-70 cursor-not-allowed' : ''
          }`}
        >
          {isSubmitting ? 'Adding...' : 'Add Todo'}
        </button>
      </div>
    </form>
  )
}
</file>

<file path="src/components/ErrorBoundary.tsx">
'use client';

import React, { ReactNode, useEffect, useState } from 'react';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

export function ErrorBoundary({ children, fallback }: ErrorBoundaryProps) {
  const [hasError, setHasError] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    // Only run in the browser
    if (typeof window === 'undefined') return;
    
    // Set up global error handler for uncaught errors
    const errorHandler = (event: ErrorEvent) => {
      console.error('[ErrorBoundary] Caught error:', event.error);
      
      // Special handling for storage access errors
      if (event.error?.message?.includes('Access to storage is not allowed') || 
          event.error?.message?.includes('localStorage') ||
          event.error?.message?.includes('sessionStorage')) {
        
        console.warn('[ErrorBoundary] Storage access error caught. Using in-memory fallback.');
        // Don't set error state for these specific errors
        // They'll be handled by the storage utility's fallback
        
        // Still prevent default to stop error propagation
        event.preventDefault();
        return;
      }
      
      setError(event.error instanceof Error ? event.error : new Error(String(event.error)));
      setHasError(true);
      
      // Prevent the error from propagating
      event.preventDefault();
    };

    // Set up handler for unhandled promise rejections
    const rejectionHandler = (event: PromiseRejectionEvent) => {
      console.error('[ErrorBoundary] Unhandled rejection:', event.reason);
      
      // Special handling for storage access rejections
      const rejectionString = String(event.reason);
      if (rejectionString.includes('Access to storage is not allowed') || 
          rejectionString.includes('localStorage') ||
          rejectionString.includes('sessionStorage')) {
        
        console.warn('[ErrorBoundary] Storage access rejection caught. Using in-memory fallback.');
        // Don't set error state for these specific errors
        
        // Still prevent default to stop error propagation
        event.preventDefault();
        return;
      }
      
      setError(event.reason instanceof Error ? event.reason : new Error(String(event.reason)));
      setHasError(true);
      
      // Prevent the error from propagating
      event.preventDefault();
    };

    // Add event listeners
    window.addEventListener('error', errorHandler);
    window.addEventListener('unhandledrejection', rejectionHandler);

    // Clean up on unmount
    return () => {
      window.removeEventListener('error', errorHandler);
      window.removeEventListener('unhandledrejection', rejectionHandler);
    };
  }, []);

  // Reset error state
  const resetError = () => {
    setHasError(false);
    setError(null);
  };

  // Default fallback UI
  const defaultFallback = (
    <div className="p-4 border border-red-500 rounded bg-red-50 text-red-900 m-4">
      <h2 className="text-lg font-bold mb-2">Something went wrong</h2>
      <p className="mb-2">
        {error?.message || 'An unexpected error occurred'}
      </p>
      {process.env.NODE_ENV !== 'production' && error?.stack && (
        <pre className="text-xs mt-2 p-2 bg-red-100 overflow-auto max-h-[200px]">
          {error.stack}
        </pre>
      )}
      <button
        onClick={resetError}
        className="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
      >
        Try Again
      </button>
    </div>
  );

  // Show the fallback UI if there's an error
  if (hasError) {
    return fallback || defaultFallback;
  }

  // Otherwise, render children normally
  return <>{children}</>;
}
</file>

<file path="src/components/ErrorHandlingProvider.tsx">
'use client';

import React, { ReactNode } from 'react';
import { StorageContextWarning } from './StorageContextWarning';
import { isUsingFallbackStorage } from '@/lib/storage-utils';

interface ErrorHandlingProviderProps {
  children: ReactNode;
}

/**
 * Global error handling provider that wraps the application
 * and provides warnings and fallbacks for common errors
 */
export function ErrorHandlingProvider({ children }: ErrorHandlingProviderProps) {
  // Only show storage warning if fallback is in use
  const showStorageWarning = isUsingFallbackStorage();
  
  return (
    <div className="relative">
      {/* Show storage context warning at the top of the app when needed */}
      {showStorageWarning && (
        <div className="sticky top-0 z-50 w-full">
          <StorageContextWarning />
        </div>
      )}
      
      {/* Render the application */}
      {children}
    </div>
  );
}
</file>

<file path="src/components/navbar.tsx">
'use client'

import { useState } from 'react'
import Link from 'next/link'
import { WalletConnectButton } from '@/components/WalletConnectButton'

type NavbarProps = {
  currentPage: string
}

export default function Navbar({ currentPage }: NavbarProps) {
  const [isWalletModalOpen, setIsWalletModalOpen] = useState(false)

  return (
    <header className="py-4 mb-8">
      <nav className="ocean-card flex justify-between items-center">
        <div className="flex items-center gap-2">
          <div className="w-10 h-10 rounded-full bg-gradient-to-br from-ocean-light to-dream-teal shadow-dreamy flex items-center justify-center text-lg text-white font-bold">
            WT
          </div>
          <Link href="/" className="text-xl font-bold text-ocean-deep dark:text-ocean-foam">
            Walrus Todo
          </Link>
        </div>

        <div className="hidden md:flex items-center space-x-6">
          <Link
            href="/"
            className={`transition-colors ${
              currentPage === 'home'
                ? 'text-ocean-deep dark:text-ocean-foam font-medium'
                : 'text-ocean-medium dark:text-ocean-light hover:text-ocean-deep dark:hover:text-ocean-foam'
            }`}
          >
            Home
          </Link>
          <Link
            href="/dashboard"
            className={`transition-colors ${
              currentPage === 'dashboard'
                ? 'text-ocean-deep dark:text-ocean-foam font-medium'
                : 'text-ocean-medium dark:text-ocean-light hover:text-ocean-deep dark:hover:text-ocean-foam'
            }`}
          >
            Dashboard
          </Link>
          <Link
            href="/blockchain"
            className={`transition-colors ${
              currentPage === 'blockchain'
                ? 'text-ocean-deep dark:text-ocean-foam font-medium'
                : 'text-ocean-medium dark:text-ocean-light hover:text-ocean-deep dark:hover:text-ocean-foam'
            }`}
          >
            NFT Todos
          </Link>
        </div>

        <div>
          <WalletConnectButton />
        </div>
      </nav>

    </header>
  )
}
</file>

<file path="src/components/SessionTimeoutWarning.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { useWalletContext } from '@/contexts/WalletContext';

// Session timeout in milliseconds (30 minutes)
const SESSION_TIMEOUT = 30 * 60 * 1000;

// Warning threshold in milliseconds (5 minutes before timeout)
const WARNING_THRESHOLD = 5 * 60 * 1000;

export function SessionTimeoutWarning() {
  const { connected, lastActivity, resetActivityTimer } = useWalletContext();
  const [showWarning, setShowWarning] = useState(false);
  const [timeRemaining, setTimeRemaining] = useState<number>(0);

  useEffect(() => {
    if (!connected) {
      setShowWarning(false);
      return;
    }

    // Check every 30 seconds to see if we're approaching timeout
    const interval = setInterval(() => {
      const now = Date.now();
      const timeSinceLastActivity = now - lastActivity;
      const timeUntilTimeout = SESSION_TIMEOUT - timeSinceLastActivity;
      
      // If we're within the warning threshold, show the warning
      if (timeUntilTimeout <= WARNING_THRESHOLD && timeUntilTimeout > 0) {
        setShowWarning(true);
        setTimeRemaining(timeUntilTimeout);
      } else {
        setShowWarning(false);
      }
    }, 30000); // Check every 30 seconds
    
    return () => clearInterval(interval);
  }, [connected, lastActivity]);

  // Update countdown timer every second when warning is shown
  useEffect(() => {
    if (!showWarning) return;
    
    const timer = setInterval(() => {
      const now = Date.now();
      const timeSinceLastActivity = now - lastActivity;
      const timeUntilTimeout = SESSION_TIMEOUT - timeSinceLastActivity;
      
      if (timeUntilTimeout <= 0) {
        setShowWarning(false);
        clearInterval(timer);
      } else {
        setTimeRemaining(timeUntilTimeout);
      }
    }, 1000);
    
    return () => clearInterval(timer);
  }, [showWarning, lastActivity]);

  // Format time remaining in minutes and seconds
  const formatTimeRemaining = () => {
    const minutes = Math.floor(timeRemaining / 60000);
    const seconds = Math.floor((timeRemaining % 60000) / 1000);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  // Stay active button handler
  const handleStayActive = () => {
    resetActivityTimer();
    setShowWarning(false);
  };

  if (!showWarning) return null;

  return (
    <div className="fixed bottom-4 right-4 w-80 bg-white dark:bg-slate-800 shadow-lg rounded-lg overflow-hidden border border-yellow-500 z-50">
      <div className="bg-yellow-100 dark:bg-yellow-900/30 px-4 py-2 flex items-center gap-2">
        <svg className="w-5 h-5 text-yellow-600 dark:text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
        </svg>
        <h3 className="font-medium text-yellow-800 dark:text-yellow-200">Session Timeout Warning</h3>
      </div>
      <div className="p-4">
        <p className="text-sm text-gray-700 dark:text-gray-300 mb-3">
          Your wallet session will expire in <span className="font-bold">{formatTimeRemaining()}</span> due to inactivity.
        </p>
        <div className="mt-3 flex justify-between">
          <button
            onClick={handleStayActive}
            className="px-4 py-2 bg-ocean-deep text-white text-sm rounded hover:bg-ocean-deep/80 transition-colors"
          >
            Stay Active
          </button>
          <button
            onClick={() => setShowWarning(false)}
            className="px-4 py-2 bg-transparent text-gray-500 text-sm hover:text-gray-700 transition-colors"
          >
            Dismiss
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/StorageContextWarning.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { detectContext, isUsingFallbackStorage, StorageContext } from '@/lib/storage-utils';

interface WarningMessageProps {
  context: StorageContext;
  usingFallback: boolean;
}

const WarningMessage: React.FC<WarningMessageProps> = ({ context, usingFallback }) => {
  if (!usingFallback) return null;
  
  const getMessageForContext = (): { title: string; message: string } => {
    switch (context) {
      case 'extension':
        return {
          title: 'Extension Storage Mode',
          message: 'Your data will not persist between sessions in this extension context.'
        };
      case 'iframe':
        return {
          title: 'Restricted Storage',
          message: 'This app is running in an iframe with limited storage access. Your data will not persist.'
        };
      case 'incognito':
        return {
          title: 'Private Browsing Detected',
          message: 'In private/incognito mode, data will not persist between sessions.'
        };
      case 'insecure':
        return {
          title: 'Non-Secure Context',
          message: 'For full functionality including persistent storage, please use HTTPS.'
        };
      case 'server':
        return {
          title: 'Server Rendering',
          message: 'Storage is not available during server rendering.'
        };
      default:
        return {
          title: 'Limited Storage Access',
          message: 'Your preferences and data will not persist between sessions.'
        };
    }
  };
  
  const { title, message } = getMessageForContext();
  
  return (
    <div className="p-2 border-l-4 border-yellow-500 bg-yellow-50 dark:bg-yellow-900/20 dark:text-yellow-100 rounded mb-4">
      <h4 className="font-medium text-yellow-800 dark:text-yellow-200">{title}</h4>
      <p className="text-sm text-yellow-700 dark:text-yellow-300">{message}</p>
    </div>
  );
};

export function StorageContextWarning() {
  const [context, setContext] = useState<StorageContext>('unknown');
  const [usingFallback, setUsingFallback] = useState(false);
  const [showWarning, setShowWarning] = useState(true);
  const [mounted, setMounted] = useState(false);
  
  // Use two-phase mounting to ensure complete client-side initialization
  useEffect(() => {
    // First phase - mark component as mounted
    setMounted(true);
    
    // Cleanup function to handle component unmounting
    return () => setMounted(false);
  }, []);
  
  // Second phase - only run detection logic after initial mount
  useEffect(() => {
    // Skip if not mounted or not in browser
    if (!mounted || typeof window === 'undefined') return;
    
    // Use setTimeout to ensure this runs after Next.js hydration is complete
    const timer = setTimeout(() => {
      try {
        // Safely detect context with error handling
        let detectedContext: StorageContext = 'unknown';
        try {
          detectedContext = detectContext();
        } catch (error) {
          console.warn('Error detecting storage context:', error);
          detectedContext = 'unknown';
        }
        setContext(detectedContext);
        
        // Safely check if using fallback storage
        let fallbackStatus = true; // Default to true for safety
        try {
          fallbackStatus = isUsingFallbackStorage();
        } catch (error) {
          console.warn('Error checking fallback storage status:', error);
        }
        setUsingFallback(fallbackStatus);
      } catch (e) {
        console.error('Error in StorageContextWarning useEffect:', e);
        // Set safe defaults
        setContext('unknown');
        setUsingFallback(true);
      }
    }, 100); // Short delay to ensure hydration is complete
    
    return () => clearTimeout(timer);
  }, [mounted]);
  
  if (!showWarning || typeof window === 'undefined') {
    return null;
  }
  
  return (
    <div className="relative">
      <WarningMessage context={context} usingFallback={usingFallback} />
      {usingFallback && (
        <button
          onClick={() => setShowWarning(false)}
          className="absolute top-2 right-2 text-yellow-700 dark:text-yellow-300 hover:text-yellow-900 dark:hover:text-yellow-100"
          aria-label="Dismiss"
        >
          <svg className="w-4 h-4" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
          </svg>
        </button>
      )}
    </div>
  );
}
</file>

<file path="src/components/todo-list.tsx">
'use client'

import { useState, useEffect } from 'react'

type Todo = {
  id: string
  title: string
  description?: string
  completed: boolean
  priority: 'low' | 'medium' | 'high'
  tags?: string[]
  dueDate?: string
  blockchainStored?: boolean
}

type TodoListProps = {
  listName: string
}

export default function TodoList({ listName }: TodoListProps) {
  const [todos, setTodos] = useState<Todo[]>([])
  const [isLoading, setIsLoading] = useState(true)

  // Mock loading todos - will be replaced with actual API call
  useEffect(() => {
    const loadTodos = async () => {
      setIsLoading(true)
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000))
      
      // Mock data - will be replaced with real data
      const mockTodos: Todo[] = [
        {
          id: '1',
          title: 'Set up blockchain wallet',
          completed: false,
          priority: 'high',
          tags: ['setup', 'blockchain'],
          blockchainStored: true
        },
        {
          id: '2',
          title: 'Design oceanic UI components',
          description: 'Create reusable Tailwind components with ocean theme',
          completed: true,
          priority: 'medium',
          tags: ['design', 'frontend']
        },
        {
          id: '3',
          title: 'Implement Sui blockchain connectivity',
          completed: false,
          priority: 'high',
          dueDate: '2023-12-01'
        },
        {
          id: '4',
          title: 'Test NFT todo transfers',
          completed: false,
          priority: 'medium',
          tags: ['testing', 'blockchain']
        }
      ]
      
      setTodos(mockTodos)
      setIsLoading(false)
    }
    
    loadTodos()
  }, [listName])

  const toggleTodoCompletion = (id: string) => {
    setTodos(todos.map(todo => 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ))
  }

  if (isLoading) {
    return (
      <div className="flex justify-center py-12">
        <div className="w-12 h-12 rounded-full border-4 border-ocean-light border-t-ocean-deep animate-spin"></div>
      </div>
    )
  }

  if (todos.length === 0) {
    return (
      <div className="text-center py-12">
        <p className="text-ocean-medium dark:text-ocean-light mb-4">No todos in this list yet.</p>
        <p className="text-sm text-ocean-medium/70 dark:text-ocean-light/70">
          Create your first todo using the form above!
        </p>
      </div>
    )
  }

  return (
    <div className="space-y-4">
      {todos.map(todo => (
        <div 
          key={todo.id} 
          className={`p-4 rounded-lg transition-all ${
            todo.completed 
              ? 'bg-green-50/50 dark:bg-green-900/30 border border-green-200 dark:border-green-800/50' 
              : 'bg-white/50 dark:bg-ocean-deep/30 border border-ocean-light/20'
          }`}
        >
          <div className="flex items-start gap-3">
            <button 
              onClick={() => toggleTodoCompletion(todo.id)}
              className={`mt-1 w-5 h-5 rounded-full flex-shrink-0 ${
                todo.completed 
                  ? 'bg-green-500 text-white flex items-center justify-center' 
                  : 'border-2 border-ocean-medium'
              }`}
            >
              {todo.completed && (
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-3 h-3">
                  <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                </svg>
              )}
            </button>
            
            <div className="flex-grow">
              <div className="flex items-start justify-between">
                <h3 className={`font-medium ${todo.completed ? 'line-through text-ocean-medium/70 dark:text-ocean-light/70' : 'text-ocean-deep dark:text-ocean-foam'}`}>
                  {todo.title}
                </h3>
                
                <div className="flex items-center gap-2">
                  {todo.blockchainStored && (
                    <span className="flex items-center text-xs bg-dream-purple/20 text-dream-purple px-2 py-0.5 rounded-full">
                      <span className="w-1.5 h-1.5 bg-dream-purple rounded-full mr-1"></span>
                      NFT
                    </span>
                  )}
                  
                  <span className={`text-xs px-2 py-0.5 rounded-full ${
                    todo.priority === 'high' 
                      ? 'bg-red-100 text-red-600 dark:bg-red-900/30 dark:text-red-300' 
                      : todo.priority === 'medium'
                      ? 'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-300'
                      : 'bg-blue-100 text-blue-600 dark:bg-blue-900/30 dark:text-blue-300'
                  }`}>
                    {todo.priority}
                  </span>
                </div>
              </div>
              
              {todo.description && (
                <p className="mt-1 text-sm text-ocean-medium dark:text-ocean-light/80">
                  {todo.description}
                </p>
              )}
              
              <div className="mt-2 flex flex-wrap items-center gap-2">
                {todo.tags && todo.tags.map(tag => (
                  <span key={tag} className="text-xs bg-ocean-light/30 dark:bg-ocean-medium/30 text-ocean-deep dark:text-ocean-foam px-2 py-0.5 rounded-full">
                    #{tag}
                  </span>
                ))}
                
                {todo.dueDate && (
                  <span className="text-xs text-ocean-medium dark:text-ocean-light flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                    Due: {todo.dueDate}
                  </span>
                )}
              </div>
            </div>
          </div>
          
          <div className="mt-3 pt-3 border-t border-ocean-light/20 dark:border-ocean-medium/20 flex justify-end gap-2">
            <button className="text-xs text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam transition-colors">
              Edit
            </button>
            {!todo.blockchainStored && (
              <button className="text-xs text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam transition-colors">
                Store on Blockchain
              </button>
            )}
            <button className="text-xs text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 transition-colors">
              Delete
            </button>
          </div>
        </div>
      ))}
    </div>
  )
}
</file>

<file path="src/components/TransactionHistory.tsx">
'use client';

import React, { useState } from 'react';
import { useWalletContext } from '@/contexts/WalletContext';
import type { TransactionRecord } from '@/contexts/WalletContext';

interface TransactionHistoryProps {
  maxItems?: number;
}

export function TransactionHistory({ maxItems = 5 }: TransactionHistoryProps) {
  const { transactions } = useWalletContext();
  const [expanded, setExpanded] = useState(false);
  
  // Get transactions to display based on expanded state and maxItems
  const displayTransactions = expanded 
    ? transactions 
    : transactions.slice(0, maxItems);
  
  if (transactions.length === 0) {
    return (
      <div className="p-4 ocean-card">
        <p className="text-ocean-medium dark:text-ocean-light text-sm">No transactions yet</p>
      </div>
    );
  }

  // Format relative time using Intl.RelativeTimeFormat
  const formatRelativeTime = (timestamp: number) => {
    if (typeof Intl === 'undefined' || !Intl.RelativeTimeFormat) {
      // Fallback for environments without Intl.RelativeTimeFormat
      return formatRelativeTimeFallback(timestamp);
    }
    
    const now = Date.now();
    const diffSeconds = Math.floor((now - timestamp) / 1000);
    
    const rtf = new Intl.RelativeTimeFormat('en', { numeric: 'auto' });
    
    if (diffSeconds < 60) {
      return rtf.format(-diffSeconds, 'second');
    }
    
    const diffMinutes = Math.floor(diffSeconds / 60);
    if (diffMinutes < 60) {
      return rtf.format(-diffMinutes, 'minute');
    }
    
    const diffHours = Math.floor(diffMinutes / 60);
    if (diffHours < 24) {
      return rtf.format(-diffHours, 'hour');
    }
    
    const diffDays = Math.floor(diffHours / 24);
    return rtf.format(-diffDays, 'day');
  };
  
  // Fallback formatter for environments without Intl.RelativeTimeFormat
  const formatRelativeTimeFallback = (timestamp: number) => {
    const now = Date.now();
    const diffSeconds = Math.floor((now - timestamp) / 1000);
    
    if (diffSeconds < 60) {
      return `${diffSeconds} seconds ago`;
    }
    
    const diffMinutes = Math.floor(diffSeconds / 60);
    if (diffMinutes < 60) {
      return `${diffMinutes} minute${diffMinutes !== 1 ? 's' : ''} ago`;
    }
    
    const diffHours = Math.floor(diffMinutes / 60);
    if (diffHours < 24) {
      return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
    }
    
    const diffDays = Math.floor(diffHours / 24);
    return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
  };

  // Get status icon based on transaction status
  const getStatusIcon = (status: 'pending' | 'success' | 'error') => {
    switch (status) {
      case 'pending':
        return (
          <div className="w-4 h-4 bg-yellow-400 rounded-full animate-pulse" 
               title="Pending transaction"></div>
        );
      case 'success':
        return (
          <svg className="w-4 h-4 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
          </svg>
        );
      case 'error':
        return (
          <svg className="w-4 h-4 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        );
    }
  };

  // Render a single transaction row
  const renderTransaction = (tx: TransactionRecord) => {
    return (
      <div key={tx.id} className="border-b border-ocean-light/20 last:border-0 py-3 flex items-center gap-3">
        <div className="flex-shrink-0">
          {getStatusIcon(tx.status)}
        </div>
        <div className="flex-1 min-w-0">
          <div className="flex justify-between">
            <p className="text-sm font-medium truncate">
              {tx.type}
              {tx.hash && (
                <span className="ml-2 text-xs text-ocean-medium dark:text-ocean-light truncate">
                  {tx.hash.slice(0, 8)}...{tx.hash.slice(-6)}
                </span>
              )}
            </p>
            <p className="text-xs text-ocean-medium dark:text-ocean-light ml-2">
              {formatRelativeTime(tx.timestamp)}
            </p>
          </div>
          {tx.status === 'error' && tx.message && (
            <p className="text-xs text-red-500 mt-1 truncate">{tx.message}</p>
          )}
        </div>
      </div>
    );
  };

  return (
    <div className="rounded-lg overflow-hidden bg-white dark:bg-slate-800 shadow-sm border border-ocean-light/20">
      <div className="bg-ocean-light/10 dark:bg-ocean-deep/20 px-4 py-2 flex justify-between items-center">
        <h3 className="font-medium text-sm text-ocean-deep dark:text-ocean-foam">
          Transaction History
        </h3>
        {transactions.length > maxItems && (
          <button 
            onClick={() => setExpanded(!expanded)}
            className="text-xs text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam"
          >
            {expanded ? 'Show less' : `Show all (${transactions.length})`}
          </button>
        )}
      </div>
      <div className="px-4 py-2 divide-y divide-ocean-light/10">
        {displayTransactions.map(renderTransaction)}
      </div>
    </div>
  );
}
</file>

<file path="src/components/WalletConnectButton.tsx">
'use client';

import React, { useState } from 'react';
import { useWalletContext } from '@/contexts/SimpleWalletContext';
import { 
  copyToClipboard, 
  getClipboardCapabilities,
  ClipboardError
} from '@/lib/clipboard';
import { WalletErrorModal } from './WalletErrorModal';
import { ClipboardErrorModal } from './ClipboardErrorModal';
import { WalletError } from '@/lib/wallet-errors';
import { ErrorBoundary } from './ErrorBoundary';

export function WalletConnectButton() {
  const {
    connected,
    connecting,
    disconnect,
    connect,
    address,
    name: walletName,
    chainId,
    error,
    setError,
    switchNetwork
  } = useWalletContext();

  const [copyStatus, setCopyStatus] = useState<'idle' | 'success' | 'error'>('idle');
  const [copyError, setCopyError] = useState<string | null>(null);
  const [clipboardError, setClipboardError] = useState<ClipboardError | null>(null);
  const [showNetworkOptions, setShowNetworkOptions] = useState(false);
  const [isNetworkSwitching, setIsNetworkSwitching] = useState(false);

  // Helper function to truncate address
  const truncateAddress = (address: string) => {
    if (!address) return '';
    return `${address.slice(0, 6)}...${address.slice(-4)}`;
  };

  // Handle copying address to clipboard
  const handleCopyAddress = async () => {
    // Prevent function execution if no address exists
    if (!address) {
      console.warn('Attempted to copy address but no address is available');
      setCopyStatus('error');
      setCopyError('No wallet address available');
      return;
    }
    
    setCopyStatus('idle');
    setCopyError(null);
    setClipboardError(null);
    
    try {
      const result = await copyToClipboard(address || '');
      
      if (result.success) {
        setCopyStatus('success');
        // Reset success status after 2 seconds
        setTimeout(() => setCopyStatus('idle'), 2000);
      } else {
        setCopyStatus('error');
        setCopyError(result.error?.message || 'Unknown error');
        
        // If it's a ClipboardError, show the modal
        if (result.error instanceof ClipboardError) {
          setClipboardError(result.error);
        }
        
        console.error('Failed to copy address:', result.error);
      }
    } catch (error) {
      setCopyStatus('error');
      const message = error instanceof Error ? error.message : 'Failed to copy';
      setCopyError(message);
      
      // If it's a ClipboardError, show the modal
      if (error instanceof ClipboardError) {
        setClipboardError(error);
      }
      
      console.error('Copy operation failed:', error);
    }
  };

  // Add clipboard manual fallback option
  const handleManualCopy = () => {
    try {
      // Prevent function execution if no address exists
      if (!address) {
        console.warn('Attempted manual copy but no address is available');
        return;
      }

      // Create a temporary input element to display the address for manual copying
      const tempInput = document.createElement('textarea');
      tempInput.value = address || '';
      tempInput.setAttribute('readonly', '');
      tempInput.style.position = 'fixed';
      tempInput.style.top = '0';
      tempInput.style.opacity = '1'; // Make visible but out of normal flow
      tempInput.style.zIndex = '1000'; 
      document.body.appendChild(tempInput);
      
      try {
        tempInput.focus();
        tempInput.select();
        
        // Show instructions
        alert('Please use keyboard shortcut to copy:\n' + 
              '• Windows/Linux: Press Ctrl+C\n' + 
              '• Mac: Press Command+C\n\n' +
              'Then click OK to continue.');
      } finally {
        // Always clean up, even if there's an error
        try {
          document.body.removeChild(tempInput);
        } catch (err) {
          console.error('Error removing temporary input element:', err);
        }
      }
    } catch (error) {
      console.error('Error in manual copy function:', error);
    }
  };

  // Handle network switching
  const handleNetworkSwitch = async (network: 'mainnet' | 'testnet' | 'devnet') => {
    if (isNetworkSwitching) return; // Prevent multiple clicks
    
    setIsNetworkSwitching(true);
    
    try {
      await switchNetwork(network);
      setShowNetworkOptions(false);
    } catch (error) {
      console.error(`Failed to switch to ${network}:`, error);
      if (setError && error instanceof Error) {
        setError(error);
      }
    } finally {
      setIsNetworkSwitching(false);
    }
  };

  // Convert network string to display name
  const getNetworkDisplayName = (networkId: number | null) => {
    if (networkId === null) return 'Unknown';
    
    // Convert network ID to readable name as needed
    const networkMap: Record<string, string> = {
      'mainnet': 'Mainnet',
      'testnet': 'Testnet',
      'devnet': 'Devnet'
    };
    
    // Return formatted name or the original if not in our map
    return networkMap[String(networkId)] || String(networkId);
  };

  // Render the connected wallet UI
  const renderConnectedUI = () => {
    if (!connected || !address) return null;
    
    // Get clipboard capabilities to determine what UI to show
    const clipboardCapabilities = getClipboardCapabilities();
    const showClipboardButton = clipboardCapabilities.hasModernApi || clipboardCapabilities.hasLegacySupport;

    return (
      <div className="flex items-center gap-4">
        <div className="px-4 py-2 bg-ocean-deep/20 dark:bg-ocean-foam/20 rounded-lg flex items-center gap-2 relative">
          <div className="flex flex-col">
            <p className="text-sm text-ocean-deep dark:text-ocean-foam">
              {walletName || 'Wallet'}: {truncateAddress(address)}
            </p>
            <p className="text-xs text-ocean-medium dark:text-ocean-light">
              {getNetworkDisplayName(chainId)}
              {!isNetworkSwitching ? (
                <button 
                  onClick={() => setShowNetworkOptions(!showNetworkOptions)}
                  className="ml-2 text-xs text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam"
                  disabled={isNetworkSwitching}
                >
                  (change)
                </button>
              ) : (
                <span className="ml-2 text-xs text-yellow-500 animate-pulse">
                  (switching...)
                </span>
              )}
            </p>
            
            {/* Network selection dropdown */}
            {showNetworkOptions && !isNetworkSwitching && (
              <div className="absolute top-full left-0 mt-2 p-2 bg-white dark:bg-slate-800 rounded-lg shadow-lg z-10 w-full min-w-[150px]">
                <div className="flex flex-col gap-2">
                  <button 
                    onClick={() => handleNetworkSwitch('mainnet')}
                    disabled={isNetworkSwitching || chainId === 'mainnet'}
                    className={`text-sm px-3 py-1 rounded-md ${
                      chainId === 'mainnet' 
                        ? 'bg-ocean-deep text-white' 
                        : isNetworkSwitching
                          ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                          : 'hover:bg-ocean-light/20'
                    }`}
                  >
                    Mainnet
                  </button>
                  <button 
                    onClick={() => handleNetworkSwitch('testnet')}
                    disabled={isNetworkSwitching || chainId === 'testnet'}
                    className={`text-sm px-3 py-1 rounded-md ${
                      chainId === 'testnet' 
                        ? 'bg-ocean-deep text-white' 
                        : isNetworkSwitching
                          ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                          : 'hover:bg-ocean-light/20'
                    }`}
                  >
                    Testnet
                  </button>
                  <button 
                    onClick={() => handleNetworkSwitch('devnet')}
                    disabled={isNetworkSwitching || chainId === 'devnet'}
                    className={`text-sm px-3 py-1 rounded-md ${
                      chainId === 'devnet' 
                        ? 'bg-ocean-deep text-white' 
                        : isNetworkSwitching
                          ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                          : 'hover:bg-ocean-light/20'
                    }`}
                  >
                    Devnet
                  </button>
                </div>
              </div>
            )}
          </div>
          
          {showClipboardButton && (
            <button
              onClick={handleCopyAddress}
              className={`text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam transition-colors ${
                copyStatus === 'error' ? 'text-red-500 dark:text-red-400' : 
                copyStatus === 'success' ? 'text-green-500 dark:text-green-400' : ''
              }`}
              title={
                copyStatus === 'error' ? 'Copy failed' : 
                copyStatus === 'success' ? 'Copied!' : 
                'Copy address'
              }
            >
              {copyStatus === 'success' ? (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                </svg>
              ) : copyStatus === 'error' ? (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              ) : (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                </svg>
              )}
            </button>
          )}
          
          {/* Error tooltip */}
          {copyStatus === 'error' && copyError && (
            <div className="absolute top-full left-0 mt-2 p-2 bg-red-100 text-red-800 text-xs rounded shadow-md z-10">
              {copyError}
            </div>
          )}
          
          {/* Success tooltip */}
          {copyStatus === 'success' && (
            <div className="absolute top-full left-0 mt-2 p-2 bg-green-100 text-green-800 text-xs rounded shadow-md z-10">
              Address copied to clipboard!
            </div>
          )}
        </div>
        <button
          onClick={() => {
            try {
              disconnect().catch(err => {
                console.error('Error disconnecting wallet:', err);
                if (setError && err instanceof Error) {
                  setError(err);
                }
              });
            } catch (error) {
              console.error('Error in disconnect handler:', error);
              if (setError && error instanceof Error) {
                setError(error);
              }
            }
          }}
          disabled={isNetworkSwitching}
          className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors disabled:bg-red-300 disabled:cursor-not-allowed"
        >
          Disconnect
        </button>
      </div>
    );
  };

  // Render the connecting UI
  const renderConnectingUI = () => {
    if (!connecting) return null;
    
    return (
      <div className="px-4 py-2 bg-ocean-deep/20 dark:bg-ocean-foam/20 rounded-lg">
        <p className="text-sm text-ocean-deep dark:text-ocean-foam flex items-center">
          <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-ocean-deep dark:text-ocean-foam" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          Connecting...
        </p>
      </div>
    );
  };

  // Render the connect button UI
  const renderConnectUI = () => {
    if (connected || connecting) return null;
    
    return (
      <button
        onClick={() => {
          try {
            connect().catch(err => {
              console.error('Error connecting wallet:', err);
              // Error is already handled by the context
            });
          } catch (error) {
            console.error('Error in connect handler:', error);
            if (setError && error instanceof Error) {
              setError(error);
            }
          }
        }}
        className="px-4 py-2 bg-ocean-deep text-white rounded-lg hover:bg-ocean-deep/80 transition-colors"
      >
        Connect Wallet
      </button>
    );
  };

  // Wrap the entire component in an ErrorBoundary
  return (
    <ErrorBoundary>
      <>
        {renderConnectedUI() || renderConnectingUI() || renderConnectUI()}
        
        <WalletErrorModal 
          error={error instanceof WalletError ? error : null} 
          onDismiss={() => setError(null)} 
        />
        <ClipboardErrorModal
          error={clipboardError}
          onDismiss={() => setClipboardError(null)}
          onTryAlternative={handleManualCopy}
        />
      </>
    </ErrorBoundary>
  );
}
</file>

<file path="src/components/WalletErrorModal.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { WalletError, getWalletErrorMessage } from '@/lib/wallet-errors';

interface WalletErrorModalProps {
  error: WalletError | null;
  onDismiss: () => void;
}

export function WalletErrorModal({ error, onDismiss }: WalletErrorModalProps) {
  const [isVisible, setIsVisible] = useState(false);
  
  useEffect(() => {
    if (error) {
      setIsVisible(true);
    } else {
      setIsVisible(false);
    }
  }, [error]);
  
  if (!error || !isVisible) {
    return null;
  }
  
  const { message, suggestion } = getWalletErrorMessage(error);
  
  const handleDismiss = () => {
    setIsVisible(false);
    onDismiss();
  };
  
  // Determine icon and color based on error type
  const getIconAndColor = () => {
    const errorName = error.name;
    
    if (errorName === 'WalletNotInstalledError') {
      return {
        icon: (
          <svg className="w-6 h-6 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
          </svg>
        ),
        bgColor: 'bg-yellow-50 dark:bg-yellow-900/20',
        borderColor: 'border-yellow-400',
        textColor: 'text-yellow-700 dark:text-yellow-200'
      };
    }
    
    if (errorName === 'WalletConnectionRejectedError') {
      return {
        icon: (
          <svg className="w-6 h-6 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        ),
        bgColor: 'bg-red-50 dark:bg-red-900/20',
        borderColor: 'border-red-400',
        textColor: 'text-red-700 dark:text-red-200'
      };
    }
    
    // Default case
    return {
      icon: (
        <svg className="w-6 h-6 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
      ),
      bgColor: 'bg-blue-50 dark:bg-blue-900/20',
      borderColor: 'border-blue-400',
      textColor: 'text-blue-700 dark:text-blue-200'
    };
  };
  
  const { icon, bgColor, borderColor, textColor } = getIconAndColor();
  
  return (
    <div className="fixed inset-0 flex items-center justify-center p-4 bg-black/50 z-50">
      <div className={`max-w-md w-full rounded-lg ${bgColor} border ${borderColor} shadow-lg overflow-hidden transform transition-all`}>
        <div className="p-4">
          <div className="flex items-start">
            <div className="flex-shrink-0">{icon}</div>
            <div className="ml-3 flex-1">
              <h3 className={`text-lg font-medium ${textColor}`}>
                {message}
              </h3>
              <div className="mt-2">
                <p className={`text-sm ${textColor}`}>
                  {suggestion}
                </p>
              </div>
              <div className="mt-4 flex justify-end">
                <button
                  type="button"
                  onClick={handleDismiss}
                  className={`inline-flex justify-center px-4 py-2 text-sm font-medium text-white bg-ocean-medium rounded-md hover:bg-ocean-deep focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-ocean-light`}
                >
                  Got it
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/WalletStatus.tsx">
'use client';

import React from 'react';
import { useWalletContext } from '@/lib/walletContext';

export function WalletStatus() {
  const { connected, publicKey, walletType } = useWalletContext();

  if (!connected || !publicKey) {
    return null;
  }

  return (
    <div className="inline-flex items-center gap-2 px-3 py-1 bg-ocean-deep/10 dark:bg-ocean-foam/10 rounded-full">
      <div 
        className={`w-2 h-2 rounded-full ${
          walletType === 'sui' ? 'bg-blue-500' : 'bg-purple-500'
        }`}
      />
      <span className="text-sm text-ocean-deep dark:text-ocean-foam">
        {walletType === 'sui' ? 'Sui' : 'Phantom'}
      </span>
    </div>
  );
}
</file>

<file path="src/contexts/SimpleWalletContext.tsx">
'use client';

import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';

// Simple wallet interface that avoids complex dependencies
interface SimpleWalletContextValue {
  connected: boolean;
  connecting: boolean;
  address: string | null;
  name: string | null;
  chainId: string | null;
  error: Error | null;
  setError: (error: Error | null) => void;
  connect: () => Promise<void>;
  disconnect: () => Promise<void>;
  switchNetwork: (network: string) => Promise<void>;
}

// Create context with default values
const SimpleWalletContext = createContext<SimpleWalletContextValue | null>(null);

// Mock wallet data for development
const MOCK_ADDRESS = '0x7a40eb2bb8dcf8abe508e3f0dc49bade2935bd8c';
const MOCK_WALLET_NAME = 'Development Wallet';

// Create a provider component
export function SimpleWalletProvider({ children }: { children: ReactNode }) {
  const [connected, setConnected] = useState(false);
  const [connecting, setConnecting] = useState(false);
  const [address, setAddress] = useState<string | null>(null);
  const [name, setName] = useState<string | null>(null);
  const [chainId, setChainId] = useState<string | null>('testnet');
  const [error, setError] = useState<Error | null>(null);

  // Safe local storage access
  const getStorage = (key: string): string | null => {
    try {
      if (typeof window === 'undefined') return null;
      return localStorage.getItem(key);
    } catch (e) {
      console.warn('Storage access failed:', e);
      return null;
    }
  };

  const setStorage = (key: string, value: string): void => {
    try {
      if (typeof window === 'undefined') return;
      localStorage.setItem(key, value);
    } catch (e) {
      console.warn('Storage write failed:', e);
    }
  };

  // Auto-connect based on stored data
  useEffect(() => {
    const autoConnect = async () => {
      try {
        const savedState = getStorage('wallet_connected');
        if (savedState === 'true' && !connected && !connecting) {
          try {
            // Simulate connection process
            const savedAddress = getStorage('wallet_address');
            const savedName = getStorage('wallet_name');
            const savedChain = getStorage('wallet_chain');
            
            if (savedAddress) {
              setAddress(savedAddress);
              setName(savedName || MOCK_WALLET_NAME);
              setChainId(savedChain || 'testnet');
              setConnected(true);
            }
          } catch (e) {
            console.warn('Auto-connect failed:', e);
            // Clean up storage
            try {
              localStorage.removeItem('wallet_connected');
              localStorage.removeItem('wallet_address');
              localStorage.removeItem('wallet_name');
              localStorage.removeItem('wallet_chain');
            } catch (error) {
              // Ignore storage errors
            }
          }
        }
      } catch (error) {
        console.warn('Error during auto-connect check:', error);
      }
    };
    
    if (typeof window !== 'undefined') {
      autoConnect();
    }
  }, [connected, connecting]);

  // Connect function
  const connect = async (): Promise<void> => {
    if (connected) return;
    
    setConnecting(true);
    setError(null);
    
    try {
      // Simulate connecting to a wallet with a short delay
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Set connected state
      setAddress(MOCK_ADDRESS);
      setName(MOCK_WALLET_NAME);
      setChainId('testnet');
      setConnected(true);
      
      // Store connection state
      setStorage('wallet_connected', 'true');
      setStorage('wallet_address', MOCK_ADDRESS);
      setStorage('wallet_name', MOCK_WALLET_NAME);
      setStorage('wallet_chain', 'testnet');
      
      return Promise.resolve();
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Connection failed');
      setError(error);
      console.error('Wallet connection error:', error);
      return Promise.reject(error);
    } finally {
      setConnecting(false);
    }
  };

  // Disconnect function
  const disconnect = async (): Promise<void> => {
    if (!connected) return;
    
    setError(null);
    
    try {
      // Simulate disconnecting from wallet with a short delay
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // Clear state
      setConnected(false);
      setAddress(null);
      setName(null);
      
      // Clear stored data
      try {
        localStorage.removeItem('wallet_connected');
        localStorage.removeItem('wallet_address');
        localStorage.removeItem('wallet_name');
        localStorage.removeItem('wallet_chain');
      } catch (e) {
        // Ignore storage errors
      }
      
      return Promise.resolve();
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Disconnect failed');
      setError(error);
      console.error('Wallet disconnect error:', error);
      return Promise.reject(error);
    }
  };

  // Switch network function
  const switchNetwork = async (network: string): Promise<void> => {
    if (!connected) {
      const error = new Error('Not connected to any wallet');
      setError(error);
      return Promise.reject(error);
    }
    
    try {
      // Simulate network switching with a delay
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Update chain ID
      setChainId(network);
      setStorage('wallet_chain', network);
      
      return Promise.resolve();
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Network switch failed');
      setError(error);
      console.error('Network switch error:', error);
      return Promise.reject(error);
    }
  };

  // Create context value
  const contextValue: SimpleWalletContextValue = {
    connected,
    connecting,
    address,
    name,
    chainId,
    error,
    setError,
    connect,
    disconnect,
    switchNetwork,
  };

  return (
    <SimpleWalletContext.Provider value={contextValue}>
      {children}
    </SimpleWalletContext.Provider>
  );
}

// Custom hook to use wallet context
export function useWalletContext() {
  const context = useContext(SimpleWalletContext);
  if (!context) {
    throw new Error('useWalletContext must be used within SimpleWalletProvider');
  }
  return context;
}
</file>

<file path="src/contexts/WalletContext.tsx">
'use client';

import React, { createContext, useContext, useState, useEffect, ReactNode, useMemo, useCallback } from 'react';
import { nanoid } from 'nanoid';
import { WalletProvider, useWallet, AllDefaultWallets } from '@suiet/wallet-kit';
import '@suiet/wallet-kit/style.css';
import { 
  WalletError,
  WalletNotInstalledError,
  WalletConnectionRejectedError,
  categorizeWalletError 
} from '@/lib/wallet-errors';

// Transaction status type
type TransactionStatus = 'pending' | 'success' | 'error';

// Transaction record interface
interface TransactionRecord {
  id: string;
  hash?: string;
  status: TransactionStatus;
  timestamp: number;
  type: string;
  message?: string;
}

// Enhanced context with additional features
interface WalletContextValue {
  // Connection state
  connected: boolean;
  connecting: boolean;
  
  // Wallet info
  address: string | null;
  chainId: number | null; // Fixed: Changed to number | null to match networkId type
  name: string | null;
  
  // Actions
  connect: () => Promise<void>;
  disconnect: () => Promise<void>;
  switchNetwork: (network: 'mainnet' | 'testnet' | 'devnet') => Promise<void>;
  
  // Transaction tracking
  transactions: TransactionRecord[];
  trackTransaction: <T extends { digest?: string }>(txPromise: Promise<T>, type: string) => Promise<T>; // Constrained generic type
  
  // Error handling
  error: Error | null;
  setError: (error: Error | null) => void;
  
  // Activity timeout (security)
  lastActivity: number;
  resetActivityTimer: () => void;
}

// Create context with default values
const WalletContext = createContext<WalletContextValue | null>(null);

// Session timeout in milliseconds (30 minutes)
const SESSION_TIMEOUT = 30 * 60 * 1000;

// Custom hook for inactivity timer
function useInactivityTimer(isConnected: boolean, onTimeout: () => void) {
  const [lastActivity, setLastActivity] = useState<number>(Date.now());
  
  const resetActivityTimer = useCallback(() => {
    setLastActivity(Date.now());
  }, []);
  
  useEffect(() => {
    if (!isConnected) return;
    
    // Set up event listeners to track activity
    const activityEvents = ['mousedown', 'keydown', 'touchstart'];
    const handleActivity = () => resetActivityTimer();
    
    activityEvents.forEach(event => {
      window.addEventListener(event, handleActivity);
    });
    
    // Auto-disconnect after inactivity
    const interval = setInterval(() => {
      const now = Date.now();
      if (now - lastActivity > SESSION_TIMEOUT) {
        console.log('Session timeout due to inactivity');
        onTimeout();
      }
    }, 60000); // Check every minute
    
    return () => {
      activityEvents.forEach(event => {
        window.removeEventListener(event, handleActivity);
      });
      clearInterval(interval);
    };
  }, [isConnected, lastActivity, onTimeout, resetActivityTimer]);
  
  return { lastActivity, resetActivityTimer };
}

// Main wallet context provider component
function WalletContextProvider({ children }: { children: ReactNode }) {
  // Track wallet state
  const [error, setError] = useState<Error | null>(null);
  const [transactions, setTransactions] = useState<TransactionRecord[]>([]);
  
  // Get wallet from Suiet kit
  const { 
    connected,
    connecting,
    account,
    wallet,
    networkId,
    select,
    connect: suietConnect,
    disconnect: suietDisconnect,
    executeMoveCall,
    executeSerializedMoveCall,
    signMessage,
    signAndExecuteTransaction,
    signTransaction,
    on,
    verifySignedMessage
  } = useWallet();

  // Handle timeout with useCallback to maintain reference stability
  const handleTimeout = useCallback(() => {
    suietDisconnect().catch(error => console.error('Error during auto-disconnect:', error));
  }, [suietDisconnect]);
  
  // Use the inactivity timer hook
  const { lastActivity, resetActivityTimer } = useInactivityTimer(connected, handleTimeout);

  // Persist last connected wallet
  useEffect(() => {
    if (connected && wallet && typeof window !== 'undefined') {
      // Save wallet name for auto-reconnect
      try {
        localStorage.setItem('lastConnectedWallet', wallet.name);
      } catch (error) {
        console.warn('Failed to save wallet info to localStorage:', error);
      }
    }
  }, [connected, wallet]);

  // Try to reconnect with the last used wallet on load
  useEffect(() => {
    const attemptReconnect = async () => {
      // Guard for SSR
      if (typeof window === 'undefined') return;
      
      try {
        const lastWallet = localStorage.getItem('lastConnectedWallet');
        if (lastWallet && !connected && !connecting) {
          // Attempt to select the wallet
          select(lastWallet);
          
          // Give the wallet selection a moment to process
          setTimeout(() => {
            suietConnect().catch(err => {
              console.warn('Auto-reconnect failed:', err);
              // Clear saved wallet if reconnect fails
              try {
                if (typeof window !== 'undefined') {
                  localStorage.removeItem('lastConnectedWallet');
                }
              } catch (e) {
                console.warn('Failed to clear wallet from localStorage:', e);
              }
            });
          }, 500);
        }
      } catch (error) {
        console.warn('Error during wallet auto-reconnect:', error);
      }
    };
    
    attemptReconnect();
  }, [connected, connecting, select, suietConnect]);

  // Enhanced connect function with error handling
  const connect = useCallback(async () => {
    resetActivityTimer();
    setError(null);
    
    try {
      await suietConnect();
    } catch (err) {
      const walletError = categorizeWalletError(err);
      setError(walletError);
      console.error('Wallet connection error:', walletError);
      throw walletError;
    }
  }, [resetActivityTimer, suietConnect]);

  // Enhanced disconnect function with cleanup
  const disconnect = useCallback(async () => {
    resetActivityTimer();
    setError(null);
    
    try {
      await suietDisconnect();
      
      // Clear persisted wallet
      try {
        if (typeof window !== 'undefined') {
          localStorage.removeItem('lastConnectedWallet');
        }
      } catch (e) {
        console.warn('Failed to clear wallet from localStorage:', e);
      }
    } catch (err) {
      const walletError = categorizeWalletError(err);
      setError(walletError);
      console.error('Wallet disconnect error:', walletError);
      throw walletError;
    }
  }, [resetActivityTimer, suietDisconnect]);

  // Network switching functionality
  const switchNetwork = useCallback(async (network: 'mainnet' | 'testnet' | 'devnet') => {
    resetActivityTimer();
    
    if (!connected || !wallet) {
      const err = new WalletError('Not connected to any wallet');
      setError(err);
      throw err;
    }
    
    try {
      await wallet.switchChain({ chainId: network });
    } catch (err) {
      const walletError = categorizeWalletError(err);
      setError(walletError);
      console.error(`Network switch error:`, walletError);
      throw walletError;
    }
  }, [connected, resetActivityTimer, wallet]);

  // Transaction tracking function
  const trackTransaction = useCallback(async <T extends { digest?: string }>(txPromise: Promise<T>, type: string): Promise<T> => {
    resetActivityTimer();
    
    // Create unique ID for tracking this transaction
    const txId = nanoid();
    
    // Add pending transaction to list
    const pendingTx: TransactionRecord = {
      id: txId,
      status: 'pending',
      timestamp: Date.now(),
      type
    };
    
    setTransactions(prev => [pendingTx, ...prev]);
    
    try {
      // Wait for transaction to complete
      const result = await txPromise;
      
      // Get hash if available (results vary by transaction type)
      const hash = result.digest ? String(result.digest) : undefined;
      
      // Update transaction status to success
      setTransactions(prev => 
        prev.map(tx => 
          tx.id === txId 
            ? { ...tx, status: 'success', hash } 
            : tx
        )
      );
      
      return result;
    } catch (error) {
      // Update transaction status to error
      const message = error instanceof Error ? error.message : String(error);
      
      setTransactions(prev => 
        prev.map(tx => 
          tx.id === txId 
            ? { ...tx, status: 'error', message } 
            : tx
        )
      );
      
      throw error;
    }
  }, [resetActivityTimer]);

  // Create context value with all wallet functions
  const contextValue = useMemo<WalletContextValue>(() => ({
    // Connection state
    connected,
    connecting,
    
    // Wallet info
    address: account?.address || null,
    chainId: networkId ?? null, // Fixed: Changed to match networkId type
    name: wallet?.name || null,
    
    // Actions
    connect,
    disconnect,
    switchNetwork,
    
    // Transaction tracking
    transactions,
    trackTransaction,
    
    // Error handling
    error,
    setError,
    
    // Activity timeout (security)
    lastActivity,
    resetActivityTimer,
  }), [
    connected,
    connecting,
    account,
    networkId,
    wallet,
    transactions,
    error,
    lastActivity,
    connect,
    disconnect,
    switchNetwork,
    trackTransaction,
    resetActivityTimer
  ]);

  return (
    <WalletContext.Provider value={contextValue}>
      {children}
    </WalletContext.Provider>
  );
}

// Wrapper component that includes the Suiet provider
export function AppWalletProvider({ children }: { children: ReactNode }) {
  return (
    <WalletProvider
      defaultWallets={AllDefaultWallets}
      chains={['mainnet', 'testnet', 'devnet']}
      autoConnect={false}
    >
      <WalletContextProvider>
        {children}
      </WalletContextProvider>
    </WalletProvider>
  );
}

// Hook to use wallet context
export function useWalletContext() {
  const context = useContext(WalletContext);
  if (!context) {
    throw new Error('useWalletContext must be used within AppWalletProvider');
  }
  return context;
}

// Export types
export type { TransactionRecord, TransactionStatus, WalletContextValue };
</file>

<file path="src/lib/clipboard.ts">
/**
 * Enhanced clipboard utility with comprehensive error handling and fallbacks
 * for various browser contexts and restrictions
 */

export interface ClipboardResult {
  success: boolean;
  error?: Error;
  method?: 'clipboard-api' | 'document-execcommand' | 'clipboard-polyfill' | 'none';
}

// Custom error types for better error handling
export class ClipboardError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ClipboardError';
  }
}

export class ClipboardApiNotSupportedError extends ClipboardError {
  constructor() {
    super('Clipboard API not supported in this browser');
    this.name = 'ClipboardApiNotSupportedError';
  }
}

export class ClipboardPermissionDeniedError extends ClipboardError {
  constructor() {
    super('Permission to access clipboard was denied');
    this.name = 'ClipboardPermissionDeniedError';
  }
}

export class InsecureContextError extends ClipboardError {
  constructor() {
    super('Clipboard access requires a secure context (HTTPS or localhost)');
    this.name = 'InsecureContextError';
  }
}

export class ClipboardPolyfillError extends ClipboardError {
  constructor(message: string = 'Clipboard polyfill failed') {
    super(message);
    this.name = 'ClipboardPolyfillError';
  }
}

/**
 * Check browser capabilities for clipboard operations
 */
export function getClipboardCapabilities(): {
  hasModernApi: boolean;
  hasLegacySupport: boolean;
  isSecureContext: boolean;
  canPolyfill: boolean;
} {
  if (typeof window === 'undefined') {
    return {
      hasModernApi: false,
      hasLegacySupport: false,
      isSecureContext: false,
      canPolyfill: false
    };
  }
  
  // Check for secure context (HTTPS or localhost)
  const isSecureContext = window.isSecureContext === true;
  
  // Check for modern clipboard API
  const hasModernApi = 
    typeof navigator !== 'undefined' && 
    navigator.clipboard !== undefined &&
    typeof navigator.clipboard.writeText === 'function';
  
  // Check for legacy support via execCommand
  const hasLegacySupport = 
    typeof document !== 'undefined' && 
    document.queryCommandSupported && 
    document.queryCommandSupported('copy');
  
  // Check if we can use any method (including polyfill)
  const canPolyfill = hasLegacySupport || hasModernApi;
  
  return {
    hasModernApi,
    hasLegacySupport,
    isSecureContext,
    canPolyfill
  };
}

/**
 * Legacy method using execCommand (works in more browsers but requires user interaction)
 */
function copyWithExecCommand(text: string): boolean {
  try {
    // Create temporary element
    const textArea = document.createElement('textarea');
    textArea.value = text;
    
    // Hide the element but make it available for selection
    textArea.style.position = 'fixed';
    textArea.style.opacity = '0';
    textArea.style.left = '-999999px';
    textArea.style.top = '0';
    textArea.setAttribute('readonly', '');
    textArea.setAttribute('aria-hidden', 'true');
    
    // Add to DOM
    document.body.appendChild(textArea);
    
    // Select text
    textArea.focus();
    textArea.select();
    
    // For mobile devices
    textArea.setSelectionRange(0, text.length);
    
    // Execute copy command
    const successful = document.execCommand('copy');
    
    // Clean up
    document.body.removeChild(textArea);
    
    return successful;
  } catch (e) {
    console.warn('Legacy clipboard copy failed:', e);
    return false;
  }
}

/**
 * Try to enhance the clipboard error with more specific information
 */
function enhanceClipboardError(error: unknown): Error {
  if (error instanceof DOMException) {
    // Handle specific DOMException types
    if (error.name === 'NotAllowedError') {
      return new ClipboardPermissionDeniedError();
    }
    if (error.name === 'SecurityError') {
      return new InsecureContextError();
    }
  }
  
  // Return original error if it's already an Error instance
  if (error instanceof Error) {
    return error;
  }
  
  // Create generic error for other cases
  return new ClipboardError(String(error) || 'Unknown clipboard error');
}

/**
 * Main copy to clipboard function with multiple fallback strategies
 */
export async function copyToClipboard(text: string): Promise<ClipboardResult> {
  // Check for server-side rendering
  if (typeof window === 'undefined') {
    return {
      success: false,
      error: new ClipboardError('Clipboard operations require a browser environment'),
      method: 'none'
    };
  }
  
  const capabilities = getClipboardCapabilities();
  
  // Try modern clipboard API first (if available)
  if (capabilities.hasModernApi && capabilities.isSecureContext) {
    try {
      await navigator.clipboard.writeText(text);
      return { 
        success: true,
        method: 'clipboard-api'
      };
    } catch (error) {
      console.warn('Modern clipboard API failed, falling back:', error);
      // Continue to fallbacks instead of returning immediately
    }
  }
  
  // Try legacy method
  if (capabilities.hasLegacySupport) {
    const legacyResult = copyWithExecCommand(text);
    if (legacyResult) {
      return { 
        success: true,
        method: 'document-execcommand'
      };
    }
  }
  
  // If we got here, both modern and legacy methods failed
  // Create appropriate error based on context
  let error: Error;
  
  if (!capabilities.isSecureContext) {
    error = new InsecureContextError();
  } else if (!capabilities.hasModernApi && !capabilities.hasLegacySupport) {
    error = new ClipboardApiNotSupportedError();
  } else {
    error = new ClipboardError('All clipboard methods failed');
  }
  
  return {
    success: false,
    error,
    method: 'none'
  };
}

/**
 * Check if clipboard operations are supported
 */
export function isCopySupported(): boolean {
  const capabilities = getClipboardCapabilities();
  return capabilities.hasModernApi || capabilities.hasLegacySupport;
}

/**
 * Get user-friendly message based on clipboard capabilities
 */
export function getClipboardSupportMessage(): string {
  const capabilities = getClipboardCapabilities();
  
  if (!capabilities.hasModernApi && !capabilities.hasLegacySupport) {
    return 'Copy to clipboard is not supported in this browser';
  }
  
  if (!capabilities.isSecureContext) {
    return 'Copy requires a secure context (HTTPS). Some features may be limited.';
  }
  
  if (capabilities.hasModernApi) {
    return 'Clipboard API is fully supported';
  }
  
  if (capabilities.hasLegacySupport) {
    return 'Using legacy clipboard support';
  }
  
  return 'Limited clipboard support';
}
</file>

<file path="src/lib/safe-storage.ts">
'use client';

/**
 * Safe Storage - Provides an enhanced localStorage wrapper with:
 * - Error handling for browser restrictions and SSR
 * - In-memory fallback when localStorage isn't available
 * - TypeScript type safety
 */

// In-memory fallback storage
const memoryStore: Record<string, string> = {};

// Check if we're in a browser environment
export const isBrowser = () => typeof window !== 'undefined';

// Check if localStorage is available
export function isStorageAvailable(): boolean {
  if (!isBrowser()) return false;
  
  try {
    // First check if localStorage is defined
    if (window.localStorage === undefined) {
      return false;
    }
    
    // Then try storage access
    const testKey = '__storage_test__';
    window.localStorage.setItem(testKey, testKey);
    window.localStorage.removeItem(testKey);
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Get item safely from storage with fallback to memory store
 */
export function getItem<T>(key: string, defaultValue?: T): T | null {
  try {
    // Return from memory store in SSR or if storage is unavailable
    if (!isStorageAvailable()) {
      const memoryValue = memoryStore[key];
      return memoryValue ? JSON.parse(memoryValue) : defaultValue ?? null;
    }
    
    // Get from localStorage with proper error handling
    const value = window.localStorage.getItem(key);
    
    // Return parsed value if it exists, otherwise return default or null
    return value !== null ? JSON.parse(value) : defaultValue ?? null;
  } catch (error) {
    // This could be a parsing error, storage access issue, or other
    console.warn(`Error getting item "${key}" from storage:`, error);
    
    // Return from memory store as fallback
    const memoryValue = memoryStore[key];
    return memoryValue ? JSON.parse(memoryValue) : defaultValue ?? null; 
  }
}

/**
 * Set item safely in storage with fallback to memory store
 */
export function setItem<T>(key: string, value: T): boolean {
  try {
    // Store as JSON string
    const valueString = JSON.stringify(value);
    
    // Always update memory store regardless of availability
    memoryStore[key] = valueString;
    
    // Skip localStorage in SSR or if unavailable
    if (!isStorageAvailable()) {
      return true; // Success using memory store
    }
    
    // Set in localStorage
    window.localStorage.setItem(key, valueString);
    return true;
  } catch (error) {
    console.warn(`Error setting item "${key}" in storage:`, error);
    
    // Still update memory store even if localStorage fails
    try {
      memoryStore[key] = JSON.stringify(value);
    } catch (e) {
      console.error(`Failed to save in memory store too:`, e);
      return false;
    }
    
    return true; // Success with fallback
  }
}

/**
 * Remove item safely from all storage
 */
export function removeItem(key: string): boolean {
  try {
    // Always remove from memory store
    delete memoryStore[key];
    
    // Skip localStorage in SSR or if unavailable
    if (!isStorageAvailable()) {
      return true;
    }
    
    // Remove from localStorage
    window.localStorage.removeItem(key);
    return true;
  } catch (error) {
    console.warn(`Error removing item "${key}" from storage:`, error);
    
    // Ensure it's removed from memory store even if localStorage fails
    delete memoryStore[key];
    return true;
  }
}

/**
 * Clear all storage safely
 */
export function clearStorage(): boolean {
  try {
    // Clear memory store
    Object.keys(memoryStore).forEach(key => delete memoryStore[key]);
    
    // Skip localStorage in SSR or if unavailable
    if (!isStorageAvailable()) {
      return true;
    }
    
    // Clear localStorage
    window.localStorage.clear();
    return true;
  } catch (error) {
    console.warn(`Error clearing storage:`, error);
    
    // Ensure memory store is cleared even if localStorage fails
    Object.keys(memoryStore).forEach(key => delete memoryStore[key]);
    return true;
  }
}

/**
 * Get all storage keys
 */
export function getAllKeys(): string[] {
  try {
    if (!isStorageAvailable()) {
      return Object.keys(memoryStore);
    }
    
    // Get keys from both localStorage and memory store
    const localStorageKeys = Object.keys(window.localStorage);
    const memoryStoreKeys = Object.keys(memoryStore);
    
    // Combine and remove duplicates
    return [...new Set([...localStorageKeys, ...memoryStoreKeys])];
  } catch (error) {
    console.warn(`Error getting storage keys:`, error);
    return Object.keys(memoryStore);
  }
}

/**
 * Check if we're using fallback storage
 */
export function isUsingFallbackStorage(): boolean {
  return !isStorageAvailable();
}

/**
 * Create a typed storage helper for specific data
 */
export function createTypedStorage<T>(key: string, defaultValue: T) {
  return {
    get: () => getItem<T>(key, defaultValue),
    set: (value: T) => setItem<T>(key, value),
    clear: () => removeItem(key)
  };
}

// Use helper functions directly
const safeStorage = {
  getItem,
  setItem,
  removeItem,
  clear: clearStorage,
  keys: getAllKeys,
  isAvailable: isStorageAvailable,
  isFallback: isUsingFallbackStorage,
  createTyped: createTypedStorage
};

export default safeStorage;
</file>

<file path="src/lib/storage-utils.ts">
'use client';

/**
 * Enhanced storage utilities with context detection and fallbacks
 * Prevents errors in restricted contexts (extensions, iframes, etc.)
 */

// In-memory fallback when localStorage isn't available
const memoryStorage: Record<string, string> = {};

// Context types
export type StorageContext = 
  | 'browser'       // Standard browser context with storage access
  | 'extension'     // Browser extension context
  | 'iframe'        // Embedded in an iframe
  | 'insecure'      // Non-HTTPS context with restricted features
  | 'incognito'     // Private/incognito browsing mode
  | 'server'        // Server-side rendering context
  | 'unknown';      // Context could not be determined

// Check if we're in a browser environment without throwing errors
function isBrowser(): boolean {
  return typeof window !== 'undefined';
}

// Detect current execution context
export function detectContext(): StorageContext {
  // Check for server-side rendering
  if (!isBrowser()) {
    return 'server';
  }

  // Safe check for extension context
  try {
    if (typeof (window as any).chrome !== 'undefined' && 
        (window as any).chrome.storage) {
      return 'extension';
    }
  } catch (e) {
    console.warn('Error checking for extension context:', e);
  }

  // Safe check for iframe
  try {
    if (window.top !== window.self) {
      return 'iframe';
    }
  } catch (e) {
    // If this errors, we're probably in a cross-origin iframe
    console.warn('Error checking for iframe context:', e);
    return 'iframe'; // Assume iframe with restrictions
  }

  // Check for insecure context (non-HTTPS except localhost)
  try {
    if (!window.isSecureContext) {
      return 'insecure';
    }
  } catch (e) {
    console.warn('Error checking for secure context:', e);
  }

  // Check for incognito/private mode or storage restrictions
  try {
    localStorage.setItem('__storage_test__', '__storage_test__');
    localStorage.removeItem('__storage_test__');
    sessionStorage.setItem('__storage_test__', '__storage_test__');
    sessionStorage.removeItem('__storage_test__');
    return 'browser';
  } catch (e) {
    // If storage test fails but browser isn't otherwise identified as a specific context
    return 'incognito';
  }
}

// Check if localStorage is available
export function isStorageAvailable(): boolean {
  if (!isBrowser()) return false;

  try {
    // First check if we're in a context that blocks storage APIs
    // Common in SSR, cross-origin iframes, or when "Block all cookies" is enabled
    if (window.localStorage === undefined || window.sessionStorage === undefined) {
      return false;
    }
    
    const testKey = '__storage_test__';
    window.localStorage.setItem(testKey, testKey);
    window.localStorage.removeItem(testKey);
    return true;
  } catch (e) {
    return false;
  }
}

// Get the appropriate storage method based on context
function getStorage(): Storage | Record<string, string> {
  // Always use memory storage in server context
  if (!isBrowser()) {
    return memoryStorage;
  }

  // Try to detect the context, but use memory storage as fallback if detection fails
  try {
    const context = detectContext();

    switch (context) {
      case 'browser':
        // Double-check storage is available
        if (isStorageAvailable()) {
          return localStorage;
        }
        return memoryStorage;
      case 'extension':
      case 'iframe':
      case 'incognito':
      case 'insecure':
      case 'server':
      case 'unknown':
      default:
        return memoryStorage;
    }
  } catch (e) {
    console.warn('Error getting storage, using memory fallback:', e);
    return memoryStorage;
  }
}

/**
 * Safe getItem - retrieves an item from the appropriate storage
 * without throwing errors in any context
 */
export function safeGetItem(key: string): string | null {
  // Always use memory storage in server context
  if (!isBrowser()) {
    return memoryStorage[key] || null;
  }

  try {
    const storage = getStorage();
    
    if (storage === memoryStorage) {
      return memoryStorage[key] || null;
    }
    
    return (storage as Storage).getItem(key);
  } catch (e) {
    console.warn(`Safe storage getItem failed for key "${key}":`, e);
    return memoryStorage[key] || null;
  }
}

/**
 * Safe setItem - stores an item in the appropriate storage
 * without throwing errors in any context
 */
export function safeSetItem(key: string, value: string): boolean {
  // Always use memory storage in server context
  if (!isBrowser()) {
    memoryStorage[key] = value;
    return true;
  }

  try {
    const storage = getStorage();
    
    if (storage === memoryStorage) {
      memoryStorage[key] = value;
      return true;
    }
    
    (storage as Storage).setItem(key, value);
    return true;
  } catch (e) {
    console.warn(`Safe storage setItem failed for key "${key}":`, e);
    // Fall back to memory storage
    memoryStorage[key] = value;
    return true;
  }
}

/**
 * Safe removeItem - removes an item from the appropriate storage
 * without throwing errors in any context
 */
export function safeRemoveItem(key: string): boolean {
  // Always use memory storage in server context
  if (!isBrowser()) {
    delete memoryStorage[key];
    return true;
  }

  try {
    const storage = getStorage();
    
    if (storage === memoryStorage) {
      delete memoryStorage[key];
      return true;
    }
    
    (storage as Storage).removeItem(key);
    return true;
  } catch (e) {
    console.warn(`Safe storage removeItem failed for key "${key}":`, e);
    // Still remove from memory storage
    delete memoryStorage[key];
    return true;
  }
}

/**
 * Safe clear - clears all items from the appropriate storage
 * without throwing errors in any context
 */
export function safeClear(): boolean {
  // Always use memory storage in server context
  if (!isBrowser()) {
    Object.keys(memoryStorage).forEach(key => {
      delete memoryStorage[key];
    });
    return true;
  }

  try {
    const storage = getStorage();
    
    if (storage === memoryStorage) {
      Object.keys(memoryStorage).forEach(key => {
        delete memoryStorage[key];
      });
      return true;
    }
    
    (storage as Storage).clear();
    return true;
  } catch (e) {
    console.warn('Safe storage clear failed:', e);
    // Still clear memory storage
    Object.keys(memoryStorage).forEach(key => {
      delete memoryStorage[key];
    });
    return true;
  }
}

// Additional utility for checking if we're using fallback storage
export function isUsingFallbackStorage(): boolean {
  if (!isBrowser()) return true;
  try {
    return getStorage() === memoryStorage;
  } catch (e) {
    return true;
  }
}

// Get all keys from current storage
export function getStorageKeys(): string[] {
  // Always use memory storage in server context
  if (!isBrowser()) {
    return Object.keys(memoryStorage);
  }

  try {
    const storage = getStorage();
    
    if (storage === memoryStorage) {
      return Object.keys(memoryStorage);
    }
    
    return Object.keys(storage);
  } catch (e) {
    console.warn('Failed to get storage keys:', e);
    return Object.keys(memoryStorage);
  }
}

// Get context-specific message for user feedback
export function getStorageContextMessage(): string {
  if (!isBrowser()) {
    return 'Server-side rendering detected. Using temporary storage.';
  }

  try {
    const context = detectContext();
    const usingFallback = isUsingFallbackStorage();
    
    if (usingFallback) {
      switch (context) {
        case 'extension':
          return 'Using extension storage mode. Your data will not persist between sessions.';
        case 'iframe':
          return 'Running in restricted iframe mode. Your data will not persist between sessions.';
        case 'incognito':
          return 'Private browsing detected. Your data will not persist between sessions.';
        case 'insecure':
          return 'Insecure context detected. For persistent storage, please use HTTPS.';
        case 'server':
          return 'Server-side rendering detected. Storage not available.';
        default:
          return 'Using temporary storage. Your data will not persist between sessions.';
      }
    }
    
    return 'Using persistent storage.';
  } catch (e) {
    return 'Using temporary storage due to browser restrictions.';
  }
}
</file>

<file path="src/lib/sui-client.ts">
/**
 * Basic client for interacting with Sui blockchain
 * This is a placeholder for actual blockchain integration
 */

export interface Todo {
  id: string;
  title: string;
  description?: string;
  completed: boolean;
  priority: 'low' | 'medium' | 'high';
  tags?: string[];
  dueDate?: string;
  blockchainStored: boolean;
  objectId?: string; // Sui object ID when stored on chain
}

export interface TodoList {
  name: string;
  todos: Todo[];
}

// In-memory storage instead of localStorage to avoid access issues
// Simulated wallet connection state
let connected = false;
let address = '';

// Safe storage check helper to avoid errors
const isStorageAvailable = () => {
  if (typeof window === 'undefined') return false;

  try {
    const testKey = '__storage_test__';
    window.localStorage.setItem(testKey, testKey);
    window.localStorage.removeItem(testKey);
    return true;
  } catch (e) {
    return false;
  }
};

/**
 * Connect to wallet (placeholder implementation)
 */
export async function connectWallet(): Promise<{ success: boolean; address: string }> {
  // This would be replaced with actual wallet connection logic
  return new Promise((resolve) => {
    setTimeout(() => {
      connected = true;
      address = '0x' + Array.from({ length: 40 }, () =>
        Math.floor(Math.random() * 16).toString(16)
      ).join('');

      // Only try to save to localStorage if it's available
      if (isStorageAvailable()) {
        try {
          localStorage.setItem('walletConnected', 'true');
          localStorage.setItem('walletAddress', address);
        } catch (e) {
          console.warn('Failed to save wallet state to localStorage:', e);
        }
      }

      resolve({
        success: true,
        address
      });
    }, 1000);
  });
}

/**
 * Check if wallet is connected
 */
export function isWalletConnected(): boolean {
  // Try to restore state from memory first
  if (connected) return true;

  // If we have access to localStorage, check there
  if (typeof window !== 'undefined' && isStorageAvailable()) {
    try {
      const storedConnected = localStorage.getItem('walletConnected');
      if (storedConnected === 'true') {
        connected = true;

        // Also restore the address if available
        const storedAddress = localStorage.getItem('walletAddress');
        if (storedAddress) {
          address = storedAddress;
        }
      }
    } catch (e) {
      console.warn('Failed to read wallet state from localStorage:', e);
    }
  }

  return connected;
}

/**
 * Get connected wallet address
 */
export function getWalletAddress(): string {
  // Check if we need to restore from localStorage
  if (!address && typeof window !== 'undefined' && isStorageAvailable()) {
    try {
      const storedAddress = localStorage.getItem('walletAddress');
      if (storedAddress) {
        address = storedAddress;
      }
    } catch (e) {
      console.warn('Failed to read wallet address from localStorage:', e);
    }
  }

  return address;
}

/**
 * Disconnect wallet
 */
export function disconnectWallet(): void {
  connected = false;
  address = '';

  // Clear localStorage if available
  if (typeof window !== 'undefined' && isStorageAvailable()) {
    try {
      localStorage.removeItem('walletConnected');
      localStorage.removeItem('walletAddress');
    } catch (e) {
      console.warn('Failed to clear wallet state in localStorage:', e);
    }
  }
}

/**
 * Get todos from blockchain (placeholder implementation)
 */
export async function getTodosFromBlockchain(): Promise<Todo[]> {
  // This would be replaced with actual blockchain data fetching
  return new Promise((resolve) => {
    setTimeout(() => {
      const mockTodos: Todo[] = [
        {
          id: 'sui-1',
          title: 'Test blockchain connection',
          completed: true,
          priority: 'high',
          blockchainStored: true,
          objectId: '0x' + Math.random().toString(16).slice(2, 10)
        },
        {
          id: 'sui-2',
          title: 'Create NFT todo',
          description: 'Using Walrus Storage for decentralized content',
          completed: false,
          priority: 'medium',
          tags: ['blockchain', 'nft'],
          blockchainStored: true,
          objectId: '0x' + Math.random().toString(16).slice(2, 10)
        }
      ];
      
      resolve(mockTodos);
    }, 1500);
  });
}

/**
 * Store todo on blockchain (placeholder implementation)
 */
export async function storeTodoOnBlockchain(todo: Todo): Promise<{ success: boolean; objectId?: string }> {
  if (!connected) {
    return { success: false };
  }
  
  return new Promise((resolve) => {
    setTimeout(() => {
      const objectId = '0x' + Math.random().toString(16).slice(2, 10);
      
      resolve({
        success: true,
        objectId
      });
    }, 2000);
  });
}

/**
 * Update todo on blockchain (placeholder implementation)
 */
export async function updateTodoOnBlockchain(todo: Todo): Promise<{ success: boolean }> {
  if (!connected || !todo.objectId) {
    return { success: false };
  }
  
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        success: true
      });
    }, 1500);
  });
}
</file>

<file path="src/lib/todo-service.ts">
/**
 * Service for managing local todo data
 * In a production app, this would integrate with the backend CLI
 */

import { Todo, TodoList } from './sui-client';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { Transaction } from '@mysten/sui/transactions';
import { PublicKey } from '@solana/web3.js';
import { 
  safeGetItem, 
  safeSetItem, 
  isUsingFallbackStorage, 
  detectContext 
} from './storage-utils';

// Define wallet-aware service types
export interface WalletSigner {
  signTransaction?: (transaction: Transaction) => Promise<any>;
  signAndExecuteTransaction?: (transaction: Transaction) => Promise<any>;
  address?: string;
  publicKey?: PublicKey | string | null;
}

// Mock data store - would be replaced with actual local storage or API calls
let todoLists: Record<string, TodoList> = {
  default: {
    name: 'Default',
    todos: [
      {
        id: '1',
        title: 'Set up blockchain wallet',
        completed: false,
        priority: 'high',
        tags: ['setup', 'blockchain'],
        blockchainStored: true,
        objectId: '0xabc123'
      },
      {
        id: '2',
        title: 'Design oceanic UI components',
        description: 'Create reusable Tailwind components with ocean theme',
        completed: true,
        priority: 'medium',
        tags: ['design', 'frontend'],
        blockchainStored: false
      },
      {
        id: '3',
        title: 'Implement Sui blockchain connectivity',
        completed: false,
        priority: 'high',
        dueDate: '2023-12-01',
        blockchainStored: false
      },
    ],
  },
  work: {
    name: 'Work',
    todos: [
      {
        id: '4',
        title: 'Test NFT todo transfers',
        completed: false,
        priority: 'medium',
        tags: ['testing', 'blockchain'],
        blockchainStored: false
      },
    ],
  },
  personal: {
    name: 'Personal',
    todos: [],
  },
  shopping: {
    name: 'Shopping',
    todos: [],
  },
};

/**
 * Try to load todo lists from storage
 */
function loadTodoLists(): void {
  try {
    const storedLists = safeGetItem('walrusTodoLists');
    if (storedLists) {
      const parsed = JSON.parse(storedLists);
      if (parsed && typeof parsed === 'object') {
        todoLists = parsed;
      }
    }
    
    if (isUsingFallbackStorage()) {
      const context = detectContext();
      console.info(`Using memory storage in ${context} context. Data will not persist between sessions.`);
    }
  } catch (e) {
    console.warn('Failed to load todo lists from storage:', e);
  }
}

/**
 * Save todo lists to storage
 */
function saveTodoLists(): void {
  try {
    const success = safeSetItem('walrusTodoLists', JSON.stringify(todoLists));
    if (!success && !isUsingFallbackStorage()) {
      console.warn('Failed to save to persistent storage, falling back to memory storage.');
    }
  } catch (e) {
    console.warn('Failed to save todo lists to storage:', e);
  }
}

/**
 * Get all todo lists
 */
export function getTodoLists(): string[] {
  // Try to load from storage first if needed
  loadTodoLists();
  return Object.keys(todoLists);
}

/**
 * Get a specific todo list
 */
export function getTodoList(listName: string): TodoList | null {
  // Try to load from storage first if needed
  loadTodoLists();
  return todoLists[listName] || null;
}

/**
 * Get todos for a specific list
 */
export function getTodos(listName: string): Todo[] {
  // Try to load from storage first if needed
  loadTodoLists();
  return todoLists[listName]?.todos || [];
}

/**
 * Add a new todo to a list
 */
export function addTodo(listName: string, todo: Omit<Todo, 'id' | 'blockchainStored'>): Todo {
  // Load latest data
  loadTodoLists();

  if (!todoLists[listName]) {
    todoLists[listName] = {
      name: listName,
      todos: [],
    };
  }

  const newTodo: Todo = {
    ...todo,
    id: Date.now().toString(),
    blockchainStored: false,
  };

  todoLists[listName].todos.push(newTodo);

  // Save changes
  saveTodoLists();

  return newTodo;
}

/**
 * Update an existing todo
 */
export function updateTodo(listName: string, updatedTodo: Todo): boolean {
  // Load latest data
  loadTodoLists();

  if (!todoLists[listName]) return false;

  const index = todoLists[listName].todos.findIndex(todo => todo.id === updatedTodo.id);
  if (index === -1) return false;

  todoLists[listName].todos[index] = updatedTodo;

  // Save changes
  saveTodoLists();

  return true;
}

/**
 * Delete a todo
 */
export function deleteTodo(listName: string, todoId: string): boolean {
  // Load latest data
  loadTodoLists();

  if (!todoLists[listName]) return false;

  const initialLength = todoLists[listName].todos.length;
  todoLists[listName].todos = todoLists[listName].todos.filter(todo => todo.id !== todoId);

  // Save changes
  saveTodoLists();

  return todoLists[listName].todos.length !== initialLength;
}

/**
 * Create a new todo list
 */
export function createTodoList(listName: string): boolean {
  // Load latest data
  loadTodoLists();

  if (todoLists[listName]) return false;

  todoLists[listName] = {
    name: listName,
    todos: [],
  };

  // Save changes
  saveTodoLists();

  return true;
}

/**
 * Delete a todo list
 */
export function deleteTodoList(listName: string): boolean {
  // Load latest data
  loadTodoLists();

  if (!todoLists[listName] || listName === 'default') return false;

  delete todoLists[listName];

  // Save changes
  saveTodoLists();

  return true;
}

/**
 * Mark a todo as stored on blockchain
 */
export function markTodoAsBlockchainStored(listName: string, todoId: string, objectId: string): boolean {
  // Load latest data
  loadTodoLists();

  if (!todoLists[listName]) return false;

  const todoIndex = todoLists[listName].todos.findIndex(todo => todo.id === todoId);
  if (todoIndex === -1) return false;

  todoLists[listName].todos[todoIndex].blockchainStored = true;
  todoLists[listName].todos[todoIndex].objectId = objectId;

  // Save changes
  saveTodoLists();

  return true;
}

/**
 * Store a todo on the blockchain using wallet signer
 * This is a placeholder that would integrate with the actual CLI backend
 */
export async function storeTodoOnBlockchain(
  listName: string, 
  todoId: string, 
  signer?: WalletSigner
): Promise<string | null> {
  // Load latest data
  loadTodoLists();

  if (!todoLists[listName]) return null;
  
  const todo = todoLists[listName].todos.find(t => t.id === todoId);
  if (!todo) return null;

  // If no signer provided, operate in read-only mode
  if (!signer || !signer.signAndExecuteTransaction) {
    console.warn('No wallet signer available - running in read-only mode');
    return null;
  }

  try {
    // Create a transaction for storing the todo
    // In production, this would call the actual smart contract
    const tx = new Transaction();
    
    // Example: Add a move call to the todo contract
    // tx.moveCall({
    //   target: '0x123::todo::create_todo',
    //   arguments: [
    //     tx.pure.string(todo.title),
    //     tx.pure.bool(todo.completed),
    //     tx.pure.string(todo.priority || 'medium')
    //   ],
    // });

    // For now, just simulate the transaction
    console.log('Would execute transaction for todo:', todo);
    
    // In production, execute the transaction
    // const result = await signer.signAndExecuteTransaction(tx);
    // const objectId = result.effects?.created?.[0]?.reference?.objectId || null;
    
    // Simulate getting an object ID
    const objectId = `0x${Math.random().toString(16).slice(2, 10)}`;
    
    // Mark the todo as stored
    markTodoAsBlockchainStored(listName, todoId, objectId);
    
    return objectId;
  } catch (error) {
    console.error('Failed to store todo on blockchain:', error);
    return null;
  }
}

/**
 * Retrieve todos from blockchain storage
 * This is a placeholder for future blockchain integration
 */
export async function retrieveTodosFromBlockchain(
  address?: string
): Promise<Todo[]> {
  if (!address) {
    console.warn('No address provided - cannot retrieve blockchain todos');
    return [];
  }

  try {
    // In production, this would query the blockchain for todos owned by the address
    console.log('Would retrieve todos for address:', address);
    
    // Return empty array for now
    return [];
  } catch (error) {
    console.error('Failed to retrieve todos from blockchain:', error);
    return [];
  }
}

/**
 * Transfer a todo NFT to another address
 * This requires the todo to be stored on blockchain
 */
export async function transferTodoNFT(
  listName: string,
  todoId: string,
  toAddress: string,
  signer?: WalletSigner
): Promise<boolean> {
  // Load latest data
  loadTodoLists();

  if (!todoLists[listName]) return false;
  
  const todo = todoLists[listName].todos.find(t => t.id === todoId);
  if (!todo || !todo.blockchainStored || !todo.objectId) {
    console.error('Todo not found or not stored on blockchain');
    return false;
  }

  if (!signer || !signer.signAndExecuteTransaction) {
    console.warn('No wallet signer available - cannot transfer NFT');
    return false;
  }

  try {
    // Create a transfer transaction
    const tx = new Transaction();
    
    // Example: Transfer the NFT
    // tx.transferObject({
    //   objectId: todo.objectId,
    //   recipient: toAddress,
    // });

    console.log('Would transfer NFT:', todo.objectId, 'to:', toAddress);
    
    // In production, execute the transaction
    // await signer.signAndExecuteTransaction(tx);
    
    // For now, just return success
    return true;
  } catch (error) {
    console.error('Failed to transfer todo NFT:', error);
    return false;
  }
}
</file>

<file path="src/lib/wallet-errors.ts">
/**
 * Custom wallet error classes and handlers
 */

// Base wallet error class
export class WalletError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'WalletError';
  }
}

// Error when no wallet is selected
export class WalletNotSelectedError extends WalletError {
  constructor() {
    super('No wallet selected. Please select a wallet before connecting.');
    this.name = 'WalletNotSelectedError';
  }
}

// Error when wallet is not installed
export class WalletNotInstalledError extends WalletError {
  walletName: string;
  
  constructor(walletName: string) {
    super(`${walletName} wallet is not installed. Please install the extension first.`);
    this.name = 'WalletNotInstalledError';
    this.walletName = walletName;
  }
}

// Error when wallet is not supported in this environment
export class WalletNotSupportedError extends WalletError {
  walletName: string;
  environment: string;
  
  constructor(walletName: string, environment: string) {
    super(`${walletName} wallet is not supported in ${environment}.`);
    this.name = 'WalletNotSupportedError';
    this.walletName = walletName;
    this.environment = environment;
  }
}

// Error when wallet connection is rejected by user
export class WalletConnectionRejectedError extends WalletError {
  constructor() {
    super('Wallet connection was rejected. Please try again.');
    this.name = 'WalletConnectionRejectedError';
  }
}

// Error when wallet is already connected
export class WalletAlreadyConnectedError extends WalletError {
  constructor() {
    super('Wallet is already connected.');
    this.name = 'WalletAlreadyConnectedError';
  }
}

// Helper function to categorize common wallet errors
export function categorizeWalletError(error: unknown): WalletError {
  // If already one of our custom errors, return it
  if (error instanceof WalletError) {
    return error;
  }
  
  // Convert to string for pattern matching
  const message = error instanceof Error ? error.message : String(error);
  const lowerMessage = message.toLowerCase();
  
  // Common error patterns
  if (lowerMessage.includes('user rejected') || lowerMessage.includes('user denied')) {
    return new WalletConnectionRejectedError();
  }
  
  if (lowerMessage.includes('not selected') || lowerMessage.includes('no wallet selected')) {
    return new WalletNotSelectedError();
  }
  
  if (lowerMessage.includes('not installed') || lowerMessage.includes('not detected')) {
    const walletName = lowerMessage.includes('phantom') ? 'Phantom' : 
                       lowerMessage.includes('sui') ? 'Sui' : 'Wallet';
    return new WalletNotInstalledError(walletName);
  }
  
  // If we can't categorize, return a generic WalletError
  return new WalletError(
    error instanceof Error ? error.message : 'Unknown wallet error occurred'
  );
}

// Get user-friendly error message and suggested action
export function getWalletErrorMessage(error: WalletError): {
  message: string; 
  suggestion: string;
} {
  if (error instanceof WalletNotSelectedError) {
    return {
      message: 'No wallet selected',
      suggestion: 'Please select a wallet before connecting'
    };
  }
  
  if (error instanceof WalletNotInstalledError) {
    return {
      message: `${error.walletName} wallet not installed`,
      suggestion: `Please install the ${error.walletName} browser extension first`
    };
  }
  
  if (error instanceof WalletNotSupportedError) {
    return {
      message: `${error.walletName} not supported`,
      suggestion: `Try using a different browser or environment`
    };
  }
  
  if (error instanceof WalletConnectionRejectedError) {
    return {
      message: 'Connection rejected',
      suggestion: 'Please approve the connection request in your wallet'
    };
  }
  
  if (error instanceof WalletAlreadyConnectedError) {
    return {
      message: 'Already connected',
      suggestion: 'Your wallet is already connected'
    };
  }
  
  // Default case
  return {
    message: error.message || 'Wallet error',
    suggestion: 'Please try again or use a different wallet'
  };
}
</file>

<file path="src/lib/walletContext.tsx">
'use client';

import React, { createContext, useContext, useState, useEffect, ReactNode, useMemo, useCallback } from 'react';
import { 
  createNetworkConfig, 
  SuiClientProvider, 
  WalletProvider as SuiWalletProvider,
  useCurrentAccount,
  useConnectWallet,
  useWallets
} from '@mysten/dapp-kit';
import { getFullnodeUrl } from '@mysten/sui/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import {
  ConnectionProvider,
  WalletProvider as SolanaWalletProvider,
  useConnection,
  useWallet as useSolanaWallet
} from '@solana/wallet-adapter-react';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';
import { Connection, clusterApiUrl, PublicKey } from '@solana/web3.js';
import { 
  WalletError,
  WalletNotSelectedError,
  WalletNotInstalledError,
  categorizeWalletError 
} from './wallet-errors';
import { SlushAccount } from '@/types/wallet';

// Configure networks for Sui
const { networkConfig } = createNetworkConfig({
  testnet: { url: getFullnodeUrl('testnet') },
  mainnet: { url: getFullnodeUrl('mainnet') },
});

// Import WalletType from types/wallet.ts
import { WalletType } from '@/types/wallet';

interface WalletContextValue {
  // Common
  connected: boolean;
  connecting: boolean;
  disconnect: () => Promise<void>;
  publicKey: string | null;
  walletType: WalletType;
  error: Error | null;
  setError: (error: Error | null) => void;
  
  // Sui specific
  suiConnect: () => Promise<void>;
  suiAccount: any | null;
  
  // Phantom specific
  phantomConnect: () => Promise<void>;
  phantomPublicKey: PublicKey | null;
  
  // Slush specific
  slushConnect: () => Promise<void>;
  slushAccount: SlushAccount | null;
}

const WalletContext = createContext<WalletContextValue | null>(null);

// Inner component to access both wallet contexts
function WalletContextInner({ children }: { children: ReactNode }) {
  const [walletType, setWalletType] = useState<WalletType>(null);
  const [connecting, setConnecting] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [slushAccount, setSlushAccount] = useState<SlushAccount | null>(null);
  const [slushAdapter, setSlushAdapter] = useState<any | null>(null);

  // Sui wallet hooks
  const suiAccount = useCurrentAccount();
  const { mutate: connectWallet } = useConnectWallet();
  const wallets = useWallets();
  
  // Get the first wallet (you might want to let users choose)
  const wallet = wallets[0];
  const suiConnected = !!suiAccount;

  // Solana wallet hooks  
  const { connect: solanaConnect, disconnect: solanaDisconnect, connected: solanaConnected, publicKey: solanaPublicKey } = useSolanaWallet();
  
  // Initialize Slush adapter if needed
  useEffect(() => {
    if (typeof window !== 'undefined' && !slushAdapter) {
      try {
        // Removed StashedWalletAdapter initialization as it's no longer available
        // Consider using WalletProvider configuration for wallet integration
        console.log('Slush wallet adapter initialization skipped - needs new implementation');
      } catch (error) {
        console.error('Failed to initialize Slush wallet adapter:', error);
      }
    }
  }, [slushAdapter]);
  
  // Combined connected state
  const connected = 
    walletType === 'sui' ? !!suiAccount : 
    walletType === 'phantom' ? solanaConnected : 
    walletType === 'slush' ? !!slushAccount : 
    false;
  
  // Combined public key
  const publicKey = 
    walletType === 'sui' ? suiAccount?.address || null :
    walletType === 'phantom' ? solanaPublicKey?.toBase58() || null :
    walletType === 'slush' ? slushAccount?.address || null :
    null;

  // Auto-detect persisted connections
  useEffect(() => {
    // Only auto-detect if no error present
    if (!error) {
      if (suiConnected && walletType !== 'sui') setWalletType('sui');
      else if (solanaConnected && walletType !== 'phantom') setWalletType('phantom');
      else if (slushAccount && walletType !== 'slush') setWalletType('slush');
    }
  }, [suiConnected, solanaConnected, slushAccount, walletType, error]);

  // Consolidated connect logic with enhanced error handling
  const handleConnect = useCallback(async (type: WalletType) => {
    if (!type) {
      const error = new WalletNotSelectedError();
      setError(error);
      return Promise.reject(error);
    }
    
    setConnecting(true);
    setError(null);
    
    try {
      // Check for specific wallet type
      if (type === 'sui') {
        if (!wallet) {
          const error = new WalletNotInstalledError('Sui');
          setError(error);
          return Promise.reject(error);
        }
        
        try {
          await connectWallet({ wallet });
        } catch (connErr) {
          const walletError = categorizeWalletError(connErr);
          setError(walletError);
          console.error(`Sui wallet connection error:`, walletError);
          return Promise.reject(walletError);
        }
      } else if (type === 'phantom') {
        if (typeof window === 'undefined' || !window.solana?.isPhantom) {
          const error = new WalletNotInstalledError('Phantom');
          setError(error);
          return Promise.reject(error);
        }
        
        try {
          await solanaConnect();
        } catch (connErr) {
          const walletError = categorizeWalletError(connErr);
          setError(walletError);
          console.error(`Phantom wallet connection error:`, walletError);
          return Promise.reject(walletError);
        }
      } else if (type === 'slush') {
        // Slush wallet integration temporarily disabled
        // Needs to be reimplemented using the current wallet API
        const error = new WalletNotInstalledError('Slush - temporarily unavailable');
        setError(error);
        console.warn('Slush wallet functionality is temporarily disabled and needs to be updated.');
        return Promise.reject(error);
        
        /* Original implementation that needs updating:
        if (!slushAdapter) {
          const error = new WalletNotInstalledError('Slush');
          setError(error);
          return Promise.reject(error);
        }
        
        try {
          const account = await slushAdapter.connect();
          setSlushAccount(account as SlushAccount);
        } catch (connErr) {
          const walletError = categorizeWalletError(connErr);
          setError(walletError);
          console.error(`Slush wallet connection error:`, walletError);
          return Promise.reject(walletError);
        }*/
      }
      }
      
      setWalletType(type);
      return Promise.resolve();
    } catch (error) {
      // Categorize and standardize wallet errors
      const walletError = categorizeWalletError(error);
      setError(walletError);
      console.error(`${type} wallet connection error:`, walletError);
      return Promise.reject(walletError);
    } finally {
      setConnecting(false);
    }
  }, [connectWallet, solanaConnect, slushAdapter, wallet]);

  // Wallet-specific connect methods with error pre-checks
  const suiConnect = useCallback(async () => {
    try {
      // Check wallet availability first to provide better UX
      if (!wallet) {
        const error = new WalletNotInstalledError('Sui');
        setError(error);
        return Promise.reject(error);
      }
      
      try {
        return await handleConnect('sui');
      } catch (err) {
        // handleConnect already handles errors, this just ensures we don't throw
        return Promise.reject(err);
      }
    } catch (error) {
      // This catch ensures errors are properly categorized
      const walletError = categorizeWalletError(error);
      // If this is a WalletNotSelectedError, provide more context
      if (walletError instanceof WalletNotSelectedError) {
        const betterError = new WalletNotSelectedError();
        setError(betterError);
        return Promise.reject(betterError);
      }
      
      // Always return a rejection rather than letting it propagate
      return Promise.reject(walletError);
    }
  }, [handleConnect, wallet]);
  
  const phantomConnect = useCallback(async () => {
    try {
      // Check wallet availability first to provide better UX
      if (typeof window === 'undefined' || !window.solana?.isPhantom) {
        const error = new WalletNotInstalledError('Phantom');
        setError(error);
        return Promise.reject(error);
      }
      
      // Direct implementation using solanaConnect instead of handleConnect for Phantom
      try {
        await solanaConnect();
        setWalletType('phantom');
        return Promise.resolve();
      } catch (connErr) {
        const walletError = categorizeWalletError(connErr);
        setError(walletError);
        console.error(`Phantom wallet connection error:`, walletError);
        return Promise.reject(walletError);
      }
    } catch (error) {
      // Special handling for WalletNotSelectedError
      const walletError = categorizeWalletError(error);
      // If error is a selection error, provide more context
      if (walletError instanceof WalletNotSelectedError) {
        const betterError = new WalletNotSelectedError();
        setError(betterError);
        return Promise.reject(betterError);
      }
      
      // Always return a rejection rather than letting it propagate
      return Promise.reject(walletError);
    }
  }, [solanaConnect, setError]);

  // Slush wallet connect method
  const slushConnect = useCallback(async () => {
    // Slush wallet connection temporarily disabled
    const error = new WalletNotInstalledError('Slush - temporarily unavailable');
    setError(error);
    console.warn('Slush wallet functionality is temporarily disabled and needs to be reimplemented.');
    return Promise.reject(error);
    
    /* Original implementation that needs updating:
    try {
      // Check wallet availability first
      if (!slushAdapter) {
        const error = new WalletNotInstalledError('Slush');
        setError(error);
        return Promise.reject(error);
      }
      
      try {
        return await handleConnect('slush');
      } catch (err) {
        // handleConnect already handles errors, this just ensures we don't throw
        return Promise.reject(err);
      }
    } catch (error) {
      // Special handling for WalletNotSelectedError
      const walletError = categorizeWalletError(error);
      if (walletError instanceof WalletNotSelectedError) {
        const betterError = new WalletNotSelectedError();
        setError(betterError);
        return Promise.reject(betterError);
      }
      
      // Always return a rejection rather than letting it propagate
      return Promise.reject(walletError);
    }
    */
  }, [setError]);

  // Universal disconnect
  const disconnect = useCallback(async () => {
    setError(null);
    
    try {
      if (walletType === 'sui') {
        // Sui dapp-kit handles disconnection automatically
        // We just need to clear our state
      } else if (walletType === 'phantom') {
        try {
          await solanaDisconnect();
        } catch (discErr) {
          console.error('Error disconnecting Phantom wallet:', discErr);
          // We'll still clear the wallet type even if disconnect fails
        }
      } else if (walletType === 'slush') {
        // Slush wallet disconnection temporarily disabled
        // Will be reimplemented with updated wallet API
        console.warn('Slush wallet disconnect functionality temporarily disabled.');
        setSlushAccount(null);
        /* Original implementation that needs updating:
        try {
          if (slushAdapter) {
            await slushAdapter.disconnect();
          }
          setSlushAccount(null);
        } catch (discErr) {
          console.error('Error disconnecting Slush wallet:', discErr);
          // We'll still clear the wallet type even if disconnect fails
        }*/
      }
      }
      setWalletType(null);
      return Promise.resolve();
    } catch (error) {
      const walletError = error instanceof Error ? error : new Error('Wallet disconnect failed');
      setError(walletError);
      console.error('Wallet disconnect error:', error);
      // Return rejection instead of throwing directly
      return Promise.reject(walletError);
    }
  }, [walletType, solanaDisconnect, slushAdapter]);

  const contextValue = useMemo<WalletContextValue>(() => ({
    connected,
    connecting,
    disconnect,
    publicKey,
    walletType,
    error,
    setError,
    suiConnect,
    suiAccount,
    phantomConnect,
    phantomPublicKey: solanaPublicKey,
    slushConnect,
    slushAccount,
  }), [
    connected, 
    connecting, 
    disconnect,
    publicKey, 
    walletType,
    error,
    setError,
    suiConnect,
    suiAccount, 
    phantomConnect,
    solanaPublicKey,
    slushConnect,
    slushAccount
  ]);

  return (
    <WalletContext.Provider value={contextValue}>
      {children}
    </WalletContext.Provider>
  );
}

// Main context provider
// Global error handler for unhandled promise rejections
const setupGlobalErrorHandlers = () => {
  if (typeof window !== 'undefined') {
    // This will help us debug unhandled promise rejections
    window.addEventListener('unhandledrejection', (event) => {
      console.error('UNHANDLED PROMISE REJECTION:', event.reason);
      
      // Prevent the default browser handling of the error
      event.preventDefault();
    });
  }
};

export function WalletContextProvider({ children }: { children: ReactNode }) {
  // Set up global error handlers when the context mounts
  useEffect(() => {
    setupGlobalErrorHandlers();
  }, []);

  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false,
        retry: false,
      },
    },
  }));
  
  // Create the Phantom adapter with error prevention
  const [phantomAdapter] = useState(() => {
    try {
      // Check if Phantom is already registered or not available
      if (typeof window === 'undefined' || !window.solana?.isPhantom) {
        // Skip adapter creation if Phantom isn't available
        return null;
      }
      
      // Create the adapter with error handling
      return new PhantomWalletAdapter();
    } catch (error) {
      console.error('Error creating PhantomWalletAdapter:', error);
      return null;
    }
  });
  
  const solanaEndpoint = clusterApiUrl('devnet');
  
  // Create a safe wallets array that won't cause duplicate registrations
  // Always provide an array, even if empty, to avoid errors
  const wallets = phantomAdapter ? [phantomAdapter] : [];

  return (
    <QueryClientProvider client={queryClient}>
      <SuiClientProvider networks={networkConfig} defaultNetwork="testnet">
        <SuiWalletProvider>
          <ConnectionProvider endpoint={solanaEndpoint}>
            <SolanaWalletProvider wallets={wallets} autoConnect={false}>
              <WalletContextInner>
                {children}
              </WalletContextInner>
            </SolanaWalletProvider>
          </ConnectionProvider>
        </SuiWalletProvider>
      </SuiClientProvider>
    </QueryClientProvider>
  );
}

// Hook to use wallet context
export function useWalletContext() {
  const context = useContext(WalletContext);
  if (!context) {
    throw new Error('useWalletContext must be used within WalletContextProvider');
  }
  return context;
}

// Export types
export type { WalletType, WalletContextValue };
</file>

<file path="src/styles/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 203, 240, 248; /* ocean-foam */
  --background-end-rgb: 144, 224, 239; /* ocean-light */
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 51, 102; /* ocean-deep */
    --background-end-rgb: 0, 119, 182; /* ocean-medium */
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
  min-height: 100vh;
}

@layer components {
  .ocean-card {
    @apply bg-white/30 dark:bg-ocean-deep/40 backdrop-blur-md rounded-xl p-6 shadow-dreamy border border-ocean-foam/50 dark:border-ocean-light/20;
  }
  
  .wave-animation {
    @apply relative overflow-hidden before:absolute before:inset-0 before:bg-ocean-wave before:bg-repeat-x before:bg-bottom before:opacity-10 before:dark:opacity-5;
  }
  
  .ocean-button {
    @apply bg-ocean-medium hover:bg-ocean-deep text-white font-semibold py-2 px-4 rounded-lg shadow-dreamy transition-all duration-300 ease-in-out transform hover:-translate-y-1 hover:shadow-underwater;
  }
  
  .ocean-input {
    @apply bg-white/50 dark:bg-ocean-deep/30 border border-ocean-light/50 dark:border-ocean-light/20 rounded-lg px-4 py-2 shadow-inner outline-none focus:ring-2 focus:ring-dream-teal transition-all duration-300;
  }
  
  .floating-element {
    @apply animate-float transition-all duration-300;
  }
}
</file>

<file path="src/types/wallet.ts">
/**
 * Wallet type definitions for the WalTodo application
 */

// Define supported wallet types
export type WalletType = 'sui' | 'phantom' | 'slush' | null;

// Re-export from existing context to maintain compatibility
export type { WalletContextValue } from '@/lib/walletContext';

// Slush wallet account interface (based on StashedWalletAdapter)
export interface SlushAccount {
  address: string;
  publicKey: Uint8Array;
  chains: string[];
  features: string[];
}
</file>

<file path="src/types/window.d.ts">
interface Window {
  suiWallet?: any;
  ethereum?: {
    isSuiWallet?: boolean;
    [key: string]: any;
  };
  martian?: {
    sui?: any;
    [key: string]: any;
  };
  suiet?: any;
  phantom?: {
    solana?: any;
    [key: string]: any;
  };
  solana?: {
    isPhantom?: boolean;
    [key: string]: any;
  };
}
</file>

<file path=".env.local.example">
# Frontend Environment Configuration
# Copy this file to .env.local and update values as needed

# API Configuration
NEXT_PUBLIC_API_URL=http://localhost:3000

# Wallet Configuration
NEXT_PUBLIC_SUI_NETWORK=testnet
NEXT_PUBLIC_SOLANA_NETWORK=devnet

# Feature Flags
NEXT_PUBLIC_ENABLE_WALLET_WARNING=true
NEXT_PUBLIC_ENABLE_STORAGE_FALLBACK=true

# Security Settings
NEXT_PUBLIC_ALLOWED_ORIGINS=http://localhost:3001,https://localhost:3001,http://127.0.0.1:3001,https://127.0.0.1:3001
</file>

<file path=".eslintrc.js">
module.exports = {
  root: true,
  extends: ['next', 'next/core-web-vitals'],
  rules: {
    'react/no-unescaped-entities': 'off',
    '@next/next/no-page-custom-font': 'off',
  },
  settings: {
    next: {
      rootDir: __dirname,
    },
  },
};
</file>

<file path=".gitignore">
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path=".npmrc">
# Frontend-specific configuration
registry=https://registry.npmjs.org/
strict-peer-dependencies=false
auto-install-peers=true
</file>

<file path="enable-simple-wallet.sh">
#!/bin/bash

# Script to enable simplified wallet context for development

echo "🔄 Switching to simplified wallet implementation..."

# Make sure we have the file
if [ ! -f src/contexts/SimpleWalletContext.tsx ]; then
  echo "❌ SimpleWalletContext.tsx not found. Aborting."
  exit 1
fi

# Add import statement to layout.tsx
echo "🔧 Updating app layout..."
sed -i '' 's/import { AppWalletProvider } from ".*"/import { SimpleWalletProvider } from "@\/contexts\/SimpleWalletContext"/' src/app/layout.tsx
sed -i '' 's/<AppWalletProvider>/<SimpleWalletProvider>/' src/app/layout.tsx
sed -i '' 's/<\/AppWalletProvider>/<\/SimpleWalletProvider>/' src/app/layout.tsx

# Update import in WalletConnectButton
echo "🔧 Updating WalletConnectButton..."
sed -i '' 's/import { useWalletContext } from ".*"/import { useWalletContext } from "@\/contexts\/SimpleWalletContext"/' src/components/WalletConnectButton.tsx

echo "✅ Switched to simplified wallet implementation."
echo "🔄 Please restart your development server now with:"
echo "   npm run dev:clean"
</file>

<file path="fix-all.sh">
#!/bin/bash

# All-in-one fix script for Next.js development issues

echo "🔧 Running complete fix for Next.js application..."

# Make script executable
chmod +x "$(dirname "$0")/fix-all.sh"
chmod +x "$(dirname "$0")/reset-next.sh"
chmod +x "$(dirname "$0")/enable-simple-wallet.sh"

# 1. Stop any running Next.js processes
echo "🛑 Stopping any running Next.js processes..."
pkill -f "node.*next" || true

# 2. Clean caches and artifacts
echo "🧹 Cleaning all caches and artifacts..."
rm -rf .next
rm -rf node_modules/.cache
rm -rf .next.lock

# 3. Install required dependencies
echo "📦 Installing required dependencies..."
npm install --save-dev style-loader
npm install --save-dev mini-css-extract-plugin@latest

# 4. Create ultrasimple config for Next.js
echo "⚙️ Creating ultrasimple Next.js config..."
cat > .simple-next.config.js << 'EOF'
/** @type {import('next').NextConfig} */
module.exports = {
  output: undefined,
  reactStrictMode: false,
  swcMinify: false,
  images: {
    domains: ['localhost', '192.168.8.204'],
  },
  experimental: {}
};
EOF

# 5. Switch to simple wallet implementation
echo "🔄 Switching to simple wallet implementation..."
./enable-simple-wallet.sh

# 6. Set optimal environment variables
echo "🌍 Setting optimal environment variables..."
export NODE_ENV=development
export NEXT_TELEMETRY_DISABLED=1
export NEXT_RUNTIME=nodejs
export NEXT_CONFIG_FILE=.simple-next.config.js
export NEXT_TURBO=0
export NODE_OPTIONS="--max-old-space-size=8192 --no-warnings"
export PORT=3002

# 7. Start the development server
echo "🚀 Starting Next.js development server..."
npx next dev --port 3002

echo "✅ Server should be running now!"
</file>

<file path="fix-dev-server.sh">
#!/bin/bash

# Script to fix Next.js development server issues
# Cleans caches and restarts the server properly

echo "🧹 Cleaning Next.js cache and fixing development server..."

# Make script executable
chmod +x "$(dirname "$0")/fix-dev-server.sh"

# Stop any running Next.js processes
echo "🛑 Stopping any running Next.js processes..."
pkill -f "node.*next" || true

# Clean Next.js cache
echo "🗑️  Removing .next directory..."
rm -rf .next
rm -rf node_modules/.cache
rm -rf .next.lock

# Handle node_modules problems
echo "🔧 Checking node_modules structure..."
if [ -f "node_modules/.pnpm/style-loader" ]; then
  echo "⚙️  Installing style-loader for CSS MIME type fix..."
  npm install --save-dev style-loader
fi

# Save current Next.js config
echo "📋 Backing up next.config.js..."
if [ -f "next.config.js" ]; then
  cp next.config.js next.config.js.bak
fi

# Check for port conflicts
PORT=3002
if lsof -Pi :$PORT -sTCP:LISTEN -t >/dev/null ; then
    echo "⚠️  Port $PORT is already in use. Killing process..."
    lsof -Pi :$PORT -sTCP:LISTEN -t | xargs kill -9 || true
fi

# Retry with alternate port if needed
if lsof -Pi :$PORT -sTCP:LISTEN -t >/dev/null ; then
    PORT=3003
    echo "⚠️  Using alternate port $PORT instead..."
fi

# Make sure node_modules are up to date
echo "📦 Checking for missing dependencies..."
if [ ! -d "node_modules" ] || [ ! -f "node_modules/.pnpm/lock.yaml" ]; then
    echo "📦 Installing dependencies..."
    npm install
fi

# Fix output configuration in dev mode
echo "⚙️  Setting development-specific environment variables..."
export NODE_ENV="development"
export NEXT_DISABLE_SOURCEMAPS=1
export NEXT_TELEMETRY_DISABLED=1

# Increase Node memory allowance
echo "🔧 Setting increased memory limits..."
export NODE_OPTIONS="--max-old-space-size=8192 --no-warnings"

# Use development mode with turbo disabled
echo "🚀 Starting Next.js dev server in clean mode on port $PORT..."
PORT=$PORT NODE_ENV=development NEXT_TURBO=0 npx next dev --no-lint --port $PORT

echo "✅ Server started successfully!"
</file>

<file path="INSTALLATION.md">
# Frontend-v2 Installation Guide

This document explains how to install and work with the Next.js frontend for the Walrus Todo application.

## Prerequisites

- Node.js LTS (≥18.x) 
- pnpm (≥8.x)

## Installation Steps

### 1. Clean Install

If you're setting up the frontend for the first time or experiencing installation issues:

```bash
# Clean up existing node_modules
cd packages/frontend-v2
rm -rf node_modules

# Clean pnpm store (optional)
pnpm store prune

# Install dependencies
pnpm install
```

### 2. Working with Workspace

This frontend is part of a pnpm workspace. If the root project has TypeScript errors during installation, you can still work with the frontend independently:

```bash
# Install only frontend dependencies
cd packages/frontend-v2
pnpm install --ignore-scripts

# Or if the workspace install fails, use CI mode
CI=true pnpm install
```

## Development

Start the development server:

```bash
pnpm dev
```

The server runs on http://localhost:3000 by default. If that port is in use, it will automatically use port 3001.

## Building

Create a production build:

```bash
pnpm build
```

## Linting

Run ESLint:

```bash
pnpm lint

# Fix lint issues automatically
pnpm lint:fix
```

## Troubleshooting

### Port Conflicts

If you see "Port 3000 is in use", the dev server will automatically use port 3001.

### TypeScript Errors in Root Project

The root project's TypeScript errors during `pnpm install` won't prevent the frontend from working. The frontend has its own TypeScript configuration and can be built independently.

### Network Issues During Install

If you experience timeouts during package installation:

1. Try using a different network
2. Use CI mode to disable prompts: `CI=true pnpm install`
3. Install packages one by one: `pnpm add <package-name>`

## Environment Configuration

The project includes `.npmrc` files for proper workspace configuration:

- Root `.npmrc`: Configures workspace-wide settings like `shamefully-hoist=true`
- Frontend `.npmrc`: Ensures proper package resolution

## CI/CD Integration

For CI pipelines, use:

```bash
# Install dependencies
CI=true pnpm install --filter @walrus-todo/frontend

# Build
pnpm --filter @walrus-todo/frontend build

# Lint
pnpm --filter @walrus-todo/frontend lint
```

## Additional Resources

- See the main [README.md](./README.md) for feature documentation
- Check [WALLET_INTEGRATION.md](./WALLET_INTEGRATION.md) for wallet setup
- Use [Next.js documentation](https://nextjs.org/docs) for framework-specific questions
</file>

<file path="jest.setup.js">
// Import Jest DOM extensions
import '@testing-library/jest-dom';

// Mock Next.js router
jest.mock('next/router', () => ({
  useRouter: () => ({
    pathname: '/',
    push: jest.fn(),
    replace: jest.fn(),
    prefetch: jest.fn(),
    back: jest.fn(),
  }),
}));

// Mock Next.js image component
jest.mock('next/image', () => ({
  __esModule: true,
  default: (props) => {
    // eslint-disable-next-line @next/next/no-img-element
    return <img {...props} alt={props.alt || ''} />;
  },
}));

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(), // Deprecated
    removeListener: jest.fn(), // Deprecated
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
});

// Mock IntersectionObserver
class MockIntersectionObserver {
  constructor(callback) {
    this.callback = callback;
    this.observe = jest.fn();
    this.unobserve = jest.fn();
    this.disconnect = jest.fn();
  }
}

Object.defineProperty(window, 'IntersectionObserver', {
  writable: true,
  value: MockIntersectionObserver,
});

// Suppress console errors during tests
const originalError = console.error;
console.error = (...args) => {
  // Suppress specific Next.js errors that occur in tests
  const errorStr = String(args[0]);
  if (
    errorStr.includes('Warning: ReactDOM.render is no longer supported') ||
    errorStr.includes('Warning: useLayoutEffect does nothing on the server') ||
    errorStr.includes('Error: Uncaught [Error: Expected server HTML to contain a matching')
  ) {
    return;
  }
  originalError(...args);
};

// Mock ResizeObserver
class MockResizeObserver {
  constructor(callback) {
    this.callback = callback;
    this.observe = jest.fn();
    this.unobserve = jest.fn();
    this.disconnect = jest.fn();
  }
}

Object.defineProperty(window, 'ResizeObserver', {
  writable: true,
  value: MockResizeObserver,
});
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  images: {
    domains: ['localhost', '192.168.8.204'],
  },
  // Disable chunking for development to fix MIME type issues
  output: process.env.NODE_ENV === 'production' ? 'standalone' : undefined,
  
  // Increase timeout for static generation
  staticPageGenerationTimeout: 180,
  
  webpack: (config, { isServer, dev }) => {
    // Fix for node-fetch encoding issue
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        fs: false,
        net: false,
        tls: false,
        encoding: false,
      };
      
      // For development mode, completely disable code splitting
      // This prevents MIME type issues with chunked files
      if (dev) {
        config.optimization.splitChunks = false;
        config.optimization.runtimeChunk = false;
        
        // Simplify CSS handling to prevent MIME type issues
        // Safer approach that doesn't rely on complex find operations
        config.module.rules.forEach(rule => {
          if (rule.oneOf) {
            rule.oneOf.forEach(r => {
              if (r.test && r.test.toString().includes('css')) {
                // For CSS modules, ensure they're handled by style-loader
                if (r.use && Array.isArray(r.use)) {
                  for (let i = 0; i < r.use.length; i++) {
                    const loader = r.use[i];
                    if (typeof loader === 'object' && 
                        loader.loader && 
                        loader.loader.includes('mini-css-extract-plugin')) {
                      // Replace mini-css-extract-plugin with style-loader
                      r.use[i] = {
                        loader: require.resolve('style-loader')
                      };
                    }
                  }
                }
              }
            });
          }
        });
      } else {
        // More sophisticated chunking for production
        config.optimization.splitChunks = {
          chunks: 'all',
          cacheGroups: {
            default: false,
            vendors: false,
            commons: {
              name: 'commons',
              test: /[\\/]node_modules[\\/]/,
              chunks: 'all',
              priority: 10,
            },
            framework: {
              name: 'framework',
              test: /[\\/]node_modules[\\/](react|react-dom|scheduler|prop-types|use-subscription)[\\/]/,
              chunks: 'all',
              priority: 20,
            },
          },
        };
      }
    }
    
    return config;
  },
  
  // Configure runtime to handle client-side operations correctly
  experimental: {
    // Configure server actions
    serverActions: {
      bodySizeLimit: '2mb',
    },
    // Force full page rendering
    workerThreads: false,
    // Use simple compiler options
    optimizeCss: false,
  },
  
  // Define custom headers to help with caching and security
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'no-cache, no-store, must-revalidate',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'X-Frame-Options',
            value: 'SAMEORIGIN',
          },
        ],
      },
    ];
  },

  // Fix for development server restarts
  onDemandEntries: {
    // Keep pages in memory for longer
    maxInactiveAge: 60 * 60 * 1000, // 1 hour
    pagesBufferLength: 5,
  },
}

module.exports = nextConfig
</file>

<file path="package.json">
{
  "name": "@walrus-todo/frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "fix-dev": "sh ./fix-dev-server.sh",
    "clean": "rm -rf .next node_modules/.cache",
    "dev:clean": "pnpm run clean && next dev",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "dependencies": {
    "@heroicons/react": "^2.0.18",
    "@mysten/dapp-kit": "^0.16.3",
    "@mysten/sui": "^1.29.1",
    "@solana/wallet-adapter-phantom": "^0.9.0",
    "@solana/wallet-adapter-react": "^0.15.0",
    "@solana/web3.js": "^1.95.0",
    "@suiet/wallet-kit": "^0.4.1",
    "@tanstack/react-query": "^5.76.1",
    "encoding": "^0.1.13",
    "nanoid": "^5.1.5",
    "next": "15.3.2",
    "react": "18.3.1",
    "react-dom": "18.3.1"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^14.2.1",
    "@types/jest": "^29.5.12",
    "@types/node": "22.0.0",
    "@types/react": "18.3.1",
    "@types/react-dom": "18.3.1",
    "autoprefixer": "10.4.20",
    "eslint": "^9.0.0",
    "eslint-config-next": "15.3.2",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "postcss": "8.4.30",
    "sinon": "^19.0.0",
    "style-loader": "^4.0.0",
    "tailwindcss": "3.4.0",
    "typescript": "5.8.3"
  },
  "jest": {
    "testEnvironment": "jsdom",
    "moduleNameMapper": {
      "^@/(.*)$": "<rootDir>/src/$1"
    },
    "setupFilesAfterEnv": [
      "<rootDir>/jest.setup.js"
    ],
    "testPathIgnorePatterns": [
      "<rootDir>/node_modules/",
      "<rootDir>/.next/"
    ],
    "transform": {
      "^.+\\.(js|jsx|ts|tsx)$": [
        "babel-jest",
        {
          "presets": [
            "next/babel"
          ]
        }
      ]
    },
    "modulePaths": [
      "<rootDir>"
    ]
  }
}
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="README.md">
# Walrus Todo Web3 Frontend

A modern, oceanic-themed Web3 frontend for the Walrus Todo application built with Next.js and Tailwind CSS.

## Features

- Dreamy oceanic design with glass-morphism cards
- Responsive layout for all device sizes
- Integration with Sui blockchain for NFT todos
- Dual wallet support: Sui ecosystem and Phantom (Solana)
- Unified wallet context for seamless integration
- Animated UI elements with wave and floating effects
- Resilient local storage with fallbacks for restricted environments

## Getting Started

### Installation

First, install dependencies:

```bash
# From this directory
pnpm install

# If the root workspace has TypeScript errors, use:
CI=true pnpm install

# For clean installation
rm -rf node_modules && pnpm install
```

For detailed installation instructions, see [INSTALLATION.md](./INSTALLATION.md).

### Development

Run the development server:

```bash
pnpm dev
```

Open [http://localhost:3000](http://localhost:3000) (or http://localhost:3001 if port 3000 is in use) with your browser to see the result.

### Building

Create a production build:

```bash
pnpm build
```

### Linting

Run ESLint to check code quality:

```bash
pnpm lint
pnpm lint:fix  # Auto-fix issues
```

## Design System

This frontend uses a custom oceanic theme with:

- Ocean-inspired color palette (deep blues, teals, light foam colors)
- Glass-morphism cards with backdrop blur
- Subtle animations including floating elements and waves
- Responsive components optimized for all device sizes
- System font stack for optimal performance and availability

### Color Palette

- `ocean-deep`: #003366 - Deep blue for primary elements and dark backgrounds
- `ocean-medium`: #0077b6 - Medium blue for buttons and interactive elements
- `ocean-light`: #90e0ef - Light blue for hover states and accents
- `ocean-foam`: #caf0f8 - Very light blue for backgrounds and subtle elements
- `dream-purple`: #7209b7 - Purple for special elements and NFT indicators
- `dream-violet`: #9d4edd - Light purple for accents
- `dream-teal`: #48bfe3 - Teal for highlights and gradients
- `coral`: #ff7f50 - Accent color for attention-grabbing elements
- `sand`: #f5e1c0 - Neutral warm color for contrast

## Pages

### Home (/)
- Hero section with animated logo
- Feature highlights with glass-morphism cards
- Wallet connection button and simulation

### Dashboard (/dashboard)
- Todo list management interface
- Create new todos with priority, tags, due date
- Toggle todo completion
- List selection sidebar

### Blockchain (/blockchain)
- View NFT todos stored on the blockchain
- Display object IDs and transaction information
- Link to blockchain explorer

## Components

- `Navbar` - Navigation and wallet connection
- `TodoList` - Display and manage todo items
- `CreateTodoForm` - Form for creating new todos
- `WalletConnectButton` - Unified wallet connection UI
- `WalletContextProvider` - Global wallet state management

## Wallet Integration

### Supported Wallets

1. **Sui Ecosystem Wallets**:
   - Sui Wallet
   - Suiet
   - Martian
   - Other wallets compatible with `@mysten/dapp-kit`

2. **Phantom Wallet** (Solana):
   - Used for cross-chain compatibility
   - Future integration with Solana ecosystem

### Wallet Setup

1. Install a supported wallet extension in your browser
2. Connect your wallet using the button in the navigation bar
3. Approve transaction requests for blockchain operations

### Wallet Context

The app uses a unified wallet context that provides:
- Connect/disconnect functionality
- Address display
- Transaction signing capabilities
- Cross-wallet compatibility

## Integration with Backend

This frontend integrates with the Walrus Todo CLI backend for:

- Todo storage on the blockchain
- NFT representation of todos
- Wallet connectivity for blockchain transactions
- Data synchronization between local and blockchain storage
- Signer integration for authenticated operations

## Storage System

The frontend implements a robust storage system with:

- In-memory state management for core functionality
- Conditional localStorage persistence when available
- Graceful fallbacks for environments where storage access is restricted
- Storage availability detection and error handling

## Project Structure

- `src/app` - Next.js App Router pages
- `src/components` - Reusable React components
  - `src/components/WalletConnectButton.tsx` - Wallet connection UI
- `src/styles` - CSS and Tailwind configuration
- `src/lib` - Utility functions and blockchain integration
  - `src/lib/sui-client.ts` - Blockchain interaction simulation
  - `src/lib/todo-service.ts` - Todo data management with wallet integration
  - `src/lib/walletContext.tsx` - Unified wallet state management
- `public` - Static assets including images

## Browser Compatibility

The application is designed to work in various environments:

- Modern browsers (Chrome, Firefox, Safari, Edge)
- Mobile browsers with responsive design
- Environments with restricted localStorage access
- Server-side rendering compatible components

## Production Deployment

Build the application for production:

```bash
pnpm build
```

Then start the production server:

```bash
pnpm start
```

## Parent Project Integration

This frontend is part of the Walrus Todo monorepo and can be run from the root directory with:

```bash
# Install dependencies
pnpm run nextjs:install

# Run development server
pnpm run nextjs

# Build for production
pnpm run nextjs:build
```
</file>

<file path="reset-next.sh">
#!/bin/bash

# Script to reset and restart Next.js dev server when things go wrong
# This fixes common issues with the development server

echo "🧹 Complete Next.js reset..."

# Stop any running Next.js servers
echo "🛑 Stopping current servers..."
pkill -f "node.*next" || true

# Clean caches and build artifacts
echo "🗑️ Cleaning caches and build artifacts..."
rm -rf .next
rm -rf node_modules/.cache
rm -rf .next.lock

# Clear NPM cache for Next.js
echo "🧽 Clearing npm cache for Next.js..."
npm cache clean --force next react react-dom

# Install required dev dependencies
echo "📦 Installing essential dev dependencies..."
npm install --save-dev style-loader
npm install --no-save mini-css-extract-plugin@latest

# Set development environment
echo "⚙️ Setting development environment..."
export NODE_ENV="development"
export NEXT_DISABLE_SOURCEMAPS=1
export NEXT_TELEMETRY_DISABLED=1
export NEXT_RUNTIME="nodejs"
export PORT=3002

# Simplify Next.js configuration for development
echo "🔧 Creating simplified development config..."
cat > .next.config.simple.js << 'EOF'
/** @type {import('next').NextConfig} */
module.exports = {
  reactStrictMode: true,
  images: {
    domains: ['localhost', '192.168.8.204'],
  },
  webpack: (config) => {
    if (!config.resolve) config.resolve = {};
    if (!config.resolve.fallback) config.resolve.fallback = {};
    
    config.resolve.fallback = {
      ...config.resolve.fallback,
      fs: false,
      net: false,
      tls: false,
      encoding: false,
    };
    
    // Disable code splitting completely
    config.optimization = {
      ...config.optimization,
      splitChunks: false,
      runtimeChunk: false,
    };
    
    return config;
  },
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'no-cache, no-store, must-revalidate',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          }
        ],
      }
    ];
  }
};
EOF

# Launch the development server with simplified config
echo "🚀 Starting Next.js server with clean slate..."
NEXT_CONFIG_FILE=.next.config.simple.js NEXT_TURBO=0 NODE_OPTIONS="--max-old-space-size=8192 --no-warnings" npx next dev --port $PORT

echo "✅ Next.js dev server restarted successfully!"
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    fontFamily: {
      sans: [
        'ui-sans-serif',
        'system-ui',
        '-apple-system',
        'BlinkMacSystemFont',
        '"Segoe UI"',
        'Roboto',
        '"Helvetica Neue"',
        'Arial',
        'sans-serif',
      ],
    },
    extend: {
      colors: {
        // Oceanic dreamy palette
        'ocean-deep': '#003366',
        'ocean-medium': '#0077b6',
        'ocean-light': '#90e0ef',
        'ocean-foam': '#caf0f8',
        'dream-purple': '#7209b7',
        'dream-violet': '#9d4edd',
        'dream-teal': '#48bfe3',
        'coral': '#ff7f50',
        'sand': '#f5e1c0',
      },
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic': 'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
        'ocean-wave': 'url("/images/ocean-wave.svg")',
      },
      animation: {
        'wave': 'wave 8s ease-in-out infinite',
        'float': 'float 6s ease-in-out infinite',
      },
      keyframes: {
        wave: {
          '0%, 100%': { transform: 'translateY(0)' },
          '50%': { transform: 'translateY(-20px)' },
        },
        float: {
          '0%, 100%': { transform: 'translateY(0) rotate(0deg)' },
          '50%': { transform: 'translateY(-10px) rotate(2deg)' },
        },
      },
      boxShadow: {
        'dreamy': '0 4px 30px rgba(0, 105, 148, 0.3)',
        'underwater': '0 8px 32px rgba(144, 224, 239, 0.3)',
      },
    },
  },
  plugins: [],
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="WALLET_INTEGRATION.md">
# Wallet Integration Documentation

## Overview

The WalTodo frontend supports wallet integration for **Sui**, **Phantom**, and **Slush** (formerly Stashed) wallets, enabling users to connect their Web3 wallets and interact with the blockchain features of the application.

## Architecture

### 1. WalletContext (`src/lib/walletContext.tsx`)

The core of our wallet integration, providing a unified interface for both Sui and Solana wallets.

**Key Features:**
- Multi-wallet support (Sui, Phantom, and Slush)
- Unified API for different wallet types
- Automatic connection persistence
- Error handling and state management
- Provider hierarchy setup
- Flexible adapter pattern for wallet integrations

**Main Components:**
- `WalletContextProvider`: Wraps the app with necessary providers
- `WalletContextInner`: Manages wallet state and connection logic
- `useWalletContext`: Hook for accessing wallet functionality

**Context Value Interface:**
```typescript
interface WalletContextValue {
  // Common properties
  connected: boolean;
  connecting: boolean;
  disconnect: () => Promise<void>;
  publicKey: string | null;
  walletType: WalletType;
  error: Error | null;
  setError: (error: Error | null) => void;
  
  // Sui specific
  suiConnect: () => Promise<void>;
  suiAccount: SuiAccount | null;
  
  // Phantom specific
  phantomConnect: () => Promise<void>;
  phantomPublicKey: PublicKey | null;
  
  // Slush specific
  slushConnect: () => Promise<void>;
  slushAccount: SlushAccount | null;
}
```

### 2. WalletConnectButton (`src/components/WalletConnectButton.tsx`)

UI component for wallet connection functionality.

**Features:**
- Auto-detects installed wallet extensions
- Shows different states (connecting, connected, disconnected)
- Displays truncated wallet address when connected
- Separate buttons for Sui, Phantom, and Slush wallets
- Error display with recovery options
- Copy address functionality
- Responsive design with oceanic theme

### 3. Integration Points

- **Root Layout** (`app/layout.tsx`): Wraps the entire app with `WalletContextProvider`
- **Navbar** (`components/navbar.tsx`): Includes the `WalletConnectButton` component
- **Blockchain Page** (`app/blockchain/page.tsx`): Uses wallet connection for NFT functionality
- **Example Usage** (`app/examples/wallet-usage.tsx`): Shows how to use wallet integration

## Dependencies

### Required Dependencies

The following packages need to be installed in `packages/frontend-v2/`:

```json
{
  "dependencies": {
    "@mysten/dapp-kit": "latest",
    "@mysten/sui": "latest",
    "@tanstack/react-query": "latest",
    "@solana/wallet-adapter-react": "latest",
    "@solana/wallet-adapter-phantom": "latest",
    "@solana/web3.js": "latest"
  }
}
```

### Installation Command

```bash
cd waltodo-frontend
pnpm add @mysten/dapp-kit @mysten/sui @tanstack/react-query @solana/wallet-adapter-react @solana/wallet-adapter-phantom @solana/web3.js
```

## Setup and Commands

### Initial Setup

1. **Install Frontend Dependencies**
   ```bash
   cd packages/frontend-v2
   pnpm install
   ```

2. **Install Wallet Dependencies** (if not already present)
   ```bash
   pnpm add @mysten/dapp-kit @mysten/sui @tanstack/react-query @solana/wallet-adapter-react @solana/wallet-adapter-phantom @solana/web3.js
   ```

3. **Return to Root Directory**
   ```bash
   cd ../..
   ```

### Development Commands

From the root directory of the project:

```bash
# Install frontend dependencies
pnpm run nextjs:install

# Start development server (runs on port 3000)
pnpm run nextjs

# Build for production
pnpm run nextjs:build

# Start production server
pnpm run nextjs:start

# Build both backend and frontend
pnpm run build:all
```

### Quick Start

```bash
# One-liner to get started
cd packages/frontend-v2 && pnpm install && cd ../.. && pnpm run nextjs
```

## Usage

### Basic Usage in Components

```typescript
import { useWalletContext } from '@/lib/walletContext';

export function MyComponent() {
  const {
    connected,
    publicKey,
    walletType,
    suiConnect,
    phantomConnect,
    slushConnect,
    disconnect,
    error
  } = useWalletContext();

  // Use wallet functionality
  if (!connected) {
    return (
      <div>
        <button onClick={suiConnect}>Connect Sui Wallet</button>
        <button onClick={phantomConnect}>Connect Phantom</button>
        <button onClick={slushConnect}>Connect Slush Wallet</button>
      </div>
    );
  }

  return (
    <div>
      <p>Connected with {walletType}: {publicKey}</p>
      <button onClick={disconnect}>Disconnect</button>
    </div>
  );
}
```

### Blockchain Interactions

```typescript
import { useWalletContext } from '@/lib/walletContext';
import { storeTodoOnBlockchain } from '@/lib/todo-service';

export function BlockchainTodo() {
  const { connected, walletType, suiAccount, phantomPublicKey, slushAccount } = useWalletContext();

  const handleStore = async (listName: string, todoId: string) => {
    if (!connected) {
      alert('Please connect your wallet first');
      return;
    }

    // Create signer based on wallet type
    let signer;
    if (walletType === 'sui') {
      signer = { address: suiAccount?.address, /* ... */ };
    } else if (walletType === 'phantom') {
      signer = { publicKey: phantomPublicKey, /* ... */ };
    } else if (walletType === 'slush') {
      signer = { address: slushAccount?.address, /* ... */ };
    }

    const objectId = await storeTodoOnBlockchain(listName, todoId, signer);
    console.log('Stored with ID:', objectId);
  };

  // Component implementation...
}
```

## Testing

### Prerequisites

- Install a Sui wallet (Sui Wallet, Suiet, or Martian)
- Install Phantom wallet for Solana/cross-chain functionality
- Install Slush wallet (formerly Stashed) for additional Sui wallet support
- Ensure you have testnet tokens

### Test Steps

1. Start the development server: `pnpm run nextjs`
2. Navigate to `http://localhost:3000`
3. Look for the wallet connect button in the navbar
4. Click to connect your preferred wallet
5. Visit the blockchain page (`/blockchain`) to view NFT todos
6. Test disconnection functionality

## Supported Wallets

### Sui Wallets
- Sui Wallet (official)
- Suiet
- Martian (Sui mode)
- Slush (formerly Stashed)

### Solana Wallets
- Phantom

## Features

### Current Features
- ✅ Multi-wallet support (Sui, Phantom, and Slush)
- ✅ Auto-detection of installed wallets
- ✅ Connection persistence
- ✅ Wallet switching
- ✅ Error handling with recovery options
- ✅ Responsive UI
- ✅ Truncated address display with copy functionality
- ✅ Connection status indicators
- ✅ DApp Kit integration

### Planned Features
- [ ] Additional wallet support (MetaMask via Sui compatibility)
- [ ] Transaction signing UI
- [ ] Balance display
- [ ] Network switching (testnet/mainnet)
- [ ] Wallet connect modal
- [ ] Mobile wallet support
- [ ] Multi-chain asset display

## Troubleshooting

### Common Issues

1. **Dependencies not found**
   - Run: `cd packages/frontend-v2 && pnpm install`
   - Install missing wallet packages

2. **Wallet not detected**
   - Ensure wallet extension is installed
   - Refresh the page
   - Check browser console for errors

3. **Connection fails**
   - Check network connectivity
   - Ensure wallet is unlocked
   - Try disconnecting and reconnecting

4. **Build errors**
   - Clear Next.js cache: `rm -rf .next`
   - Reinstall dependencies: `rm -rf node_modules && pnpm install`

### Debug Mode

Add to your component to debug wallet state:
```typescript
const walletContext = useWalletContext();
console.log('Wallet context:', walletContext);
```

## Architecture Decisions

### Why Multiple Wallet Support?

We support Sui, Phantom, and Slush wallets to:
- Provide flexibility for users with different wallet preferences
- Enable cross-chain functionality (future feature)
- Increase adoption by supporting popular wallets
- Improve user experience with choice of interfaces
- Support various security models preferred by different user segments

### Provider Hierarchy

The provider structure ensures:
1. QueryClient for React Query (data fetching)
2. SuiClient for Sui blockchain interaction
3. Connection Provider for Solana RPC
4. Wallet Providers for actual wallet connections
5. Our unified WalletContext on top

This hierarchy ensures all necessary providers are available throughout the app.

## Contributing

When adding new wallet integrations:

1. Add the wallet adapter to dependencies
2. Update `WalletContextProvider` with new provider
3. Add connection logic in `WalletContextInner`
4. Update `WalletConnectButton` with new wallet option
5. Add TypeScript types for new wallet
6. Update this documentation

## Resources

- [Sui Wallet Documentation](https://docs.mysten.io/dapp-kit)
- [Phantom Wallet Docs](https://docs.phantom.app)
- [Solana Wallet Adapter](https://github.com/solana-labs/wallet-adapter)
- [Mysten DApp Kit](https://docs.sui.io/guides/developer/integration-guides/dapp-kit)
- [Stashed/Slush Wallet](https://www.slushwallet.xyz/)
- [Next.js Documentation](https://nextjs.org/docs)
</file>

</files>
