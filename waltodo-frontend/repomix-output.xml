This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__tests__/
  components/
    SessionTimeoutWarning.test.tsx
    TransactionHistory.test.tsx
    WalletConnectButton.test.tsx
  contexts/
    WalletContext.test.tsx
  hooks/
    useBlockchainEvents.test.tsx
    useInactivityTimer.test.tsx
  integration/
    WalletIntegration.test.tsx
docs/
  FIXING_BROWSER_ERRORS.md
  FRONTEND_FIXES.md
public/
  config/
    testnet.json
  images/
    ocean-wave.svg
scripts/
  start-with-available-port.js
src/
  app/
    about/
      page.tsx
    blockchain/
      page.tsx
    dashboard/
      page.tsx
    examples/
      page.tsx
      wallet-usage.tsx
    test-blockchain/
      page.tsx
    walrus/
      page.tsx
    ClientOnlyRoot.tsx
    layout.tsx
    page.tsx
  components/
    BlockchainEventStatus.tsx
    BlockchainTodoManager.tsx
    ClientOnly.tsx
    ClipboardErrorModal.tsx
    context-warning.tsx
    create-todo-form.tsx
    ErrorBoundary.tsx
    ErrorHandlingProvider.tsx
    ErrorSuppressor.tsx
    navbar.tsx
    RealtimeTodoList.tsx
    SessionTimeoutWarning.tsx
    StorageContextWarning.tsx
    todo-list.tsx
    TransactionHistory.tsx
    TransactionSigner.tsx
    WalletConnectButton.tsx
    WalletErrorModal.tsx
    WalletSelector.tsx
    WalletStatus.tsx
    WalrusStorageManager.tsx
  contexts/
    SimpleWalletContext.tsx
    WalletContext.tsx
  examples/
    blockchain-events-usage.tsx
  hooks/
    useBlockchainEvents.ts
    useInactivityTimer.ts
    useSuiTodos.ts
    useWalrusStorage.ts
  lib/
    api-client.ts
    blockchain-events.ts
    clipboard.ts
    config-loader.ts
    global-error-suppression.ts
    safe-storage.ts
    storage-utils.ts
    sui-client-utils.ts
    sui-client.ts
    todo-service.ts
    wallet-errors.ts
    wallet-safe-operations.ts
    walrus-client.ts
    walrus-error-handling.ts
    walrus-todo-integration.ts
  styles/
    globals.css
  types/
    blockchain-events.ts
    todo.ts
    wallet.ts
    window.d.ts
.eslintrc.js
.gitignore
.npmrc
.prettierrc.json
enable-simple-wallet.sh
fix-all.sh
fix-dev-server.sh
INSTALLATION.md
jest.setup.js
next.config.js
package.json
postcss.config.js
README-BLOCKCHAIN-EVENTS.md
README.md
reset-next.sh
setup-config.js
tailwind.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__tests__/components/SessionTimeoutWarning.test.tsx">
import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { SessionTimeoutWarning } from '../../src/components/SessionTimeoutWarning';
import { useWalletContext } from '../../src/contexts/WalletContext';

// Mock wallet context
jest.mock('../../src/contexts/WalletContext', () => ({
  useWalletContext: jest.fn()
}));

// Constants from the component
const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
const WARNING_THRESHOLD = 5 * 60 * 1000; // 5 minutes

describe('SessionTimeoutWarning', () => {
  // Mock current time for consistent testing
  let mockNow = Date.now();
  const originalNow = Date.now;
  
  // Timer mocking
  let timerCallback: () => void;
  
  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();
    
    // Restore and re-mock Date.now for each test
    global.Date.now = originalNow;
    mockNow = originalNow();
    global.Date.now = jest.fn(() => mockNow);
    
    // Mock setInterval to capture the callback for testing
    jest.spyOn(global, 'setInterval').mockImplementation((callback: any, ms: number) => {
      timerCallback = callback;
      return 1 as any; // Timer ID
    });
    
    // Default context values
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: true,
      lastActivity: mockNow - (SESSION_TIMEOUT - WARNING_THRESHOLD - 1000), // Just before warning threshold
      resetActivityTimer: jest.fn()
    });
  });
  
  afterEach(() => {
    jest.useRealTimers();
    global.Date.now = originalNow;
  });
  
  it('does not show warning when user is active', () => {
    render(<SessionTimeoutWarning />);
    
    // Warning should not be visible
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });
  
  it('shows warning when approaching timeout threshold', () => {
    // Set activity time to be within warning threshold
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: true,
      lastActivity: mockNow - (SESSION_TIMEOUT - WARNING_THRESHOLD / 2), // Middle of warning period
      resetActivityTimer: jest.fn()
    });
    
    render(<SessionTimeoutWarning />);
    
    // Warning should now be visible
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
    
    // Call the timer callback directly to simulate interval trigger
    act(() => {
      timerCallback();
    });
    
    // Warning should be visible after timer callback
    expect(screen.getByText(/Session Timeout Warning/)).toBeInTheDocument();
    expect(screen.getByText(/Your wallet session will expire in/)).toBeInTheDocument();
  });
  
  it('does not show warning when not connected', () => {
    // Set connected to false
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: false,
      lastActivity: mockNow - (SESSION_TIMEOUT - WARNING_THRESHOLD / 2), // Middle of warning period
      resetActivityTimer: jest.fn()
    });
    
    render(<SessionTimeoutWarning />);
    
    // Call the timer callback
    act(() => {
      timerCallback();
    });
    
    // Warning should still not be visible
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });
  
  it('calls resetActivityTimer when "Stay Active" is clicked', () => {
    // Set activity time to be within warning threshold
    const mockResetActivityTimer = jest.fn();
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: true,
      lastActivity: mockNow - (SESSION_TIMEOUT - WARNING_THRESHOLD / 2), // Middle of warning period
      resetActivityTimer: mockResetActivityTimer
    });
    
    render(<SessionTimeoutWarning />);
    
    // Call the timer callback to show warning
    act(() => {
      timerCallback();
    });
    
    // Warning should be visible
    const stayActiveButton = screen.getByText('Stay Active');
    expect(stayActiveButton).toBeInTheDocument();
    
    // Click "Stay Active"
    fireEvent.click(stayActiveButton);
    
    // Should call resetActivityTimer
    expect(mockResetActivityTimer).toHaveBeenCalledTimes(1);
    
    // Warning should be dismissed
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });
  
  it('dismisses warning when "Dismiss" is clicked', () => {
    // Set activity time to be within warning threshold
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: true,
      lastActivity: mockNow - (SESSION_TIMEOUT - WARNING_THRESHOLD / 2), // Middle of warning period
      resetActivityTimer: jest.fn()
    });
    
    render(<SessionTimeoutWarning />);
    
    // Call the timer callback to show warning
    act(() => {
      timerCallback();
    });
    
    // Warning should be visible
    const dismissButton = screen.getByText('Dismiss');
    expect(dismissButton).toBeInTheDocument();
    
    // Click "Dismiss"
    fireEvent.click(dismissButton);
    
    // Warning should be dismissed
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });
  
  it('formats countdown timer correctly', () => {
    // Set activity time to exactly 2 minutes before timeout
    const timeRemaining = 2 * 60 * 1000; // 2 minutes
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: true,
      lastActivity: mockNow - (SESSION_TIMEOUT - timeRemaining),
      resetActivityTimer: jest.fn()
    });
    
    render(<SessionTimeoutWarning />);
    
    // Call the timer callback to show warning
    act(() => {
      timerCallback();
    });
    
    // Warning should show the formatted time remaining (2:00)
    expect(screen.getByText(/Your wallet session will expire in 2:00/)).toBeInTheDocument();
    
    // Advance time by 30 seconds
    mockNow += 30 * 1000;
    
    // Call the timer callback again to update the display
    act(() => {
      timerCallback();
    });
    
    // Warning should now show 1:30
    expect(screen.getByText(/Your wallet session will expire in 1:30/)).toBeInTheDocument();
  });
  
  it('hides warning when timeout period is over', () => {
    // Set activity time to be within warning threshold
    (useWalletContext as jest.Mock).mockReturnValue({
      connected: true,
      lastActivity: mockNow - (SESSION_TIMEOUT - WARNING_THRESHOLD / 2), // Middle of warning period
      resetActivityTimer: jest.fn()
    });
    
    render(<SessionTimeoutWarning />);
    
    // Call the timer callback to show warning
    act(() => {
      timerCallback();
    });
    
    // Warning should be visible
    expect(screen.getByText(/Session Timeout Warning/)).toBeInTheDocument();
    
    // Advance time beyond the timeout
    mockNow += SESSION_TIMEOUT;
    
    // Call the timer callback again
    act(() => {
      timerCallback();
    });
    
    // Warning should no longer be visible
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });
});
</file>

<file path="__tests__/components/TransactionHistory.test.tsx">
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { TransactionHistory } from '../../src/components/TransactionHistory';
import { useWalletContext } from '../../src/contexts/WalletContext';
import type { TransactionRecord } from '../../src/contexts/WalletContext';

// Mock wallet context
jest.mock('../../src/contexts/WalletContext', () => ({
  useWalletContext: jest.fn()
}));

// Mock Intl.RelativeTimeFormat for consistent testing
const mockFormatFn = jest.fn(value => `${Math.abs(value)} time units ago`);
global.Intl.RelativeTimeFormat = jest.fn().mockImplementation(() => ({
  format: mockFormatFn
})) as any;

describe('TransactionHistory', () => {
  // Sample transaction records for testing
  const mockTransactions: TransactionRecord[] = [
    {
      id: 'tx1',
      status: 'success',
      timestamp: Date.now() - 60000, // 1 minute ago
      type: 'Transfer',
      hash: '0xabc123def456'
    },
    {
      id: 'tx2',
      status: 'pending',
      timestamp: Date.now() - 300000, // 5 minutes ago
      type: 'Swap'
    },
    {
      id: 'tx3',
      status: 'error',
      timestamp: Date.now() - 3600000, // 1 hour ago
      type: 'Mint',
      message: 'Transaction failed: insufficient funds'
    },
    {
      id: 'tx4',
      status: 'success',
      timestamp: Date.now() - 86400000, // 1 day ago
      type: 'Stake',
      hash: '0x789012345abc'
    },
    {
      id: 'tx5',
      status: 'success',
      timestamp: Date.now() - 172800000, // 2 days ago
      type: 'Claim',
      hash: '0xdef456789abc'
    },
    {
      id: 'tx6',
      status: 'success',
      timestamp: Date.now() - 604800000, // 7 days ago
      type: 'Vote',
      hash: '0x123def789abc'
    }
  ];

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Default to empty transactions
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: []
    });
  });

  it('displays message when no transactions exist', () => {
    render(<TransactionHistory />);
    
    expect(screen.getByText('No transactions yet')).toBeInTheDocument();
  });

  it('displays transactions with correct status icons', () => {
    // Use a subset of mock transactions with different statuses
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: mockTransactions.slice(0, 3) // Success, Pending, Error
    });
    
    render(<TransactionHistory />);
    
    // Check transaction types are displayed
    expect(screen.getByText('Transfer')).toBeInTheDocument();
    expect(screen.getByText('Swap')).toBeInTheDocument();
    expect(screen.getByText('Mint')).toBeInTheDocument();
    
    // Check hash is displayed for the success transaction
    expect(screen.getByText(/0xabc123/)).toBeInTheDocument();
    
    // Check error message is displayed
    expect(screen.getByText(/insufficient funds/)).toBeInTheDocument();
  });

  it('limits transactions to maxItems by default', () => {
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: mockTransactions // All 6 transactions
    });
    
    // Default maxItems is 5
    render(<TransactionHistory />);
    
    // Should show the 5 most recent transactions
    expect(screen.getByText('Transfer')).toBeInTheDocument();
    expect(screen.getByText('Swap')).toBeInTheDocument();
    expect(screen.getByText('Mint')).toBeInTheDocument();
    expect(screen.getByText('Stake')).toBeInTheDocument();
    expect(screen.getByText('Claim')).toBeInTheDocument();
    
    // Should not show the oldest transaction
    expect(screen.queryByText('Vote')).not.toBeInTheDocument();
    
    // Should show a "Show all" button
    expect(screen.getByText('Show all (6)')).toBeInTheDocument();
  });

  it('expands to show all transactions when "Show all" is clicked', () => {
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: mockTransactions // All 6 transactions
    });
    
    render(<TransactionHistory />);
    
    // Initially, should not show the oldest transaction
    expect(screen.queryByText('Vote')).not.toBeInTheDocument();
    
    // Click "Show all"
    fireEvent.click(screen.getByText('Show all (6)'));
    
    // Now should show all transactions, including the oldest
    expect(screen.getByText('Vote')).toBeInTheDocument();
    
    // Button should now say "Show less"
    expect(screen.getByText('Show less')).toBeInTheDocument();
  });

  it('collapses back when "Show less" is clicked', () => {
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: mockTransactions // All 6 transactions
    });
    
    render(<TransactionHistory />);
    
    // Click "Show all"
    fireEvent.click(screen.getByText('Show all (6)'));
    
    // Now should show all transactions
    expect(screen.getByText('Vote')).toBeInTheDocument();
    
    // Click "Show less"
    fireEvent.click(screen.getByText('Show less'));
    
    // Should hide the oldest transaction again
    expect(screen.queryByText('Vote')).not.toBeInTheDocument();
  });

  it('respects custom maxItems prop', () => {
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: mockTransactions // All 6 transactions
    });
    
    // Set maxItems to 2
    render(<TransactionHistory maxItems={2} />);
    
    // Should only show the 2 most recent transactions
    expect(screen.getByText('Transfer')).toBeInTheDocument();
    expect(screen.getByText('Swap')).toBeInTheDocument();
    
    // Should not show the rest
    expect(screen.queryByText('Mint')).not.toBeInTheDocument();
    expect(screen.queryByText('Stake')).not.toBeInTheDocument();
    expect(screen.queryByText('Claim')).not.toBeInTheDocument();
    expect(screen.queryByText('Vote')).not.toBeInTheDocument();
  });

  it('uses Intl.RelativeTimeFormat for time formatting', () => {
    // Set up a single transaction for simplicity
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: [mockTransactions[0]] // Just the first transaction (1 minute ago)
    });
    
    render(<TransactionHistory />);
    
    // Check that Intl.RelativeTimeFormat was used
    expect(global.Intl.RelativeTimeFormat).toHaveBeenCalledWith('en', { numeric: 'auto' });
    
    // Check that format function was called with expected value
    // The first parameter should be negative, representing time in the past
    expect(mockFormatFn).toHaveBeenCalledWith(expect.any(Number), expect.any(String));
    
    // The result of the format function should be in the document
    expect(screen.getByText('1 time units ago')).toBeInTheDocument();
  });

  it('falls back to manual formatting when Intl.RelativeTimeFormat is not available', () => {
    // Temporarily remove Intl.RelativeTimeFormat
    const originalIntl = global.Intl;
    delete (global as any).Intl.RelativeTimeFormat;
    
    // Set up a single transaction for simplicity
    (useWalletContext as jest.Mock).mockReturnValue({
      transactions: [
        {
          ...mockTransactions[0],
          timestamp: Date.now() - 60000 // 1 minute ago
        }
      ]
    });
    
    render(<TransactionHistory />);
    
    // Should use fallback formatting
    expect(screen.getByText('1 minute ago')).toBeInTheDocument();
    
    // Restore Intl
    global.Intl = originalIntl;
  });
});
</file>

<file path="__tests__/components/WalletConnectButton.test.tsx">
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { WalletConnectButton } from '../../src/components/WalletConnectButton';
import { useWalletContext } from '../../src/contexts/WalletContext';
import { WalletError } from '../../src/lib/wallet-errors';
import { ClipboardError } from '../../src/lib/clipboard';

// Mock the entire wallet context
jest.mock('../../src/contexts/WalletContext', () => ({
  useWalletContext: jest.fn()
}));

// Mock the clipboard utilities
jest.mock('../../src/lib/clipboard', () => ({
  copyToClipboard: jest.fn(),
  getClipboardCapabilities: jest.fn(() => ({
    hasModernApi: true,
    hasLegacySupport: true
  })),
  ClipboardError: class MockClipboardError extends Error {
    constructor(message: string) {
      super(message);
      this.name = 'ClipboardError';
    }
  }
}));

// Mock the ErrorBoundary component
jest.mock('../../src/components/ErrorBoundary', () => ({
  ErrorBoundary: ({ children }: { children: React.ReactNode }) => <>{children}</>
}));

// Mock the WalletErrorModal and ClipboardErrorModal components
jest.mock('../../src/components/WalletErrorModal', () => ({
  WalletErrorModal: ({ error, onDismiss }: any) => (
    <div data-testid="wallet-error-modal">
      {error && <div data-testid="wallet-error-message">{error.message}</div>}
      <button data-testid="dismiss-wallet-error" onClick={onDismiss}>
        Dismiss
      </button>
    </div>
  )
}));

jest.mock('../../src/components/ClipboardErrorModal', () => ({
  ClipboardErrorModal: ({ error, onDismiss, onTryAlternative }: any) => (
    <div data-testid="clipboard-error-modal">
      {error && <div data-testid="clipboard-error-message">{error.message}</div>}
      <button data-testid="dismiss-clipboard-error" onClick={onDismiss}>
        Dismiss
      </button>
      <button data-testid="try-alternative" onClick={onTryAlternative}>
        Try Alternative
      </button>
    </div>
  )
}));

describe('WalletConnectButton', () => {
  // Default mock values for wallet context
  const mockDisconnect = jest.fn().mockResolvedValue(undefined);
  const mockConnect = jest.fn().mockResolvedValue(undefined);
  const mockSwitchNetwork = jest.fn().mockResolvedValue(undefined);
  const mockSetError = jest.fn();
  
  // Default props for disconnected state
  const disconnectedProps = {
    connected: false,
    connecting: false,
    disconnect: mockDisconnect,
    connect: mockConnect,
    address: null,
    name: null,
    chainId: null,
    error: null,
    setError: mockSetError,
    switchNetwork: mockSwitchNetwork,
    transactions: [],
    trackTransaction: jest.fn(),
    lastActivity: Date.now(),
    resetActivityTimer: jest.fn()
  };
  
  // Default props for connected state
  const connectedProps = {
    ...disconnectedProps,
    connected: true,
    address: '0x123456789abcdef123456789abcdef123456789a',
    name: 'Test Wallet',
    chainId: 'testnet'
  };
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Default to disconnected state
    (useWalletContext as jest.Mock).mockReturnValue(disconnectedProps);
  });
  
  it('renders connect button when disconnected', () => {
    render(<WalletConnectButton />);
    
    // Should show connect button
    const connectButton = screen.getByText('Connect Wallet');
    expect(connectButton).toBeInTheDocument();
    
    // Should not show disconnect button
    expect(screen.queryByText('Disconnect')).not.toBeInTheDocument();
  });
  
  it('renders connecting state correctly', () => {
    (useWalletContext as jest.Mock).mockReturnValue({
      ...disconnectedProps,
      connecting: true
    });
    
    render(<WalletConnectButton />);
    
    // Should show connecting message
    expect(screen.getByText('Connecting...')).toBeInTheDocument();
    
    // Should not show connect or disconnect buttons
    expect(screen.queryByText('Connect Wallet')).not.toBeInTheDocument();
    expect(screen.queryByText('Disconnect')).not.toBeInTheDocument();
  });
  
  it('renders connected state with wallet info', () => {
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    render(<WalletConnectButton />);
    
    // Should show wallet info
    expect(screen.getByText(/Test Wallet:/)).toBeInTheDocument();
    expect(screen.getByText(/0x1234/)).toBeInTheDocument(); // Truncated address
    
    // Should show network
    expect(screen.getByText('Testnet')).toBeInTheDocument();
    
    // Should show disconnect button
    expect(screen.getByText('Disconnect')).toBeInTheDocument();
    
    // Should show change network button
    expect(screen.getByText('(change)')).toBeInTheDocument();
  });
  
  it('connects wallet when connect button is clicked', async () => {
    render(<WalletConnectButton />);
    
    // Click connect button
    fireEvent.click(screen.getByText('Connect Wallet'));
    
    // Check if connect was called
    expect(mockConnect).toHaveBeenCalledTimes(1);
  });
  
  it('disconnects wallet when disconnect button is clicked', async () => {
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    render(<WalletConnectButton />);
    
    // Click disconnect button
    fireEvent.click(screen.getByText('Disconnect'));
    
    // Check if disconnect was called
    expect(mockDisconnect).toHaveBeenCalledTimes(1);
  });
  
  it('shows network options when change button is clicked', () => {
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    render(<WalletConnectButton />);
    
    // Initially, network options should not be visible
    expect(screen.queryByText('Mainnet')).not.toBeInTheDocument();
    
    // Click change button
    fireEvent.click(screen.getByText('(change)'));
    
    // Now network options should be visible
    expect(screen.getByText('Mainnet')).toBeInTheDocument();
    expect(screen.getByText('Testnet')).toBeInTheDocument();
    expect(screen.getByText('Devnet')).toBeInTheDocument();
  });
  
  it('triggers network switch when a network option is clicked', async () => {
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    render(<WalletConnectButton />);
    
    // Click change button to show options
    fireEvent.click(screen.getByText('(change)'));
    
    // Click a network option
    fireEvent.click(screen.getByText('Mainnet'));
    
    // Check if switchNetwork was called with correct parameter
    expect(mockSwitchNetwork).toHaveBeenCalledWith('mainnet');
  });
  
  it('shows error modal when there is an error', () => {
    const error = new WalletError('Test wallet error');
    
    (useWalletContext as jest.Mock).mockReturnValue({
      ...disconnectedProps,
      error
    });
    
    render(<WalletConnectButton />);
    
    // Error modal should be visible with error message
    expect(screen.getByTestId('wallet-error-modal')).toBeInTheDocument();
    expect(screen.getByTestId('wallet-error-message')).toHaveTextContent('Test wallet error');
  });
  
  it('clears error when dismiss is clicked', () => {
    const error = new WalletError('Test wallet error');
    
    (useWalletContext as jest.Mock).mockReturnValue({
      ...disconnectedProps,
      error
    });
    
    render(<WalletConnectButton />);
    
    // Click dismiss button
    fireEvent.click(screen.getByTestId('dismiss-wallet-error'));
    
    // Check if setError was called with null
    expect(mockSetError).toHaveBeenCalledWith(null);
  });
  
  it('handles copy functionality for connected wallet address', async () => {
    // Mock copyToClipboard to succeed
    const { copyToClipboard } = require('../../src/lib/clipboard');
    copyToClipboard.mockResolvedValue({ success: true });
    
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    render(<WalletConnectButton />);
    
    // Find and click copy button (it's an SVG icon)
    const copyButton = screen.getByTitle('Copy address');
    fireEvent.click(copyButton);
    
    // Should have called copyToClipboard with the address
    expect(copyToClipboard).toHaveBeenCalledWith(connectedProps.address);
    
    // Wait for success message
    await waitFor(() => {
      expect(screen.getByText('Address copied to clipboard!')).toBeInTheDocument();
    });
  });
  
  it('handles copy failures and shows error message', async () => {
    // Mock copyToClipboard to fail
    const { copyToClipboard } = require('../../src/lib/clipboard');
    copyToClipboard.mockResolvedValue({ 
      success: false, 
      error: new ClipboardError('Failed to copy to clipboard') 
    });
    
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    render(<WalletConnectButton />);
    
    // Find and click copy button
    const copyButton = screen.getByTitle('Copy address');
    fireEvent.click(copyButton);
    
    // Should show clipboard error modal
    await waitFor(() => {
      expect(screen.getByTestId('clipboard-error-modal')).toBeInTheDocument();
      expect(screen.getByTestId('clipboard-error-message')).toHaveTextContent('Failed to copy to clipboard');
    });
  });
  
  it('disables network switching buttons during switch', async () => {
    // Start with connected state
    (useWalletContext as jest.Mock).mockReturnValue(connectedProps);
    
    // Mock switchNetwork to delay resolution
    mockSwitchNetwork.mockImplementation(() => new Promise(resolve => {
      setTimeout(resolve, 100);
    }));
    
    render(<WalletConnectButton />);
    
    // Click change button to show options
    fireEvent.click(screen.getByText('(change)'));
    
    // Click a network option
    fireEvent.click(screen.getByText('Mainnet'));
    
    // Check that "switching..." text appears
    await waitFor(() => {
      // This will pass once the component re-renders with isNetworkSwitching=true
      // We can't directly check for it since it's a state inside the component
      expect(screen.queryByText('(change)')).not.toBeInTheDocument();
      expect(screen.getByText('(switching...)')).toBeInTheDocument();
    });
    
    // Network options should be hidden during switching
    expect(screen.queryByText('Mainnet')).not.toBeInTheDocument();
    
    // Disconnect button should be disabled during switching
    expect(screen.getByText('Disconnect')).toBeDisabled();
  });
});
</file>

<file path="__tests__/contexts/WalletContext.test.tsx">
import React from 'react';
import { render, screen, waitFor, act, renderHook } from '@testing-library/react';
import { AppWalletProvider, useWalletContext } from '../../src/contexts/WalletContext';
import { nanoid } from 'nanoid';

// Mock the nanoid package
jest.mock('nanoid', () => ({
  nanoid: jest.fn(() => 'mocked-nanoid-value')
}));

// Mock the Suiet wallet kit
jest.mock('@suiet/wallet-kit', () => {
  const mockWalletHook = {
    connected: false,
    connecting: false,
    account: null,
    wallet: null,
    networkId: null,
    select: jest.fn(),
    connect: jest.fn(),
    disconnect: jest.fn(),
    executeMoveCall: jest.fn(),
    executeSerializedMoveCall: jest.fn(),
    signMessage: jest.fn(),
    signAndExecuteTransaction: jest.fn(),
    signTransaction: jest.fn(),
    on: jest.fn(),
    verifySignedMessage: jest.fn()
  };

  return {
    useWallet: jest.fn(() => mockWalletHook),
    WalletProvider: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
    AllDefaultWallets: ['mock-wallet-1', 'mock-wallet-2']
  };
});

// Mock window.localStorage
const localStorageMock = (() => {
  let store: Record<string, string> = {};
  return {
    getItem: jest.fn((key: string) => store[key] || null),
    setItem: jest.fn((key: string, value: string) => {
      store[key] = value;
    }),
    removeItem: jest.fn((key: string) => {
      delete store[key];
    }),
    clear: jest.fn(() => {
      store = {};
    })
  };
})();
Object.defineProperty(window, 'localStorage', { value: localStorageMock });

// Create a wrapper for testing hooks with the provider
const wrapper = ({ children }: { children: React.ReactNode }) => (
  <AppWalletProvider>{children}</AppWalletProvider>
);

describe('WalletContext', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    localStorageMock.clear();
  });

  it('should provide initial values', () => {
    const { result } = renderHook(() => useWalletContext(), { wrapper });
    
    // Check initial values
    expect(result.current.connected).toBe(false);
    expect(result.current.connecting).toBe(false);
    expect(result.current.address).toBeNull();
    expect(result.current.chainId).toBeNull();
    expect(result.current.name).toBeNull();
    expect(result.current.error).toBeNull();
    expect(result.current.transactions).toEqual([]);
    expect(result.current.lastActivity).toBeDefined();
    
    // Check that functions are defined
    expect(typeof result.current.connect).toBe('function');
    expect(typeof result.current.disconnect).toBe('function');
    expect(typeof result.current.switchNetwork).toBe('function');
    expect(typeof result.current.trackTransaction).toBe('function');
    expect(typeof result.current.setError).toBe('function');
    expect(typeof result.current.resetActivityTimer).toBe('function');
  });

  it('should maintain stable function references between renders', async () => {
    const { result, rerender } = renderHook(() => useWalletContext(), { wrapper });
    
    // Capture initial function references
    const initialConnect = result.current.connect;
    const initialDisconnect = result.current.disconnect;
    const initialSwitchNetwork = result.current.switchNetwork;
    const initialTrackTransaction = result.current.trackTransaction;
    
    // Force a re-render
    rerender();
    
    // Check that function references haven't changed
    expect(result.current.connect).toBe(initialConnect);
    expect(result.current.disconnect).toBe(initialDisconnect);
    expect(result.current.switchNetwork).toBe(initialSwitchNetwork);
    expect(result.current.trackTransaction).toBe(initialTrackTransaction);
  });

  it('should track transactions correctly', async () => {
    const { result } = renderHook(() => useWalletContext(), { wrapper });
    
    // Mock transaction promise
    const mockTransaction = Promise.resolve({ digest: 'mock-tx-hash' });
    
    // Track the transaction
    let txResult;
    await act(async () => {
      txResult = await result.current.trackTransaction(mockTransaction, 'TestTransaction');
    });
    
    // Check result
    expect(txResult).toEqual({ digest: 'mock-tx-hash' });
    
    // Check transaction was added to history
    expect(result.current.transactions).toHaveLength(1);
    expect(result.current.transactions[0]).toEqual(expect.objectContaining({
      id: 'mocked-nanoid-value',
      status: 'success',
      type: 'TestTransaction',
      hash: 'mock-tx-hash'
    }));
  });
  
  it('should handle failed transactions', async () => {
    const { result } = renderHook(() => useWalletContext(), { wrapper });
    
    // Mock failed transaction promise
    const mockError = new Error('Transaction failed');
    const mockFailedTransaction = Promise.reject(mockError);
    
    // Track the transaction (expecting it to fail)
    await act(async () => {
      try {
        await result.current.trackTransaction(mockFailedTransaction, 'FailedTransaction');
      } catch (error) {
        // Expected to fail
      }
    });
    
    // Check transaction was added to history with error status
    expect(result.current.transactions).toHaveLength(1);
    expect(result.current.transactions[0]).toEqual(expect.objectContaining({
      id: 'mocked-nanoid-value',
      status: 'error',
      type: 'FailedTransaction',
      message: 'Transaction failed'
    }));
  });

  it('should handle error states', async () => {
    const { result } = renderHook(() => useWalletContext(), { wrapper });
    
    // Set an error
    act(() => {
      result.current.setError(new Error('Test error'));
    });
    
    // Check error state
    expect(result.current.error).toEqual(new Error('Test error'));
    
    // Clear error
    act(() => {
      result.current.setError(null);
    });
    
    // Check error cleared
    expect(result.current.error).toBeNull();
  });

  it('should update lastActivity on resetActivityTimer', async () => {
    const { result } = renderHook(() => useWalletContext(), { wrapper });
    
    // Get initial lastActivity value
    const initialLastActivity = result.current.lastActivity;
    
    // Wait a bit to ensure time difference
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Reset activity timer
    act(() => {
      result.current.resetActivityTimer();
    });
    
    // Check lastActivity was updated
    expect(result.current.lastActivity).not.toBe(initialLastActivity);
    expect(result.current.lastActivity).toBeGreaterThan(initialLastActivity);
  });
  
  // Tests for localStorage persistence would go here, but they require more complex mocking
  // of the useWallet hook from @suiet/wallet-kit
});
</file>

<file path="__tests__/hooks/useBlockchainEvents.test.tsx">
/**
 * Tests for blockchain event hooks
 * Ensures real-time event subscriptions work correctly
 */

import { renderHook, act, waitFor } from '@testing-library/react';

// Mock the hooks and types with proper interfaces
const mockUseBlockchainEvents = jest.fn();
const mockUseTodoEvents = jest.fn();
const mockUseTodoStateSync = jest.fn();

jest.mock('@/hooks/useBlockchainEvents', () => ({
  useBlockchainEvents: mockUseBlockchainEvents,
  useTodoEvents: mockUseTodoEvents,
  useTodoStateSync: mockUseTodoStateSync,
}));

jest.mock('@/lib/blockchain-events', () => ({
  BlockchainEventManager: jest.fn().mockImplementation(() => ({
    initialize: jest.fn(),
    subscribeToEvents: jest.fn(),
    unsubscribeAll: jest.fn(),
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    getConnectionState: jest.fn(),
    destroy: jest.fn(),
  }))
}));

jest.mock('@/lib/sui-client', () => ({
  Todo: jest.fn()
}));

// Define Todo interface for tests
interface Todo {
  id: string;
  title: string;
  completed: boolean;
  priority?: string;
  blockchainStored?: boolean;
  objectId?: string;
  owner?: string;
  createdAt?: number;
  completedAt?: number;
}

// Mock the blockchain event manager
jest.mock('@/lib/blockchain-events');
jest.mock('@/lib/sui-client');

const mockEventManager = {
  initialize: jest.fn(),
  subscribeToEvents: jest.fn(),
  unsubscribeAll: jest.fn(),
  addEventListener: jest.fn(),
  removeEventListener: jest.fn(),
  getConnectionState: jest.fn(),
  destroy: jest.fn(),
};

const mockGetEventManager = jest.fn(() => mockEventManager);

// Mock the wallet context
const mockWalletContext = {
  address: '0x123456789',
  connected: true,
  // ... other wallet properties
};

jest.mock('@/contexts/WalletContext', () => ({
  useWalletContext: () => mockWalletContext,
}));

describe('useBlockchainEvents', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockEventManager.getConnectionState.mockReturnValue({
      connected: false,
      connecting: false,
      error: null,
      lastReconnectAttempt: 0,
      reconnectAttempts: 0,
      subscriptionCount: 0,
    });
  });

  it('should initialize event manager on mount', async () => {
    mockEventManager.initialize.mockResolvedValue(undefined);
    mockEventManager.subscribeToEvents.mockResolvedValue(undefined);

    const { result } = renderHook(() => 
      useBlockchainEvents({ autoStart: true })
    );

    await waitFor(() => {
      expect(mockEventManager.initialize).toHaveBeenCalled();
    });
  });

  it('should start subscription when autoStart is true', async () => {
    mockEventManager.initialize.mockResolvedValue(undefined);
    mockEventManager.subscribeToEvents.mockResolvedValue(undefined);

    const { result } = renderHook(() => 
      useBlockchainEvents({ autoStart: true, owner: '0x123' })
    );

    await waitFor(() => {
      expect(mockEventManager.subscribeToEvents).toHaveBeenCalledWith('0x123');
    });
  });

  it('should provide connection state', () => {
    const mockState = {
      connected: true,
      connecting: false,
      error: null,
      lastReconnectAttempt: 0,
      reconnectAttempts: 0,
      subscriptionCount: 1,
    };

    mockEventManager.getConnectionState.mockReturnValue(mockState);

    const { result } = renderHook(() => useBlockchainEvents());

    expect(result.current.connectionState).toEqual(mockState);
    expect(result.current.isConnected).toBe(true);
    expect(result.current.isConnecting).toBe(false);
  });

  it('should handle start and stop subscription', async () => {
    mockEventManager.initialize.mockResolvedValue(undefined);
    mockEventManager.subscribeToEvents.mockResolvedValue(undefined);

    const { result } = renderHook(() => 
      useBlockchainEvents({ autoStart: false })
    );

    // Start subscription
    await act(async () => {
      await result.current.startSubscription();
    });

    expect(mockEventManager.subscribeToEvents).toHaveBeenCalled();

    // Stop subscription
    act(() => {
      result.current.stopSubscription();
    });

    expect(mockEventManager.unsubscribeAll).toHaveBeenCalled();
  });

  it('should restart subscription', async () => {
    mockEventManager.initialize.mockResolvedValue(undefined);
    mockEventManager.subscribeToEvents.mockResolvedValue(undefined);

    const { result } = renderHook(() => 
      useBlockchainEvents({ autoStart: false })
    );

    await act(async () => {
      await result.current.restartSubscription();
    });

    expect(mockEventManager.unsubscribeAll).toHaveBeenCalled();
    expect(mockEventManager.subscribeToEvents).toHaveBeenCalled();
  });

  it('should add event listeners', () => {
    const mockUnsubscribe = jest.fn();
    mockEventManager.addEventListener.mockReturnValue(mockUnsubscribe);

    const { result } = renderHook(() => useBlockchainEvents());

    const listener = jest.fn();
    const unsubscribe = result.current.addEventListener('created', listener);

    expect(mockEventManager.addEventListener).toHaveBeenCalledWith('created', listener);
    expect(typeof unsubscribe).toBe('function');
  });

  it('should cleanup on unmount', () => {
    const { unmount } = renderHook(() => useBlockchainEvents());

    unmount();

    expect(mockEventManager.destroy).toHaveBeenCalled();
  });
});

describe('useTodoEvents', () => {
  const mockTodoCreatedEvent = {
    type: 'created' as const,
    data: {
      todo_id: '1',
      title: 'Test Todo',
      owner: '0x123',
      timestamp: '1234567890',
    },
  };

  beforeEach(() => {
    jest.clearAllMocks();
    mockEventManager.getConnectionState.mockReturnValue({
      connected: true,
      connecting: false,
      error: null,
      lastReconnectAttempt: 0,
      reconnectAttempts: 0,
      subscriptionCount: 1,
    });
  });

  it('should track recent events', async () => {
    const mockUnsubscribe = jest.fn();
    mockEventManager.addEventListener.mockImplementation((eventType, listener) => {
      // Simulate event after subscription
      setTimeout(() => listener(mockTodoCreatedEvent), 10);
      return mockUnsubscribe;
    });

    const { result } = renderHook(() => useTodoEvents({ autoStart: true }));

    await waitFor(() => {
      expect(result.current.recentEvents).toHaveLength(1);
      expect(result.current.recentEvents[0]).toEqual(mockTodoCreatedEvent);
    });
  });

  it('should call event handlers', async () => {
    const onTodoCreated = jest.fn();
    const mockUnsubscribe = jest.fn();

    mockEventManager.addEventListener.mockImplementation((eventType, listener) => {
      // Simulate event after subscription
      setTimeout(() => listener(mockTodoCreatedEvent), 10);
      return mockUnsubscribe;
    });

    renderHook(() => 
      useTodoEvents({ 
        autoStart: true,
        onTodoCreated,
      })
    );

    await waitFor(() => {
      expect(onTodoCreated).toHaveBeenCalledWith({
        id: '1',
        title: 'Test Todo',
        blockchainStored: true,
        objectId: '1',
        owner: '0x123',
        createdAt: 1234567890,
      });
    });
  });

  it('should clear recent events', async () => {
    const mockUnsubscribe = jest.fn();
    mockEventManager.addEventListener.mockImplementation((eventType, listener) => {
      setTimeout(() => listener(mockTodoCreatedEvent), 10);
      return mockUnsubscribe;
    });

    const { result } = renderHook(() => useTodoEvents({ autoStart: true }));

    await waitFor(() => {
      expect(result.current.recentEvents).toHaveLength(1);
    });

    act(() => {
      result.current.clearRecentEvents();
    });

    expect(result.current.recentEvents).toHaveLength(0);
  });
});

describe('useTodoStateSync', () => {
  const initialTodos: Todo[] = [
    {
      id: '1',
      title: 'Initial Todo',
      completed: false,
      priority: 'medium',
      blockchainStored: false,
    },
  ];

  const mockTodoCreatedEvent = {
    type: 'created' as const,
    data: {
      todo_id: '2',
      title: 'New Todo',
      owner: '0x123',
      timestamp: '1234567890',
    },
  };

  beforeEach(() => {
    jest.clearAllMocks();
    mockEventManager.getConnectionState.mockReturnValue({
      connected: true,
      connecting: false,
      error: null,
      lastReconnectAttempt: 0,
      reconnectAttempts: 0,
      subscriptionCount: 1,
    });
  });

  it('should initialize with provided todos', () => {
    const onTodoChange = jest.fn();
    const { result } = renderHook(() => 
      useTodoStateSync({
        todos: initialTodos,
        onTodoChange,
        autoStart: false,
      })
    );

    expect(result.current.syncedTodos).toEqual(initialTodos);
  });

  it('should add new todos from blockchain events', async () => {
    const onTodoChange = jest.fn();
    const mockUnsubscribe = jest.fn();

    mockEventManager.addEventListener.mockImplementation((eventType, listener) => {
      setTimeout(() => listener(mockTodoCreatedEvent), 10);
      return mockUnsubscribe;
    });

    const { result } = renderHook(() => 
      useTodoStateSync({
        todos: initialTodos,
        onTodoChange,
        autoStart: true,
      })
    );

    await waitFor(() => {
      expect(result.current.syncedTodos).toHaveLength(2);
      expect(result.current.syncedTodos[1]).toMatchObject({
        id: '2',
        title: 'New Todo',
        blockchainStored: true,
      });
    });

    expect(onTodoChange).toHaveBeenCalled();
  });

  it('should update existing todos from blockchain events', async () => {
    const onTodoChange = jest.fn();
    const mockUnsubscribe = jest.fn();

    const mockTodoCompletedEvent = {
      type: 'completed' as const,
      data: {
        todo_id: '1',
        timestamp: '1234567890',
      },
    };

    mockEventManager.addEventListener.mockImplementation((eventType, listener) => {
      setTimeout(() => listener(mockTodoCompletedEvent), 10);
      return mockUnsubscribe;
    });

    const { result } = renderHook(() => 
      useTodoStateSync({
        todos: initialTodos,
        onTodoChange,
        autoStart: true,
      })
    );

    await waitFor(() => {
      const updatedTodo = result.current.syncedTodos.find(t => t.id === '1');
      expect(updatedTodo?.completed).toBe(true);
      expect(updatedTodo?.completedAt).toBe(1234567890);
    });

    expect(onTodoChange).toHaveBeenCalled();
  });

  it('should remove todos from blockchain delete events', async () => {
    const onTodoChange = jest.fn();
    const mockUnsubscribe = jest.fn();

    const mockTodoDeletedEvent = {
      type: 'deleted' as const,
      data: {
        todo_id: '1',
        timestamp: '1234567890',
      },
    };

    mockEventManager.addEventListener.mockImplementation((eventType, listener) => {
      setTimeout(() => listener(mockTodoDeletedEvent), 10);
      return mockUnsubscribe;
    });

    const { result } = renderHook(() => 
      useTodoStateSync({
        todos: initialTodos,
        onTodoChange,
        autoStart: true,
      })
    );

    await waitFor(() => {
      expect(result.current.syncedTodos).toHaveLength(0);
    });

    expect(onTodoChange).toHaveBeenCalled();
  });

  it('should update when external todos change', () => {
    const onTodoChange = jest.fn();
    const newTodos: Todo[] = [
      ...initialTodos,
      {
        id: '2',
        title: 'Another Todo',
        completed: false,
        priority: 'high',
        blockchainStored: false,
      },
    ];

    const { result, rerender } = renderHook(
      ({ todos }) => useTodoStateSync({
        todos,
        onTodoChange,
        autoStart: false,
      }),
      { initialProps: { todos: initialTodos } }
    );

    expect(result.current.syncedTodos).toEqual(initialTodos);

    rerender({ todos: newTodos });

    expect(result.current.syncedTodos).toEqual(newTodos);
  });
});

describe('Event error handling', () => {
  it('should handle connection errors', async () => {
    const connectionError = new Error('Connection failed');
    mockEventManager.initialize.mockRejectedValue(connectionError);

    const { result } = renderHook(() => 
      useBlockchainEvents({ autoStart: true })
    );

    await waitFor(() => {
      expect(result.current.error).toEqual(connectionError);
    });
  });

  it('should handle subscription errors', async () => {
    mockEventManager.initialize.mockResolvedValue(undefined);
    const subscriptionError = new Error('Subscription failed');
    mockEventManager.subscribeToEvents.mockRejectedValue(subscriptionError);

    const { result } = renderHook(() => 
      useBlockchainEvents({ autoStart: true })
    );

    await waitFor(() => {
      expect(result.current.error).toEqual(subscriptionError);
    });
  });
});

describe('Event manager lifecycle', () => {
  it('should not create multiple managers', () => {
    const { rerender } = renderHook(() => useBlockchainEvents());
    
    rerender();
    
    // Event manager should be singleton
    expect(mockGetEventManager).toHaveBeenCalledTimes(1);
  });

  it('should cleanup subscriptions on component unmount', () => {
    const { unmount } = renderHook(() => useBlockchainEvents({ autoStart: true }));

    unmount();

    expect(mockEventManager.destroy).toHaveBeenCalled();
  });
});
</file>

<file path="__tests__/hooks/useInactivityTimer.test.tsx">
import { renderHook, act } from '@testing-library/react';
import { useInactivityTimer } from '../../src/contexts/WalletContext'; // Import the hook from actual file

// Mock the Date.now function
const mockDateNow = jest.fn(() => 1621234567890); // Fixed timestamp for testing
global.Date.now = mockDateNow;

describe('useInactivityTimer', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();
    mockDateNow.mockReturnValue(1621234567890); // Reset timestamp
    
    // Mock event listeners
    window.addEventListener = jest.fn();
    window.removeEventListener = jest.fn();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it('should initialize with current timestamp', () => {
    const onTimeout = jest.fn();
    const { result } = renderHook(() => useInactivityTimer(true, onTimeout));
    
    expect(result.current.lastActivity).toBe(1621234567890);
  });

  it('should not set up event listeners when not connected', () => {
    const onTimeout = jest.fn();
    renderHook(() => useInactivityTimer(false, onTimeout));
    
    expect(window.addEventListener).not.toHaveBeenCalled();
  });

  it('should set up event listeners when connected', () => {
    const onTimeout = jest.fn();
    renderHook(() => useInactivityTimer(true, onTimeout));
    
    // Check for 3 event listeners: mousedown, keydown, touchstart
    expect(window.addEventListener).toHaveBeenCalledTimes(3);
    expect(window.addEventListener).toHaveBeenCalledWith('mousedown', expect.any(Function));
    expect(window.addEventListener).toHaveBeenCalledWith('keydown', expect.any(Function));
    expect(window.addEventListener).toHaveBeenCalledWith('touchstart', expect.any(Function));
  });

  it('should reset lastActivity when resetActivityTimer is called', () => {
    const onTimeout = jest.fn();
    const { result } = renderHook(() => useInactivityTimer(true, onTimeout));
    
    // Update the mocked Date.now return value
    mockDateNow.mockReturnValue(1621234667890); // 100s later
    
    // Call resetActivityTimer
    act(() => {
      result.current.resetActivityTimer();
    });
    
    // Check if lastActivity was updated
    expect(result.current.lastActivity).toBe(1621234667890);
  });

  it('should call onTimeout when session times out', () => {
    const onTimeout = jest.fn();
    renderHook(() => useInactivityTimer(true, onTimeout));
    
    // Move time forward by less than timeout (29 min)
    mockDateNow.mockReturnValue(1621234567890 + 29 * 60 * 1000); 
    jest.advanceTimersByTime(60000); // Check every minute
    
    // onTimeout should not be called yet
    expect(onTimeout).not.toHaveBeenCalled();
    
    // Move time forward beyond timeout (31 min)
    mockDateNow.mockReturnValue(1621234567890 + 31 * 60 * 1000);
    jest.advanceTimersByTime(60000); // Another minute
    
    // onTimeout should be called
    expect(onTimeout).toHaveBeenCalledTimes(1);
  });

  it('should clean up event listeners on unmount', () => {
    const onTimeout = jest.fn();
    const { unmount } = renderHook(() => useInactivityTimer(true, onTimeout));
    
    unmount();
    
    // Check for 3 event listeners being removed
    expect(window.removeEventListener).toHaveBeenCalledTimes(3);
    expect(window.removeEventListener).toHaveBeenCalledWith('mousedown', expect.any(Function));
    expect(window.removeEventListener).toHaveBeenCalledWith('keydown', expect.any(Function));
    expect(window.removeEventListener).toHaveBeenCalledWith('touchstart', expect.any(Function));
  });

  it('should reset timer on user activity', () => {
    const onTimeout = jest.fn();
    renderHook(() => useInactivityTimer(true, onTimeout));
    
    // Capture the callback function registered with the event listener
    const handleActivity = (window.addEventListener as jest.Mock).mock.calls[0][1];
    
    // Mock Date.now to return a new value
    mockDateNow.mockReturnValue(1621234667890); // 100s later
    
    // Simulate user activity
    act(() => {
      handleActivity();
    });
    
    // Move time forward to what would have been a timeout from the original time
    mockDateNow.mockReturnValue(1621234567890 + 31 * 60 * 1000);
    jest.advanceTimersByTime(60000);
    
    // onTimeout should not be called because we reset the timer
    expect(onTimeout).not.toHaveBeenCalled();
    
    // But if we move time forward from the new activity time, it should trigger
    mockDateNow.mockReturnValue(1621234667890 + 31 * 60 * 1000);
    jest.advanceTimersByTime(60000);
    
    // Now onTimeout should be called
    expect(onTimeout).toHaveBeenCalledTimes(1);
  });
});
</file>

<file path="__tests__/integration/WalletIntegration.test.tsx">
import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { AppWalletProvider } from '../../src/contexts/WalletContext';
import { WalletConnectButton } from '../../src/components/WalletConnectButton';
import { TransactionHistory } from '../../src/components/TransactionHistory';
import { SessionTimeoutWarning } from '../../src/components/SessionTimeoutWarning';

// Mock the suiet wallet kit
jest.mock('@suiet/wallet-kit', () => {
  // We'll use this object to control the mock wallet behavior during tests
  const mockWalletState = {
    connected: false,
    connecting: false,
    account: null,
    wallet: null,
    networkId: null,
    error: null,
    
    // Methods that can be called to modify the mock state
    setConnected(value: boolean) {
      this.connected = value;
      if (value) {
        this.account = {
          address: '0x123456789abcdef123456789abcdef123456789a'
        };
        this.wallet = {
          name: 'Mock Sui Wallet',
          switchChain: jest.fn().mockImplementation(({ chainId }) => {
            mockWalletState.networkId = chainId;
            return Promise.resolve();
          })
        };
        this.networkId = 'testnet';
      } else {
        this.account = null;
        this.wallet = null;
        this.networkId = null;
      }
    },
    
    setConnecting(value: boolean) {
      this.connecting = value;
    },
    
    // Mock implementation will call these functions after a delay
    simulateConnect() {
      return new Promise<void>((resolve) => {
        this.setConnecting(true);
        
        setTimeout(() => {
          this.setConnecting(false);
          this.setConnected(true);
          resolve();
        }, 100);
      });
    },
    
    simulateDisconnect() {
      return new Promise<void>((resolve) => {
        setTimeout(() => {
          this.setConnected(false);
          resolve();
        }, 100);
      });
    }
  };
  
  // The exported hook that our components will call
  const useWallet = jest.fn(() => ({
    connected: mockWalletState.connected,
    connecting: mockWalletState.connecting,
    account: mockWalletState.account,
    wallet: mockWalletState.wallet,
    networkId: mockWalletState.networkId,
    error: mockWalletState.error,
    
    // Function implementations
    select: jest.fn(),
    connect: jest.fn().mockImplementation(() => mockWalletState.simulateConnect()),
    disconnect: jest.fn().mockImplementation(() => mockWalletState.simulateDisconnect()),
    on: jest.fn()
  }));
  
  return {
    useWallet,
    WalletProvider: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
    AllDefaultWallets: ['mock-wallet-1', 'mock-wallet-2'],
    
    // Expose the mock state for test manipulation
    __mockWalletState: mockWalletState
  };
});

// Mock nanoid for consistent transaction IDs
jest.mock('nanoid', () => ({
  nanoid: jest.fn(() => 'mocked-nanoid-value')
}));

// Test the entire wallet flow with multiple components
describe('Wallet Integration', () => {
  // Helper to get the mock wallet state
  const getMockWalletState = () => {
    return require('@suiet/wallet-kit').__mockWalletState;
  };
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Reset mock wallet to initial state
    const mockWalletState = getMockWalletState();
    mockWalletState.setConnected(false);
    mockWalletState.setConnecting(false);
    mockWalletState.error = null;
    
    // Mock Date.now for consistent testing
    jest.spyOn(Date, 'now').mockImplementation(() => 1621234567890);
    
    // Mock timers
    jest.useFakeTimers();
  });
  
  afterEach(() => {
    jest.useRealTimers();
  });

  // Test App component to wrap everything
  const TestApp = () => (
    <AppWalletProvider>
      <div>
        <WalletConnectButton />
        <TransactionHistory />
        <SessionTimeoutWarning />
      </div>
    </AppWalletProvider>
  );

  it('shows connect button when wallet is not connected', () => {
    render(<TestApp />);
    
    // Should show connect button
    expect(screen.getByText('Connect Wallet')).toBeInTheDocument();
    
    // Should not show transaction history (no content)
    expect(screen.getByText('No transactions yet')).toBeInTheDocument();
    
    // Should not show timeout warning
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });

  it('shows connecting UI during connection', async () => {
    render(<TestApp />);
    
    // Click connect
    fireEvent.click(screen.getByText('Connect Wallet'));
    
    // Should show connecting state
    expect(screen.getByText('Connecting...')).toBeInTheDocument();
    
    // Wait for connection to complete
    await act(async () => {
      jest.advanceTimersByTime(100);
    });
  });

  it('shows wallet info after successful connection', async () => {
    render(<TestApp />);
    
    // Click connect
    fireEvent.click(screen.getByText('Connect Wallet'));
    
    // Wait for connection to complete
    await act(async () => {
      jest.advanceTimersByTime(100);
    });
    
    // Should show wallet info
    expect(screen.getByText(/Mock Sui Wallet:/)).toBeInTheDocument();
    expect(screen.getByText(/Testnet/)).toBeInTheDocument();
    
    // Should show disconnect button
    expect(screen.getByText('Disconnect')).toBeInTheDocument();
  });

  it('changes network when network is selected', async () => {
    render(<TestApp />);
    
    // Connect wallet
    fireEvent.click(screen.getByText('Connect Wallet'));
    
    // Wait for connection to complete
    await act(async () => {
      jest.advanceTimersByTime(100);
    });
    
    // Click change network
    fireEvent.click(screen.getByText('(change)'));
    
    // Should show network options
    expect(screen.getByText('Mainnet')).toBeInTheDocument();
    
    // Select a different network
    fireEvent.click(screen.getByText('Mainnet'));
    
    // Should show switching indicator
    expect(screen.getByText('(switching...)')).toBeInTheDocument();
    
    // Mock the switchChain completion
    await act(async () => {
      // The network switching is handled by the mock implementation
      jest.advanceTimersByTime(100);
    });
    
    // Check if network was updated in the UI
    expect(screen.getByText('Mainnet')).toBeInTheDocument();
  });

  it('adds transactions to history when using trackTransaction', async () => {
    // This requires access to context directly, which isn't easy in this integration test
    // Typically would be separate component that uses the useWalletContext hook
    // For now, we'll skip actual transaction creation in this test
  });

  it('disconnects wallet when disconnect button is clicked', async () => {
    render(<TestApp />);
    
    // Connect wallet
    fireEvent.click(screen.getByText('Connect Wallet'));
    
    // Wait for connection to complete
    await act(async () => {
      jest.advanceTimersByTime(100);
    });
    
    // Should show wallet info
    expect(screen.getByText(/Mock Sui Wallet:/)).toBeInTheDocument();
    
    // Click disconnect
    fireEvent.click(screen.getByText('Disconnect'));
    
    // Wait for disconnection to complete
    await act(async () => {
      jest.advanceTimersByTime(100);
    });
    
    // Should show connect button again
    expect(screen.getByText('Connect Wallet')).toBeInTheDocument();
  });

  it('shows timeout warning when approaching session timeout', async () => {
    render(<TestApp />);
    
    // Connect wallet
    fireEvent.click(screen.getByText('Connect Wallet'));
    
    // Wait for connection to complete
    await act(async () => {
      jest.advanceTimersByTime(100);
    });
    
    // Set lastActivity to approach warning threshold
    const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
    const WARNING_THRESHOLD = 5 * 60 * 1000; // 5 minutes
    
    // Modify Date.now to simulate time passing to within warning period
    jest.spyOn(Date, 'now').mockImplementation(() => 
      1621234567890 + (SESSION_TIMEOUT - WARNING_THRESHOLD + 1000)
    );
    
    // Trigger the check interval
    await act(async () => {
      jest.advanceTimersByTime(30000); // 30 seconds (interval check)
    });
    
    // Warning should be visible
    expect(screen.getByText(/Session Timeout Warning/)).toBeInTheDocument();
    
    // Click "Stay Active"
    fireEvent.click(screen.getByText('Stay Active'));
    
    // Warning should be dismissed
    expect(screen.queryByText(/Session Timeout Warning/)).not.toBeInTheDocument();
  });
});
</file>

<file path="docs/FIXING_BROWSER_ERRORS.md">
# Fixing Browser Context and Security Errors

This guide addresses common browser security and context errors that may occur when running the Walrus Todo frontend application.

## Common Errors and Solutions

### 1. Storage Access Errors

**Error**: `Access to storage is not allowed from this context`

**Causes**:
- Application is running in an iframe with restricted permissions
- Browser privacy settings blocking third-party storage
- Application served over HTTP instead of HTTPS
- Content Security Policy restrictions

**Solutions**:

1. **Use HTTPS locally**:
   ```bash
   # Create a local certificate
   openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes
   
   # Update package.json to use HTTPS
   "scripts": {
     "dev": "next dev --experimental-https",
     "dev:https": "next dev --experimental-https-key key.pem --experimental-https-cert cert.pem"
   }
   ```

2. **Configure browser settings**:
   - Chrome: Settings  Privacy and security  Cookies  Allow all cookies
   - Firefox: Settings  Privacy & Security  Cookies and Site Data  Accept all cookies
   - Safari: Preferences  Privacy  Uncheck "Prevent cross-site tracking"

3. **Use the storage fallback**:
   The application now includes an in-memory fallback when localStorage is unavailable.

### 2. Wallet Connection Errors

**Error**: `WalletNotSelectedError`

**Causes**:
- Wallet extension not installed
- Wallet not initialized before connection attempt
- Page loaded before wallet injection

**Solutions**:

1. **Install required wallet extensions**:
   - For Sui: Install Sui Wallet, Suiet, or Martian
   - For Solana: Install Phantom wallet

2. **Wait for wallet initialization**:
   The application now includes proper wallet detection and error messages.

3. **Refresh the page**:
   Sometimes wallet extensions need a page refresh to properly inject.

### 3. Clipboard Access Errors

**Error**: `Copy to clipboard is not supported in this browser`

**Causes**:
- Non-secure context (HTTP instead of HTTPS)
- Browser doesn't support clipboard API
- Permissions not granted

**Solutions**:

1. **Use HTTPS**:
   Clipboard API requires a secure context (HTTPS or localhost)

2. **Grant permissions**:
   When prompted, allow clipboard access

3. **Use fallback method**:
   The application now includes a fallback clipboard method for older browsers

## Recommended Development Setup

### 1. Using Local HTTPS

```bash
# Install mkcert for local certificates
brew install mkcert # macOS
mkcert -install

# Create certificates
cd packages/frontend-v2
mkcert localhost 127.0.0.1 ::1

# Update next.config.js
module.exports = {
  server: {
    https: {
      key: fs.readFileSync('./localhost-key.pem'),
      cert: fs.readFileSync('./localhost.pem'),
    },
  },
}
```

### 2. Using Environment Variables

Create a `.env.local` file:

```bash
# Copy example configuration
cp .env.local.example .env.local

# Update values as needed
NEXT_PUBLIC_ENABLE_WALLET_WARNING=true
NEXT_PUBLIC_ENABLE_STORAGE_FALLBACK=true
```

### 3. Using Docker for HTTPS

```dockerfile
# Dockerfile
FROM node:18-alpine
WORKDIR /app
COPY . .
RUN npm install
RUN npm run build

# Use nginx for HTTPS
FROM nginx:alpine
COPY --from=0 /app/.next/static /usr/share/nginx/html/_next/static
COPY nginx.conf /etc/nginx/nginx.conf
COPY cert.pem /etc/nginx/cert.pem
COPY key.pem /etc/nginx/key.pem
```

## Testing in Different Contexts

### 1. Direct Browser Access
```bash
# HTTP (may have restrictions)
http://localhost:3001

# HTTPS (recommended)
https://localhost:3001
```

### 2. Iframe Testing
```html
<!-- test-iframe.html -->
<iframe src="http://localhost:3001" 
        allow="clipboard-read; clipboard-write; storage-access"
        width="100%" 
        height="600">
</iframe>
```

### 3. Cross-Origin Testing
```javascript
// Set CORS headers in next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: '/api/:path*',
        headers: [
          { key: 'Access-Control-Allow-Origin', value: '*' },
          { key: 'Access-Control-Allow-Methods', value: 'GET,POST,PUT,DELETE' },
        ],
      },
    ]
  },
}
```

## Browser-Specific Solutions

### Chrome/Edge
- Enable clipboard: `chrome://flags/#clipboard-unsanitized-content`
- Allow storage: `chrome://settings/content/cookies`

### Firefox
- Enable clipboard: `about:config`  `dom.allow_cut_copy`  true
- Allow storage: `about:preferences#privacy`

### Safari
- Enable clipboard: Preferences  Websites  Use of clipboard
- Allow storage: Preferences  Privacy  Website tracking

## Production Deployment

For production, ensure:

1. **Use HTTPS**: Deploy to a service that provides HTTPS by default (Vercel, Netlify, etc.)
2. **Set proper headers**: Configure Content Security Policy and CORS headers
3. **Handle errors gracefully**: Implement proper error boundaries and fallbacks
4. **Test across browsers**: Verify functionality in all target browsers

## Environment Detection

The application now includes automatic detection of:
- Storage availability
- Secure context
- Iframe context
- Clipboard support

A warning banner will appear when running in a restricted context, providing guidance to users.

## Troubleshooting

1. **Check browser console**: Look for specific error messages
2. **Verify wallet installation**: Ensure wallet extensions are properly installed
3. **Test in incognito mode**: Rule out extension conflicts
4. **Check network tab**: Verify all resources load correctly
5. **Use browser developer tools**: Check storage, cookies, and permissions

## Additional Resources

- [MDN: Secure Contexts](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts)
- [Chrome Storage Access API](https://developers.google.com/web/updates/2020/07/storage-access-api)
- [Clipboard API](https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API)
- [Wallet Adapter Documentation](https://github.com/solana-labs/wallet-adapter)
</file>

<file path="docs/FRONTEND_FIXES.md">
# Frontend Fixes Made

## Date: May 19, 2025

## Issue: Wallet Integration Problems

The frontend was encountering issues with the wallet integration due to conflicting implementations:

1. **Multiple wallet context implementations**:
   - `lib/walletContext.tsx` - Complex implementation with StashedWalletAdapter
   - `contexts/WalletContext.tsx` - Implementation using Suiet wallet integration
   - `contexts/SimpleWalletContext.tsx` - Simplified implementation for development

2. **StashedWalletAdapter missing**:
   - The `lib/walletContext.tsx` file was trying to use a StashedWalletAdapter that was no longer available
   - This caused import errors when trying to run the application

## Solutions Applied:

1. **Enable Simple Wallet Context**:
   - Ran the `enable-simple-wallet.sh` script to switch to the simplified wallet implementation
   - This fixed the import issues by using a simple wallet implementation that doesn't require external wallet adapters

2. **Fixed Manual Import Updates**:
   - The script didn't fully update all imports, so manual fixes were needed:
     - Updated import in `src/app/layout.tsx` to import SimpleWalletProvider
     - Updated import in `src/components/WalletConnectButton.tsx` to use the SimpleWalletContext

3. **Package.json Script Fix**:
   - Fixed the `dev:clean` script which was using yarn instead of pnpm:
     - Changed `"dev:clean": "yarn clean && next dev"` to `"dev:clean": "pnpm run clean && next dev"`

## Verification:

The application now successfully builds and runs in development mode. The wallet integration works correctly with the simplified implementation, allowing development to continue without external wallet dependencies.

## Implementation Details:

The `SimpleWalletContext` provides:
- A mock wallet address (0x7a40eb2bb8dcf8abe508e3f0dc49bade2935bd8c)
- Connect/disconnect functionality
- Network switching (mainnet, testnet, devnet)
- Mock transaction tracking
- Proper error handling

This implementation is perfect for development purposes, and when ready for production, the more complex wallet integrations can be re-enabled.
</file>

<file path="public/config/testnet.json">
{
  "network": "testnet",
  "rpcUrl": "https://fullnode.testnet.sui.io",
  "walrus": {
    "publisherUrl": "https://publisher.walrus-testnet.walrus.space",
    "aggregatorUrl": "https://aggregator.walrus-testnet.walrus.space"
  },
  "deployment": {
    "packageId": "0xd6f97fc85796ee23adf60504a620631a0eea6947f85c4ca51e02245e9a4b57d7",
    "upgradeCapId": "0x380082348e8c41fe52101bbf51758e2d700bbde96f3df516b37139ad6cb93563",
    "deployerAddress": "0xca793690985183dc8e2180fd059d76f3b0644f5c2ecd3b01cdebe7d40b0cca39",
    "timestamp": "2025-05-27T02:53:00Z",
    "gasUsed": "129773480",
    "transactionHash": "C3HkWwACTjfQi9i7focqoZhsZpXtH61JBJVahaxa6SbH"
  },
  "features": {
    "aiIntegration": false,
    "batchOperations": true,
    "storageOptimization": true,
    "realTimeUpdates": true
  },
  "environment": {
    "mode": "production",
    "debug": false,
    "apiEndpoint": "https://fullnode.testnet.sui.io"
  }
}
</file>

<file path="public/images/ocean-wave.svg">
<?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1440 320">
  <defs>
    <linearGradient id="oceanGradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:#0077b6;stop-opacity:0.7" />
      <stop offset="50%" style="stop-color:#48bfe3;stop-opacity:0.7" />
      <stop offset="100%" style="stop-color:#90e0ef;stop-opacity:0.7" />
    </linearGradient>
  </defs>
  <path fill="url(#oceanGradient)" fill-opacity="1" d="M0,192L48,181.3C96,171,192,149,288,154.7C384,160,480,192,576,202.7C672,213,768,203,864,181.3C960,160,1056,128,1152,138.7C1248,149,1344,203,1392,229.3L1440,256L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"></path>
</svg>
</file>

<file path="scripts/start-with-available-port.js">
#!/usr/bin/env node

const { spawn } = require('child_process');
const getPort = require('get-port').default;

async function startWithAvailablePort() {
  try {
    // Find an available port starting from 3000
    const port = await getPort({ port: [3000, 3001, 3002, 3003, 3004, 3005] });
    
    console.log(` Starting Next.js server on available port: ${port}`);
    
    // Set the PORT environment variable
    process.env.PORT = port.toString();
    
    // Resolve the path to Next.js CLI
    const nextPath = require.resolve('next/dist/bin/next');
    
    // Start the Next.js server with the available port
    const nextProcess = spawn(process.execPath, [nextPath, process.argv[2] || 'dev'], {
      stdio: 'inherit',
      env: { ...process.env, PORT: port.toString() }
    });
    
    // Handle process termination
    process.on('SIGINT', () => {
      console.log('\n Shutting down server...');
      nextProcess.kill('SIGINT');
      process.exit(0);
    });
    
    process.on('SIGTERM', () => {
      nextProcess.kill('SIGTERM');
      process.exit(0);
    });
    
    nextProcess.on('close', (code) => {
      process.exit(code);
    });
    
  } catch (error) {
    console.error(' Failed to start server:', error.message);
    process.exit(1);
  }
}

startWithAvailablePort();
</file>

<file path="src/app/about/page.tsx">
export default function About() {
  return (
    <div className='min-h-screen bg-gradient-to-br from-ocean-foam to-ocean-light p-4'>
      <div className='max-w-4xl mx-auto'>
        <div className='glass-card p-8 rounded-2xl'>
          <h1 className='text-4xl font-bold text-ocean-deep mb-6'>
            About Walrus Todo
          </h1>

          <div className='prose prose-ocean max-w-none'>
            <p className='text-lg text-ocean-deep mb-4'>
              Walrus Todo is a next-generation Web3 task management application
              that combines the power of blockchain technology with beautiful,
              intuitive design.
            </p>

            <h2 className='text-2xl font-semibold text-ocean-deep mt-8 mb-4'>
              Features
            </h2>
            <ul className='list-disc list-inside text-ocean-deep space-y-2'>
              <li>Decentralized storage using Walrus Protocol</li>
              <li>NFT-based todos on Sui blockchain</li>
              <li>Beautiful oceanic design with glass-morphism effects</li>
              <li>Multi-wallet support (Sui, Phantom, Slush, Backpack)</li>
              <li>Automatic port detection for development</li>
              <li>Comprehensive error handling</li>
            </ul>

            <h2 className='text-2xl font-semibold text-ocean-deep mt-8 mb-4'>
              Technology Stack
            </h2>
            <ul className='list-disc list-inside text-ocean-deep space-y-2'>
              <li>Next.js 15 with App Router</li>
              <li>React 18 with TypeScript</li>
              <li>Tailwind CSS for styling</li>
              <li>Sui blockchain integration</li>
              <li>Walrus decentralized storage</li>
              <li>Multiple wallet adapters</li>
            </ul>

            <h2 className='text-2xl font-semibold text-ocean-deep mt-8 mb-4'>
              Built With
            </h2>
            <p className='text-ocean-deep'>
              This application demonstrates the future of decentralized task
              management, where your data is truly yours and stored on the
              blockchain for permanence and transparency.
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/blockchain/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import Navbar from '@/components/navbar';
import BlockchainTodoManager from '@/components/BlockchainTodoManager';
import { useWalletContext } from '@/contexts/WalletContext';
import { useSuiTodos } from '@/hooks/useSuiTodos';

export default function BlockchainPage() {
  const { connected, connecting, account, connect } = useWalletContext();
  const { state, network, isWalletReady } = useSuiTodos();
  const [showFullManager, setShowFullManager] = useState(false);

  // Wallet connection component
  const WalletConnectionSection = () => {
    if (connected) {
      return (
        <div className='ocean-card mb-6'>
          <div className='flex justify-between items-center'>
            <div>
              <h3 className='text-lg font-semibold text-ocean-deep dark:text-ocean-foam mb-2'>
                Wallet Connected
              </h3>
              <p className='text-sm text-ocean-medium dark:text-ocean-light'>
                Address:{' '}
                <code className='bg-white/20 px-2 py-1 rounded text-xs'>
                  {account?.address}
                </code>
              </p>
              <p className='text-sm text-ocean-medium dark:text-ocean-light'>
                Network: {network} {state.networkHealth ? '' : ''}
              </p>
            </div>
            <div className='flex gap-2'>
              <button
                onClick={() => setShowFullManager(!showFullManager)}
                className='ocean-button text-sm'
              >
                {showFullManager ? 'Simple View' : 'Advanced Manager'}
              </button>
            </div>
          </div>
        </div>
      );
    }

    return (
      <div className='ocean-card mb-6'>
        <div className='text-center py-8'>
          <div className='mb-4'>
            <svg
              className='w-16 h-16 mx-auto text-ocean-medium'
              fill='none'
              stroke='currentColor'
              viewBox='0 0 24 24'
            >
              <path
                strokeLinecap='round'
                strokeLinejoin='round'
                strokeWidth={1.5}
                d='M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z'
              />
            </svg>
          </div>
          <h3 className='text-xl font-semibold text-ocean-deep dark:text-ocean-foam mb-2'>
            Connect Your Wallet
          </h3>
          <p className='text-ocean-medium dark:text-ocean-light mb-6 max-w-md mx-auto'>
            Connect your Sui wallet to create, manage, and transfer TodoNFTs on
            the blockchain.
          </p>
          <button
            onClick={connect}
            disabled={connecting}
            className='ocean-button inline-flex items-center gap-2'
          >
            {connecting ? (
              <>
                <div className='w-4 h-4 rounded-full border-2 border-white border-t-transparent animate-spin'></div>
                Connecting...
              </>
            ) : (
              'Connect Wallet'
            )}
          </button>
        </div>
      </div>
    );
  };

  return (
    <div className='max-w-6xl mx-auto'>
      <Navbar currentPage='blockchain' />

      <div className='mb-8'>
        <h1 className='text-3xl font-bold mb-4 text-ocean-deep dark:text-ocean-foam'>
          Blockchain Todos
        </h1>
        <p className='text-ocean-medium dark:text-ocean-light'>
          Create, manage, and transfer your TodoNFTs on the Sui blockchain
        </p>
      </div>

      <WalletConnectionSection />

      {connected && (
        <>
          {showFullManager ? (
            <BlockchainTodoManager />
          ) : (
            <div className='ocean-card'>
              <div className='text-center py-12'>
                <h3 className='text-xl font-semibold text-ocean-deep dark:text-ocean-foam mb-2'>
                  Simple Todo View
                </h3>
                <p className='text-ocean-medium dark:text-ocean-light mb-6 max-w-md mx-auto'>
                  Switch to Advanced Manager to create and manage TodoNFTs.
                </p>
                <button
                  onClick={() => setShowFullManager(true)}
                  className='ocean-button'
                >
                  Open Advanced Manager
                </button>
              </div>
            </div>
          )}
        </>
      )}
    </div>
  );
}
</file>

<file path="src/app/dashboard/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import Navbar from '@/components/navbar';
import TodoList from '@/components/todo-list';
import CreateTodoForm from '@/components/create-todo-form';
import { useWalletContext } from '@/contexts/WalletContext';
import {
  getTodoLists,
  createTodoList,
  deleteTodoList,
} from '@/lib/todo-service';

export default function Dashboard() {
  const [selectedList, setSelectedList] = useState('default');
  const [refreshKey, setRefreshKey] = useState(0);
  const [todoLists, setTodoLists] = useState<string[]>(['default']);
  const [showCreateList, setShowCreateList] = useState(false);
  const [newListName, setNewListName] = useState('');
  const { address } = useWalletContext();

  // Load todo lists for the current wallet
  useEffect(() => {
    const lists = getTodoLists(address || undefined);
    setTodoLists(lists.length > 0 ? lists : ['default']);
  }, [address, refreshKey]);

  const handleTodoAdded = () => {
    // Force TodoList to refresh by updating key
    setRefreshKey(prev => prev + 1);
  };

  const handleCreateList = () => {
    if (!newListName.trim()) return;

    const success = createTodoList(newListName.trim(), address || undefined);
    if (success) {
      setRefreshKey(prev => prev + 1);
      setSelectedList(newListName.trim());
      setNewListName('');
      setShowCreateList(false);
    } else {
      alert('Failed to create list. List name might already exist.');
    }
  };

  const handleDeleteList = (listName: string) => {
    if (listName === 'default') {
      alert('Cannot delete the default list');
      return;
    }

    if (
      !confirm(
        `Are you sure you want to delete the "${listName}" list? This will delete all todos in it.`
      )
    ) {
      return;
    }

    const success = deleteTodoList(listName, address || undefined);
    if (success) {
      setRefreshKey(prev => prev + 1);
      if (selectedList === listName) {
        setSelectedList('default');
      }
    } else {
      alert('Failed to delete list');
    }
  };

  return (
    <div className='max-w-6xl mx-auto'>
      <Navbar currentPage='dashboard' />

      <div className='mb-8'>
        <h1 className='text-3xl font-bold mb-4 text-ocean-deep dark:text-ocean-foam'>
          Dashboard
        </h1>
        <p className='text-ocean-medium dark:text-ocean-light'>
          Manage your todos across different lists
        </p>
      </div>

      <div className='grid grid-cols-1 md:grid-cols-4 gap-6'>
        <div className='md:col-span-1'>
          <div className='ocean-card h-full'>
            <h2 className='text-xl font-semibold mb-4 text-ocean-deep dark:text-ocean-foam'>
              Your Lists
            </h2>

            <ul className='space-y-2'>
              {todoLists.map(list => (
                <li key={list} className='mb-1'>
                  <div className='flex items-center gap-2'>
                    <button
                      className={`flex-grow text-left px-3 py-2 rounded-lg transition-colors ${
                        selectedList === list
                          ? 'bg-ocean-medium text-white font-medium'
                          : 'hover:bg-ocean-light/30 dark:hover:bg-ocean-medium/30'
                      }`}
                      onClick={() => setSelectedList(list)}
                    >
                      {list.charAt(0).toUpperCase() + list.slice(1)}
                    </button>
                    {list !== 'default' && (
                      <button
                        onClick={() => handleDeleteList(list)}
                        className='p-1 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 transition-colors'
                        title='Delete list'
                      >
                        <svg
                          xmlns='http://www.w3.org/2000/svg'
                          className='h-4 w-4'
                          fill='none'
                          viewBox='0 0 24 24'
                          stroke='currentColor'
                        >
                          <path
                            strokeLinecap='round'
                            strokeLinejoin='round'
                            strokeWidth={2}
                            d='M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16'
                          />
                        </svg>
                      </button>
                    )}
                  </div>
                </li>
              ))}
            </ul>

            <div className='mt-6'>
              {!showCreateList ? (
                <button
                  className='ocean-button w-full'
                  onClick={() => setShowCreateList(true)}
                >
                  <span>Create New List</span>
                </button>
              ) : (
                <div className='space-y-3'>
                  <input
                    type='text'
                    value={newListName}
                    onChange={e => setNewListName(e.target.value)}
                    onKeyPress={e => e.key === 'Enter' && handleCreateList()}
                    placeholder='List name...'
                    className='w-full px-3 py-2 border border-ocean-light dark:border-ocean-medium rounded-lg focus:ring-2 focus:ring-ocean-medium focus:border-transparent bg-white dark:bg-ocean-deep text-ocean-deep dark:text-ocean-foam'
                    autoFocus
                  />
                  <div className='flex gap-2'>
                    <button
                      onClick={handleCreateList}
                      disabled={!newListName.trim()}
                      className='flex-1 px-3 py-2 bg-ocean-medium text-white rounded-lg hover:bg-ocean-deep transition-colors disabled:opacity-50 disabled:cursor-not-allowed'
                    >
                      Create
                    </button>
                    <button
                      onClick={() => {
                        setShowCreateList(false);
                        setNewListName('');
                      }}
                      className='px-3 py-2 border border-ocean-light dark:border-ocean-medium rounded-lg hover:bg-ocean-light/30 dark:hover:bg-ocean-medium/30 transition-colors'
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

        <div className='md:col-span-3'>
          <div className='ocean-card mb-6'>
            <h2 className='text-xl font-semibold mb-4 text-ocean-deep dark:text-ocean-foam'>
              Add New Todo
            </h2>
            <CreateTodoForm
              listName={selectedList}
              onTodoAdded={handleTodoAdded}
            />
          </div>

          <div className='ocean-card'>
            <div className='flex justify-between items-center mb-4'>
              <h2 className='text-xl font-semibold text-ocean-deep dark:text-ocean-foam'>
                {selectedList.charAt(0).toUpperCase() + selectedList.slice(1)}{' '}
                List
              </h2>

              <div className='flex space-x-2'>
                <button className='px-3 py-1 text-sm bg-ocean-light/50 dark:bg-ocean-medium/50 rounded-lg hover:bg-ocean-light dark:hover:bg-ocean-medium transition-colors'>
                  All
                </button>
                <button className='px-3 py-1 text-sm bg-ocean-light/30 dark:bg-ocean-medium/30 rounded-lg hover:bg-ocean-light dark:hover:bg-ocean-medium transition-colors'>
                  Pending
                </button>
                <button className='px-3 py-1 text-sm bg-ocean-light/30 dark:bg-ocean-medium/30 rounded-lg hover:bg-ocean-light dark:hover:bg-ocean-medium transition-colors'>
                  Completed
                </button>
              </div>
            </div>

            <TodoList
              key={`${selectedList}-${refreshKey}`}
              listName={selectedList}
            />
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/examples/page.tsx">
import Navbar from '@/components/navbar';
import WalletUsageExample from './wallet-usage';

export default function ExamplesPage() {
  return (
    <>
      <Navbar currentPage='examples' />

      <div className='max-w-7xl mx-auto px-4 sm:px-6 lg:px-8'>
        <h1 className='text-3xl font-bold text-ocean-deep dark:text-ocean-foam mb-8'>
          Code Examples
        </h1>

        <div className='grid gap-8'>
          <div className='ocean-card'>
            <WalletUsageExample />
          </div>
        </div>
      </div>
    </>
  );
}
</file>

<file path="src/app/examples/wallet-usage.tsx">
'use client';

/**
 * Example: How to use the updated wallet integration in components
 */

import { useState } from 'react';
import { useWalletContext } from '@/contexts/WalletContext';
import { storeTodoOnBlockchain } from '@/lib/todo-service';
import { TransactionHistory } from '@/components/TransactionHistory';

export default function WalletUsageExample() {
  const {
    connected,
    address,
    chainId,
    name: walletName,
    connect,
    disconnect,
    switchNetwork,
    trackTransaction,
  } = useWalletContext();

  const [transactionStatus, setTransactionStatus] = useState<
    'idle' | 'pending' | 'success' | 'error'
  >('idle');
  const [transactionId, setTransactionId] = useState<string | null>(null);

  // Example of how to store a todo on blockchain with transaction tracking
  const handleStoreOnBlockchain = async (listName: string, todoId: string) => {
    if (!connected) {
      alert('Please connect your wallet first');
      return;
    }

    setTransactionStatus('pending');

    try {
      // Store the todo on blockchain (returns object ID)
      const objectId = await storeTodoOnBlockchain(listName, todoId);

      if (objectId) {
        console.log('Todo stored with ID:', objectId);
        setTransactionStatus('success');
        setTransactionId(objectId);
      } else {
        throw new Error('Failed to store todo on blockchain');
      }
    } catch (error) {
      console.error('Transaction failed:', error);
      setTransactionStatus('error');
    }
  };

  return (
    <div className='p-4 ocean-card'>
      <h2 className='text-xl font-bold mb-4'>Wallet Usage Example</h2>

      <div className='space-y-4'>
        <div className='p-4 bg-ocean-deep/10 rounded-lg'>
          <p>
            <span className='font-medium'>Connected:</span>{' '}
            {connected ? 'Yes' : 'No'}
          </p>
          <p>
            <span className='font-medium'>Wallet:</span> {walletName || 'None'}
          </p>
          <p>
            <span className='font-medium'>Address:</span>{' '}
            {address || 'Not connected'}
          </p>
          <p>
            <span className='font-medium'>Network:</span> {chainId || 'Unknown'}
          </p>
        </div>

        {/* Wallet connection controls */}
        <div className='flex gap-4 flex-wrap'>
          {!connected ? (
            <button
              onClick={() => connect()}
              className='px-4 py-2 bg-ocean-deep text-white rounded-lg hover:bg-ocean-deep/80'
            >
              Connect Wallet
            </button>
          ) : (
            <button
              onClick={() => disconnect()}
              className='px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600'
            >
              Disconnect
            </button>
          )}

          {/* Network switching example */}
          {connected && (
            <div className='flex gap-2'>
              <button
                onClick={() => switchNetwork('mainnet')}
                className={`px-4 py-2 rounded-lg ${
                  chainId === 'mainnet'
                    ? 'bg-green-500 text-white'
                    : 'bg-gray-200 hover:bg-gray-300'
                }`}
              >
                Mainnet
              </button>
              <button
                onClick={() => switchNetwork('testnet')}
                className={`px-4 py-2 rounded-lg ${
                  chainId === 'testnet'
                    ? 'bg-green-500 text-white'
                    : 'bg-gray-200 hover:bg-gray-300'
                }`}
              >
                Testnet
              </button>
              <button
                onClick={() => switchNetwork('devnet')}
                className={`px-4 py-2 rounded-lg ${
                  chainId === 'devnet'
                    ? 'bg-green-500 text-white'
                    : 'bg-gray-200 hover:bg-gray-300'
                }`}
              >
                Devnet
              </button>
            </div>
          )}
        </div>

        {/* Transaction example section */}
        <div className='mt-6'>
          <h3 className='text-lg font-medium mb-2'>Transaction Example</h3>
          <div className='flex gap-4 items-center'>
            <button
              onClick={() => handleStoreOnBlockchain('default', '123')}
              disabled={!connected || transactionStatus === 'pending'}
              className='px-4 py-2 bg-blue-500 text-white rounded disabled:bg-gray-300 disabled:cursor-not-allowed'
            >
              {transactionStatus === 'pending'
                ? 'Processing...'
                : 'Store Todo on Blockchain'}
            </button>

            {/* Transaction status indicator */}
            {transactionStatus === 'pending' && (
              <div className='text-yellow-600'>Transaction in progress...</div>
            )}
            {transactionStatus === 'success' && (
              <div className='text-green-600'>
                Transaction successful! Object ID: {transactionId}
              </div>
            )}
            {transactionStatus === 'error' && (
              <div className='text-red-600'>
                Transaction failed. Please try again.
              </div>
            )}
          </div>
        </div>

        {/* Transaction History */}
        <div className='mt-6'>
          <h3 className='text-lg font-medium mb-2'>Transaction History</h3>
          <TransactionHistory maxItems={3} />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/test-blockchain/page.tsx">
'use client';

import { useState } from 'react';
import { useWalletContext } from '@/contexts/WalletContext';
import { useSuiTodos } from '@/hooks/useSuiTodos';
import Navbar from '@/components/navbar';
import WalrusStorageManager from '@/components/WalrusStorageManager';

export default function TestBlockchainPage() {
  const { connected, address, connect, disconnect } = useWalletContext();
  const { state, actions, isWalletReady } = useSuiTodos();
  const [testResult, setTestResult] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);

  const testCreateTodo = async () => {
    setIsLoading(true);
    setTestResult('Creating todo...');

    try {
      const result = await actions.createTodo({
        title: 'Test Todo ' + new Date().toISOString(),
        description:
          'This is a test todo created to verify blockchain connectivity',
        priority: 'high',
        tags: ['test', 'blockchain'],
      });

      if (result.success) {
        setTestResult(` Success! Todo created with ID: ${result.digest}`);
      } else {
        setTestResult(` Failed: ${result.error}`);
      }
    } catch (error) {
      setTestResult(
        ` Error: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    } finally {
      setIsLoading(false);
    }
  };

  const testCompleteTodo = async () => {
    if (state.todos.length === 0) {
      setTestResult(' No todos to complete');
      return;
    }

    const todo = state.todos.find(t => !t.completed) || state.todos[0];

    setIsLoading(true);
    setTestResult(`Completing todo: ${todo.title}...`);

    try {
      const result = await actions.completeTodo(todo.id);

      if (result.success) {
        setTestResult(` Success! Todo completed`);
      } else {
        setTestResult(` Failed: ${result.error}`);
      }
    } catch (error) {
      setTestResult(
        ` Error: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className='max-w-6xl mx-auto'>
      <Navbar currentPage='test' />

      <div className='mb-8'>
        <h1 className='text-3xl font-bold mb-4 text-ocean-deep dark:text-ocean-foam'>
          Test Blockchain Connectivity
        </h1>
        <p className='text-ocean-medium dark:text-ocean-light'>
          Test page to verify blockchain operations are working correctly
        </p>
      </div>

      <div className='ocean-card mb-6'>
        <h2 className='text-xl font-semibold mb-4'>Wallet Status</h2>
        <div className='space-y-2'>
          <p>Connected: {connected ? ' Yes' : ' No'}</p>
          <p>Address: {address || 'Not connected'}</p>
          <p>Wallet Ready: {isWalletReady ? ' Yes' : ' No'}</p>

          {!connected ? (
            <button onClick={connect} className='ocean-button'>
              Connect Wallet
            </button>
          ) : (
            <button onClick={disconnect} className='ocean-button'>
              Disconnect
            </button>
          )}
        </div>
      </div>

      <div className='ocean-card mb-6'>
        <h2 className='text-xl font-semibold mb-4'>
          Todos ({state.todos.length})
        </h2>
        {state.loading ? (
          <p>Loading todos...</p>
        ) : state.todos.length === 0 ? (
          <p>No todos found</p>
        ) : (
          <ul className='space-y-2'>
            {state.todos.map(todo => (
              <li key={todo.id} className='flex items-center gap-2'>
                <span className={todo.completed ? 'line-through' : ''}>
                  {todo.title}
                </span>
                {todo.blockchainStored && (
                  <span className='text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded'>
                    NFT: {todo.objectId?.slice(0, 8)}...
                  </span>
                )}
              </li>
            ))}
          </ul>
        )}

        <button
          onClick={() => actions.refreshTodos()}
          className='ocean-button mt-4'
          disabled={state.refreshing}
        >
          {state.refreshing ? 'Refreshing...' : 'Refresh Todos'}
        </button>
      </div>

      <div className='ocean-card mb-6'>
        <h2 className='text-xl font-semibold mb-4'>Test Operations</h2>

        <div className='space-y-4'>
          <button
            onClick={testCreateTodo}
            disabled={!isWalletReady || isLoading}
            className='ocean-button w-full'
          >
            Test Create Todo
          </button>

          <button
            onClick={testCompleteTodo}
            disabled={!isWalletReady || isLoading || state.todos.length === 0}
            className='ocean-button w-full'
          >
            Test Complete Todo
          </button>
        </div>

        {testResult && (
          <div className='mt-4 p-4 bg-gray-100 rounded'>
            <h3 className='font-semibold mb-2'>Test Result:</h3>
            <pre className='whitespace-pre-wrap text-sm'>{testResult}</pre>
          </div>
        )}
      </div>

      {state.error && (
        <div className='ocean-card mb-6 bg-red-50 border-red-200'>
          <h3 className='text-red-800 font-semibold mb-2'>Error:</h3>
          <p className='text-red-700'>{state.error}</p>
          <button
            onClick={() => actions.clearError()}
            className='mt-2 text-sm text-red-600 underline'
          >
            Clear Error
          </button>
        </div>
      )}

      <WalrusStorageManager />
    </div>
  );
}
</file>

<file path="src/app/walrus/page.tsx">
/**
 * Walrus Storage Page
 *
 * Demo page showcasing Walrus Protocol integration for decentralized todo storage.
 */

'use client';

import React from 'react';
import dynamic from 'next/dynamic';

// Dynamically import WalrusStorageManager to prevent SSR issues with WASM
const WalrusStorageManager = dynamic(
  () => import('@/components/WalrusStorageManager'),
  {
    ssr: false,
    loading: () => (
      <div className='flex items-center justify-center py-12'>
        <div className='text-center'>
          <div className='animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4'></div>
          <p className='text-gray-600'>Loading Walrus Storage Manager...</p>
        </div>
      </div>
    ),
  }
);

export default function WalrusPage() {
  return (
    <div className='min-h-screen bg-gradient-to-br from-blue-50 via-white to-cyan-50'>
      {/* Header */}
      <div className='bg-white shadow-sm border-b'>
        <div className='max-w-7xl mx-auto px-4 sm:px-6 lg:px-8'>
          <div className='py-6'>
            <div className='flex items-center space-x-4'>
              <div className='flex-shrink-0'>
                <div className='w-12 h-12 bg-blue-600 rounded-xl flex items-center justify-center'>
                  <svg
                    className='w-6 h-6 text-white'
                    fill='none'
                    stroke='currentColor'
                    viewBox='0 0 24 24'
                  >
                    <path
                      strokeLinecap='round'
                      strokeLinejoin='round'
                      strokeWidth={2}
                      d='M4 7v10c0 2.21 1.79 4 4 4h8c0-5-4-9-8-9s-8 4-8-5zm0 0V4a1 1 0 011-1h4a1 1 0 011 1v3M8 12l4 4 4-4m0 6H8'
                    />
                  </svg>
                </div>
              </div>
              <div>
                <h1 className='text-3xl font-bold text-gray-900'>
                  Walrus Protocol Storage
                </h1>
                <p className='text-gray-600 mt-1'>
                  Decentralized storage for your todos using Walrus Protocol
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Feature highlights */}
      <div className='max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8'>
        <div className='grid grid-cols-1 md:grid-cols-3 gap-6 mb-8'>
          <div className='bg-white rounded-xl p-6 shadow-sm border'>
            <div className='w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center mb-4'>
              <svg
                className='w-5 h-5 text-blue-600'
                fill='none'
                stroke='currentColor'
                viewBox='0 0 24 24'
              >
                <path
                  strokeLinecap='round'
                  strokeLinejoin='round'
                  strokeWidth={2}
                  d='M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z'
                />
              </svg>
            </div>
            <h3 className='text-lg font-semibold text-gray-900 mb-2'>
              Decentralized Storage
            </h3>
            <p className='text-gray-600 text-sm'>
              Store your todos on Walrus Protocol's decentralized network for
              permanent, censorship-resistant storage.
            </p>
          </div>

          <div className='bg-white rounded-xl p-6 shadow-sm border'>
            <div className='w-10 h-10 bg-green-100 rounded-lg flex items-center justify-center mb-4'>
              <svg
                className='w-5 h-5 text-green-600'
                fill='none'
                stroke='currentColor'
                viewBox='0 0 24 24'
              >
                <path
                  strokeLinecap='round'
                  strokeLinejoin='round'
                  strokeWidth={2}
                  d='M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z'
                />
              </svg>
            </div>
            <h3 className='text-lg font-semibold text-gray-900 mb-2'>
              Blockchain Ownership
            </h3>
            <p className='text-gray-600 text-sm'>
              Create NFTs on Sui blockchain that reference your Walrus-stored
              todos for verifiable ownership.
            </p>
          </div>

          <div className='bg-white rounded-xl p-6 shadow-sm border'>
            <div className='w-10 h-10 bg-purple-100 rounded-lg flex items-center justify-center mb-4'>
              <svg
                className='w-5 h-5 text-purple-600'
                fill='none'
                stroke='currentColor'
                viewBox='0 0 24 24'
              >
                <path
                  strokeLinecap='round'
                  strokeLinejoin='round'
                  strokeWidth={2}
                  d='M13 10V3L4 14h7v7l9-11h-7z'
                />
              </svg>
            </div>
            <h3 className='text-lg font-semibold text-gray-900 mb-2'>
              High Performance
            </h3>
            <p className='text-gray-600 text-sm'>
              Enjoy fast uploads and downloads with built-in redundancy and
              availability guarantees.
            </p>
          </div>
        </div>
      </div>

      {/* Main content */}
      <div className='max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pb-12'>
        <WalrusStorageManager />
      </div>

      {/* Footer info */}
      <div className='bg-gray-50 border-t'>
        <div className='max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8'>
          <div className='grid grid-cols-1 md:grid-cols-2 gap-8'>
            <div>
              <h3 className='text-lg font-medium text-gray-900 mb-4'>
                How It Works
              </h3>
              <div className='space-y-3 text-sm text-gray-600'>
                <div className='flex items-start space-x-3'>
                  <div className='w-6 h-6 bg-blue-100 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5'>
                    <span className='text-blue-600 font-medium text-xs'>1</span>
                  </div>
                  <p>Create a todo with your content, priority, and metadata</p>
                </div>
                <div className='flex items-start space-x-3'>
                  <div className='w-6 h-6 bg-blue-100 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5'>
                    <span className='text-blue-600 font-medium text-xs'>2</span>
                  </div>
                  <p>Upload to Walrus Protocol for decentralized storage</p>
                </div>
                <div className='flex items-start space-x-3'>
                  <div className='w-6 h-6 bg-blue-100 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5'>
                    <span className='text-blue-600 font-medium text-xs'>3</span>
                  </div>
                  <p>
                    Optionally create an NFT on Sui blockchain for ownership
                  </p>
                </div>
                <div className='flex items-start space-x-3'>
                  <div className='w-6 h-6 bg-blue-100 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5'>
                    <span className='text-blue-600 font-medium text-xs'>4</span>
                  </div>
                  <p>Retrieve your todos anytime using the blob ID</p>
                </div>
              </div>
            </div>

            <div>
              <h3 className='text-lg font-medium text-gray-900 mb-4'>
                Storage Information
              </h3>
              <div className='space-y-3 text-sm text-gray-600'>
                <p>
                  <strong>Network:</strong> Walrus Testnet
                </p>
                <p>
                  <strong>Storage Duration:</strong> 5 epochs (approximately 5
                  days)
                </p>
                <p>
                  <strong>Max File Size:</strong> 13 MB per todo
                </p>
                <p>
                  <strong>Redundancy:</strong> Multiple copies across
                  decentralized nodes
                </p>
                <p>
                  <strong>Cost:</strong> Paid in WAL tokens (get testnet tokens
                  from faucet)
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/ClientOnlyRoot.tsx">
// Using React client component
'use client';

import React, { ReactNode, useEffect, useState } from 'react';
import { ErrorBoundary } from '@/components/ErrorBoundary';
import { ErrorSuppressor } from '@/components/ErrorSuppressor';
import { AppWalletProvider } from '@/contexts/WalletContext';

interface ClientOnlyRootProps {
  children: ReactNode;
}

export default function ClientOnlyRoot({ children }: ClientOnlyRootProps) {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    console.log(' ClientOnlyRoot useEffect FIRED!');
    // Use a small delay to ensure proper hydration
    const timer = setTimeout(() => {
      setIsClient(true);
      console.log(' ClientOnlyRoot isClient set to true');
    }, 10);
    
    return () => clearTimeout(timer);
  }, []);

  console.log(' ClientOnlyRoot render, isClient:', isClient, 'window exists:', typeof window !== 'undefined');

  // Render a minimal fallback during SSR and initial client render
  if (!isClient) {
    return (
      <main className='container mx-auto px-4 py-8'>
        <div className="text-center">
          <div>Loading wallet and blockchain components...</div>
          <div className="mt-2 text-sm text-gray-600">Initializing client...</div>
        </div>
      </main>
    );
  }

  console.log(' ClientOnlyRoot rendering full app with wallet provider');

  return (
    <ErrorBoundary>
      <ErrorSuppressor />
      <AppWalletProvider>
        {children}
      </AppWalletProvider>
    </ErrorBoundary>
  );
}
</file>

<file path="src/app/layout.tsx">
import '@/styles/globals.css';
import '@mysten/dapp-kit/dist/index.css';
import type { Metadata } from 'next';
import ClientOnlyRoot from './ClientOnlyRoot';

export const metadata: Metadata = {
  title: 'Walrus Todo - Web3 Task Management',
  description: 'A blockchain-powered todo application with oceanic design',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang='en'>
      <body className='font-sans wave-animation'>
        {/* ClientOnlyRoot handles all client-side components */}
        <ClientOnlyRoot>{children}</ClientOnlyRoot>
      </body>
    </html>
  );
}
</file>

<file path="src/app/page.tsx">
'use client';

import { useState } from 'react';
import Link from 'next/link';
import Navbar from '@/components/navbar';

export default function Home() {
  const [isConnecting, setIsConnecting] = useState(false);

  const handleConnect = async () => {
    setIsConnecting(true);
    // Connection logic will be added later
    setTimeout(() => setIsConnecting(false), 1500);
  };

  return (
    <>
      <Navbar currentPage='home' />
      <div className='flex flex-col items-center justify-center min-h-[80vh] text-center'>
        <div className='floating-element mb-8'>
          <div className='relative w-32 h-32 md:w-48 md:h-48 mx-auto'>
            {/* Replace with your app logo */}
            <div className='w-full h-full rounded-full bg-gradient-to-br from-ocean-light to-dream-teal shadow-dreamy flex items-center justify-center text-4xl md:text-6xl text-white font-bold'>
              WT
            </div>
          </div>
        </div>

        <h1 className='text-4xl md:text-6xl font-bold mb-4 text-ocean-deep dark:text-ocean-foam'>
          <span className='inline-block animate-float'>Walrus</span>{' '}
          <span className='inline-block animate-float animation-delay-300'>
            Todo
          </span>
        </h1>

        <p className='text-xl mb-8 max-w-2xl text-ocean-medium dark:text-ocean-light'>
          A dreamy, oceanic Web3 task management experience powered by Sui
          blockchain and Walrus decentralized storage
        </p>

        <div className='grid grid-cols-1 md:grid-cols-2 gap-6 mb-12'>
          <div className='ocean-card max-w-sm transform transition-all hover:scale-105'>
            <h2 className='text-2xl font-semibold mb-3 text-ocean-deep dark:text-ocean-foam'>
              Decentralized Tasks
            </h2>
            <p className='text-ocean-medium dark:text-ocean-light mb-4'>
              Store your todos securely on the blockchain as NFTs that can be
              transferred and shared.
            </p>
          </div>

          <div className='ocean-card max-w-sm transform transition-all hover:scale-105'>
            <h2 className='text-2xl font-semibold mb-3 text-ocean-deep dark:text-ocean-foam'>
              AI-Powered
            </h2>
            <p className='text-ocean-medium dark:text-ocean-light mb-4'>
              Get intelligent suggestions, categorization, and prioritization
              for your tasks.
            </p>
          </div>
        </div>

        <button
          className='ocean-button group relative overflow-hidden'
          onClick={handleConnect}
          disabled={isConnecting}
        >
          <span className='relative z-10'>
            {isConnecting ? 'Connecting...' : 'Connect Wallet to Begin'}
          </span>
          <span className='absolute inset-0 bg-gradient-to-r from-dream-teal to-dream-purple opacity-0 group-hover:opacity-30 transition-opacity duration-300'></span>
        </button>

        <div className='mt-12 flex gap-6'>
          <Link
            href='/about'
            className='text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam transition-colors'
          >
            Learn More
          </Link>
          <Link
            href='/dashboard'
            className='text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam transition-colors'
          >
            View Dashboard
          </Link>
        </div>
      </div>
    </>
  );
}
</file>

<file path="src/components/BlockchainEventStatus.tsx">
/**
 * React component for displaying blockchain event connection status
 * Shows real-time connection state with visual indicators
 */

'use client';

import React, { useState } from 'react';
import { useEventConnectionStatus } from '@/hooks/useBlockchainEvents';

interface BlockchainEventStatusProps {
  className?: string;
  showReconnectButton?: boolean;
  showDetails?: boolean;
  compact?: boolean;
}

export function BlockchainEventStatus({
  className = '',
  showReconnectButton = true,
  showDetails = false,
  compact = false,
}: BlockchainEventStatusProps) {
  const { connectionState, statusColor, statusText, canReconnect, reconnect } =
    useEventConnectionStatus();

  const [showDetailsState, setShowDetailsState] = useState(showDetails);

  const getIndicatorClasses = () => {
    const baseClasses = 'inline-block w-2 h-2 rounded-full mr-2';
    switch (statusColor) {
      case 'green':
        return `${baseClasses} bg-green-500`;
      case 'yellow':
        return `${baseClasses} bg-yellow-500 animate-pulse`;
      case 'red':
        return `${baseClasses} bg-red-500`;
      default:
        return `${baseClasses} bg-gray-400`;
    }
  };

  const handleReconnect = async () => {
    try {
      await reconnect();
    } catch (error) {
      console.error('Failed to reconnect:', error);
    }
  };

  if (compact) {
    return (
      <div className={`flex items-center text-sm ${className}`}>
        <span className={getIndicatorClasses()}></span>
        <span className='text-gray-600 dark:text-gray-300'>
          {connectionState.connected ? 'Live' : 'Offline'}
        </span>
      </div>
    );
  }

  return (
    <div
      className={`bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-4 ${className}`}
    >
      <div className='flex items-center justify-between'>
        <div className='flex items-center'>
          <span className={getIndicatorClasses()}></span>
          <div>
            <span className='font-medium text-gray-900 dark:text-gray-100'>
              Blockchain Events
            </span>
            <p className='text-sm text-gray-600 dark:text-gray-400'>
              {statusText}
            </p>
          </div>
        </div>

        <div className='flex items-center space-x-2'>
          {!compact && (
            <button
              onClick={() => setShowDetailsState(!showDetailsState)}
              className='text-sm text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300'
            >
              {showDetailsState ? 'Hide' : 'Details'}
            </button>
          )}

          {showReconnectButton && canReconnect && (
            <button
              onClick={handleReconnect}
              className='px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors'
            >
              Reconnect
            </button>
          )}
        </div>
      </div>

      {showDetailsState && (
        <div className='mt-4 pt-4 border-t border-gray-200 dark:border-gray-600'>
          <dl className='grid grid-cols-2 gap-4 text-sm'>
            <div>
              <dt className='font-medium text-gray-900 dark:text-gray-100'>
                Status
              </dt>
              <dd className='text-gray-600 dark:text-gray-400'>
                {connectionState.connected ? 'Connected' : 'Disconnected'}
              </dd>
            </div>

            <div>
              <dt className='font-medium text-gray-900 dark:text-gray-100'>
                Reconnect Attempts
              </dt>
              <dd className='text-gray-600 dark:text-gray-400'>
                {connectionState.reconnectAttempts}
              </dd>
            </div>

            {connectionState.lastReconnectAttempt > 0 && (
              <div className='col-span-2'>
                <dt className='font-medium text-gray-900 dark:text-gray-100'>
                  Last Reconnect Attempt
                </dt>
                <dd className='text-gray-600 dark:text-gray-400'>
                  {new Date(
                    connectionState.lastReconnectAttempt
                  ).toLocaleString()}
                </dd>
              </div>
            )}

            {connectionState.error && (
              <div className='col-span-2'>
                <dt className='font-medium text-red-600 dark:text-red-400'>
                  Error
                </dt>
                <dd className='text-red-600 dark:text-red-400 font-mono text-xs'>
                  {connectionState.error.message}
                </dd>
              </div>
            )}
          </dl>
        </div>
      )}
    </div>
  );
}

/**
 * Simple status indicator for nav bars or headers
 */
export function BlockchainEventIndicator({
  className = '',
}: {
  className?: string;
}) {
  return (
    <BlockchainEventStatus
      className={className}
      compact={true}
      showReconnectButton={false}
      showDetails={false}
    />
  );
}
</file>

<file path="src/components/BlockchainTodoManager.tsx">
/**
 * Comprehensive TodoNFT management component
 * Demonstrates all blockchain operations with proper error handling
 */

'use client';

import React, { useState, useEffect } from 'react';
import {
  useSuiTodos,
  useTodoOperation,
  NetworkType,
  Todo,
  CreateTodoParams,
  UpdateTodoParams,
} from '@/hooks/useSuiTodos';
import { useWalletContext } from '@/contexts/WalletContext';

// TodoNFT creation form component
function CreateTodoForm({
  onSubmit,
  loading,
}: {
  onSubmit: (params: CreateTodoParams) => Promise<void>;
  loading: boolean;
}) {
  const [formData, setFormData] = useState<CreateTodoParams>({
    title: '',
    description: '',
    priority: 'medium',
    dueDate: undefined,
    tags: [],
  });

  const [errors, setErrors] = useState<Record<string, string>>({});

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!formData.title.trim()) {
      newErrors.title = 'Title is required';
    } else if (formData.title.length > 100) {
      newErrors.title = 'Title must be 100 characters or less';
    }

    if (formData.description.length > 500) {
      newErrors.description = 'Description must be 500 characters or less';
    }

    // Priority is always valid since it has a default
    // Tags and dueDate are optional

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!validateForm()) {
      return;
    }

    try {
      await onSubmit(formData);

      // Reset form on success
      setFormData({
        title: '',
        description: '',
        priority: 'medium',
        dueDate: undefined,
        tags: [],
      });
      setErrors({});
    } catch (error) {
      console.error('Create todo error:', error);
    }
  };

  return (
    <form
      onSubmit={handleSubmit}
      className='bg-white p-6 rounded-lg shadow-md space-y-4'
    >
      <h3 className='text-lg font-semibold text-gray-900'>Create TodoNFT</h3>

      <div>
        <label
          htmlFor='title'
          className='block text-sm font-medium text-gray-700 mb-1'
        >
          Title *
        </label>
        <input
          type='text'
          id='title'
          value={formData.title}
          onChange={e =>
            setFormData(prev => ({ ...prev, title: e.target.value }))
          }
          className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
            errors.title ? 'border-red-500' : 'border-gray-300'
          }`}
          placeholder='Enter todo title'
          disabled={loading}
        />
        {errors.title && (
          <p className='text-red-500 text-sm mt-1'>{errors.title}</p>
        )}
      </div>

      <div>
        <label
          htmlFor='description'
          className='block text-sm font-medium text-gray-700 mb-1'
        >
          Description
        </label>
        <textarea
          id='description'
          value={formData.description}
          onChange={e =>
            setFormData(prev => ({ ...prev, description: e.target.value }))
          }
          className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 resize-vertical ${
            errors.description ? 'border-red-500' : 'border-gray-300'
          }`}
          placeholder='Enter todo description'
          rows={3}
          disabled={loading}
        />
        {errors.description && (
          <p className='text-red-500 text-sm mt-1'>{errors.description}</p>
        )}
      </div>

      <div>
        <label
          htmlFor='priority'
          className='block text-sm font-medium text-gray-700 mb-1'
        >
          Priority
        </label>
        <select
          id='priority'
          value={formData.priority || 'medium'}
          onChange={e =>
            setFormData(prev => ({
              ...prev,
              priority: e.target.value as 'low' | 'medium' | 'high',
            }))
          }
          className='w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500'
          disabled={loading}
        >
          <option value='low'>Low</option>
          <option value='medium'>Medium</option>
          <option value='high'>High</option>
        </select>
      </div>

      <div>
        <label
          htmlFor='dueDate'
          className='block text-sm font-medium text-gray-700 mb-1'
        >
          Due Date
        </label>
        <input
          type='date'
          id='dueDate'
          value={formData.dueDate || ''}
          onChange={e =>
            setFormData(prev => ({
              ...prev,
              dueDate: e.target.value || undefined,
            }))
          }
          className='w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500'
          disabled={loading}
        />
      </div>

      <div>
        <label
          htmlFor='tags'
          className='block text-sm font-medium text-gray-700 mb-1'
        >
          Tags (comma-separated)
        </label>
        <input
          type='text'
          id='tags'
          value={formData.tags?.join(', ') || ''}
          onChange={e =>
            setFormData(prev => ({
              ...prev,
              tags: e.target.value
                .split(',')
                .map(tag => tag.trim())
                .filter(tag => tag.length > 0),
            }))
          }
          className='w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500'
          placeholder='work, urgent, blockchain'
          disabled={loading}
        />
      </div>

      <button
        type='submit'
        disabled={loading}
        className='w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors'
      >
        {loading ? 'Creating...' : 'Create TodoNFT'}
      </button>
    </form>
  );
}

// Individual todo item component
function TodoItem({
  todo,
  onUpdate,
  onComplete,
  onDelete,
  loading,
}: {
  todo: Todo;
  onUpdate: (params: UpdateTodoParams) => Promise<void>;
  onComplete: (objectId: string) => Promise<void>;
  onDelete: (objectId: string) => Promise<void>;
  loading: boolean;
}) {
  const [isEditing, setIsEditing] = useState(false);
  const [editForm, setEditForm] = useState({
    title: todo.title,
    description: todo.description || '',
  });

  const { executeOperation, loading: operationLoading } = useTodoOperation();

  const handleSave = async () => {
    if (!todo.objectId) return;

    await executeOperation(async () => {
      await onUpdate({
        objectId: todo.objectId!,
        title: editForm.title,
        description: editForm.description,
      });
      setIsEditing(false);
      // Return a mock TransactionResult since onUpdate returns void
      return { success: true };
    });
  };

  const handleComplete = async () => {
    if (!todo.objectId) return;

    await executeOperation(async () => {
      await onComplete(todo.objectId!);
      return { success: true };
    });
  };

  const handleDelete = async () => {
    if (!todo.objectId) return;

    if (window.confirm('Are you sure you want to delete this TodoNFT?')) {
      await executeOperation(async () => {
        await onDelete(todo.objectId!);
        return { success: true };
      });
    }
  };

  const isLoading = loading || operationLoading;

  return (
    <div
      className={`bg-white p-4 rounded-lg shadow-md border-l-4 ${
        todo.completed ? 'border-green-500 bg-green-50' : 'border-blue-500'
      }`}
    >
      <div className='flex justify-between items-start mb-2'>
        {isEditing ? (
          <input
            type='text'
            value={editForm.title}
            onChange={e =>
              setEditForm(prev => ({ ...prev, title: e.target.value }))
            }
            className='text-lg font-semibold bg-transparent border-b border-gray-300 focus:outline-none focus:border-blue-500 flex-1 mr-2'
            disabled={isLoading}
          />
        ) : (
          <h4
            className={`text-lg font-semibold ${
              todo.completed ? 'line-through text-gray-500' : 'text-gray-900'
            }`}
          >
            {todo.title}
          </h4>
        )}

        <div className='flex space-x-2'>
          {isEditing ? (
            <>
              <button
                onClick={handleSave}
                disabled={isLoading}
                className='text-green-600 hover:text-green-800 disabled:opacity-50'
              >
                Save
              </button>
              <button
                onClick={() => setIsEditing(false)}
                disabled={isLoading}
                className='text-gray-600 hover:text-gray-800 disabled:opacity-50'
              >
                Cancel
              </button>
            </>
          ) : (
            <>
              <button
                onClick={() => setIsEditing(true)}
                disabled={isLoading || todo.completed}
                className='text-blue-600 hover:text-blue-800 disabled:opacity-50'
              >
                Edit
              </button>
              {!todo.completed && (
                <button
                  onClick={handleComplete}
                  disabled={isLoading}
                  className='text-green-600 hover:text-green-800 disabled:opacity-50'
                >
                  Complete
                </button>
              )}
              <button
                onClick={handleDelete}
                disabled={isLoading}
                className='text-red-600 hover:text-red-800 disabled:opacity-50'
              >
                Delete
              </button>
            </>
          )}
        </div>
      </div>

      {isEditing ? (
        <div className='space-y-2'>
          <textarea
            value={editForm.description}
            onChange={e =>
              setEditForm(prev => ({ ...prev, description: e.target.value }))
            }
            className='w-full p-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 resize-vertical'
            placeholder='Description'
            rows={2}
            disabled={isLoading}
          />
        </div>
      ) : (
        <>
          {todo.description && (
            <p
              className={`text-gray-600 mb-2 ${
                todo.completed ? 'line-through' : ''
              }`}
            >
              {todo.description}
            </p>
          )}

          <div className='flex justify-between items-center text-sm text-gray-500'>
            <div>
              <span className='mr-4'>Object ID: {todo.objectId}</span>
              {todo.createdAt && (
                <span>
                  Created: {new Date(todo.createdAt).toLocaleDateString()}
                </span>
              )}
            </div>
          </div>
        </>
      )}
    </div>
  );
}

// Network switcher component
function NetworkSwitcher({
  currentNetwork,
  onSwitch,
  disabled,
}: {
  currentNetwork: NetworkType;
  onSwitch: (network: NetworkType) => Promise<void>;
  disabled: boolean;
}) {
  const networks: { value: NetworkType; label: string }[] = [
    { value: 'mainnet', label: 'Mainnet' },
    { value: 'testnet', label: 'Testnet' },
    { value: 'devnet', label: 'Devnet' },
    { value: 'localnet', label: 'Local' },
  ];

  return (
    <div className='flex items-center space-x-2'>
      <label className='text-sm font-medium text-gray-700'>Network:</label>
      <select
        value={currentNetwork}
        onChange={e => onSwitch(e.target.value as NetworkType)}
        disabled={disabled}
        className='px-3 py-1 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50'
      >
        {networks.map(({ value, label }) => (
          <option key={value} value={value}>
            {label}
          </option>
        ))}
      </select>
    </div>
  );
}

// Main TodoNFT management component
export default function BlockchainTodoManager() {
  const { connected, connecting, address } = useWalletContext();
  const { state, actions, network, isWalletReady } = useSuiTodos();

  const [showCreateForm, setShowCreateForm] = useState(false);

  if (!connected && !connecting) {
    return (
      <div className='max-w-4xl mx-auto p-6'>
        <div className='bg-yellow-50 border border-yellow-200 rounded-lg p-4 text-center'>
          <h2 className='text-xl font-semibold text-yellow-800 mb-2'>
            Wallet Connection Required
          </h2>
          <p className='text-yellow-700'>
            Please connect your wallet to manage TodoNFTs on the Sui blockchain.
          </p>
        </div>
      </div>
    );
  }

  if (connecting) {
    return (
      <div className='max-w-4xl mx-auto p-6'>
        <div className='bg-blue-50 border border-blue-200 rounded-lg p-4 text-center'>
          <h2 className='text-xl font-semibold text-blue-800 mb-2'>
            Connecting Wallet...
          </h2>
          <p className='text-blue-700'>
            Please check your wallet and approve the connection.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className='max-w-4xl mx-auto p-6 space-y-6'>
      {/* Header */}
      <div className='bg-white p-6 rounded-lg shadow-md'>
        <div className='flex justify-between items-center mb-4'>
          <h1 className='text-2xl font-bold text-gray-900'>TodoNFT Manager</h1>
          <NetworkSwitcher
            currentNetwork={network}
            onSwitch={actions.switchToNetwork}
            disabled={state.loading}
          />
        </div>

        <div className='flex justify-between items-center'>
          <div className='text-sm text-gray-600'>
            <p>
              Connected:{' '}
              <code className='bg-gray-100 px-2 py-1 rounded'>{address}</code>
            </p>
            <p>
              Network: {network} {state.networkHealth ? '' : ''}
            </p>
          </div>

          <div className='space-x-2'>
            <button
              onClick={() => setShowCreateForm(!showCreateForm)}
              className='bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors'
            >
              {showCreateForm ? 'Hide Form' : 'Create TodoNFT'}
            </button>
            <button
              onClick={actions.refreshTodos}
              disabled={state.refreshing}
              className='bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700 disabled:opacity-50 transition-colors'
            >
              {state.refreshing ? 'Refreshing...' : 'Refresh'}
            </button>
          </div>
        </div>
      </div>

      {/* Error Display */}
      {state.error && (
        <div className='bg-red-50 border border-red-200 rounded-lg p-4'>
          <div className='flex justify-between items-center'>
            <div>
              <h3 className='text-red-800 font-medium'>Error</h3>
              <p className='text-red-700'>{state.error}</p>
            </div>
            <button
              onClick={actions.clearError}
              className='text-red-600 hover:text-red-800'
            >
              Dismiss
            </button>
          </div>
        </div>
      )}

      {/* Create Form */}
      {showCreateForm && (
        <CreateTodoForm
          onSubmit={async params => {
            // Convert CreateTodoParams to hook's simpler format
            await actions.createTodo({
              title: params.title,
              description: params.description,
              priority: 'medium', // Default priority since CreateTodoParams doesn't have it
              dueDate: undefined, // Default dueDate since CreateTodoParams doesn't have it
            });
          }}
          loading={state.loading}
        />
      )}

      {/* Todo List */}
      <div className='space-y-4'>
        <h2 className='text-xl font-semibold text-gray-900'>
          Your TodoNFTs ({state.todos.length})
        </h2>

        {state.loading && state.todos.length === 0 ? (
          <div className='bg-gray-50 p-8 rounded-lg text-center'>
            <p className='text-gray-600'>Loading your TodoNFTs...</p>
          </div>
        ) : state.todos.length === 0 ? (
          <div className='bg-gray-50 p-8 rounded-lg text-center'>
            <p className='text-gray-600'>
              No TodoNFTs found. Create your first TodoNFT to get started!
            </p>
          </div>
        ) : (
          <div className='space-y-4'>
            {state.todos.map(todo => (
              <TodoItem
                key={todo.objectId}
                todo={todo}
                onUpdate={async params => {
                  await actions.updateTodo(params);
                }}
                onComplete={async objectId => {
                  await actions.completeTodo(objectId);
                }}
                onDelete={async objectId => {
                  await actions.deleteTodo(objectId);
                }}
                loading={state.loading}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/ClientOnly.tsx">
'use client';

import { useState, useEffect, ReactNode } from 'react';

interface ClientOnlyProps {
  children: ReactNode;
  fallback?: ReactNode;
}

/**
 * Component that only renders its children on the client, never during SSR
 * This prevents hydration errors for components that use browser-only APIs
 */
export function ClientOnly({ children, fallback = null }: ClientOnlyProps) {
  // State to track if we're mounted on the client
  const [mounted, setMounted] = useState(false);

  // Set mounted to true on client after hydration
  useEffect(() => {
    setMounted(true);
    return () => setMounted(false);
  }, []);

  // If we're not mounted yet, render nothing or fallback
  if (!mounted) {
    return fallback ? <div>{fallback}</div> : null;
  }

  // Render children only on client
  return <div>{children}</div>;
}
</file>

<file path="src/components/ClipboardErrorModal.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { ClipboardError, getClipboardCapabilities } from '@/lib/clipboard';

interface ClipboardErrorModalProps {
  error: ClipboardError | null;
  onDismiss: () => void;
  onTryAlternative?: () => void;
}

export function ClipboardErrorModal({
  error,
  onDismiss,
  onTryAlternative,
}: ClipboardErrorModalProps) {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (error) {
      setIsVisible(true);
    } else {
      setIsVisible(false);
    }
  }, [error]);

  if (!error || !isVisible) {
    return null;
  }

  const capabilities = getClipboardCapabilities();

  // Determine title and message based on error type
  const getErrorInfo = () => {
    const errorName = error.name;

    if (errorName === 'ClipboardApiNotSupportedError') {
      return {
        title: 'Clipboard Not Supported',
        message: 'Your browser does not support clipboard operations.',
        suggestion: capabilities.hasLegacySupport
          ? 'Try using keyboard shortcuts instead (Ctrl+C/Cmd+C)'
          : 'Try using a different browser with clipboard support.',
      };
    }

    if (errorName === 'ClipboardPermissionDeniedError') {
      return {
        title: 'Permission Denied',
        message: 'The browser denied permission to access the clipboard.',
        suggestion:
          'Try again after clicking somewhere on the page, or use keyboard shortcuts instead.',
      };
    }

    if (errorName === 'InsecureContextError') {
      return {
        title: 'Secure Context Required',
        message: 'Clipboard access requires a secure context (HTTPS).',
        suggestion: 'Try accessing this site over HTTPS instead.',
      };
    }

    if (errorName === 'ClipboardPolyfillError') {
      return {
        title: 'Clipboard Fallback Failed',
        message: 'The clipboard fallback mechanism failed.',
        suggestion: 'Try using keyboard shortcuts to copy text manually.',
      };
    }

    // Default case
    return {
      title: 'Clipboard Error',
      message:
        error.message || 'An error occurred while accessing the clipboard.',
      suggestion: 'Try using keyboard shortcuts instead (Ctrl+C/Cmd+C).',
    };
  };

  const { title, message, suggestion } = getErrorInfo();

  const handleDismiss = () => {
    setIsVisible(false);
    onDismiss();
  };

  return (
    <div className='fixed inset-0 flex items-center justify-center p-4 bg-black/50 z-50'>
      <div className='max-w-md w-full rounded-lg bg-white dark:bg-gray-800 shadow-lg overflow-hidden transform transition-all'>
        <div className='p-4'>
          <div className='flex items-start'>
            <div className='flex-shrink-0'>
              <svg
                className='w-6 h-6 text-yellow-400'
                fill='none'
                stroke='currentColor'
                viewBox='0 0 24 24'
              >
                <path
                  strokeLinecap='round'
                  strokeLinejoin='round'
                  strokeWidth={2}
                  d='M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z'
                />
              </svg>
            </div>
            <div className='ml-3 flex-1'>
              <h3 className='text-lg font-medium text-gray-900 dark:text-white'>
                {title}
              </h3>
              <div className='mt-2'>
                <p className='text-sm text-gray-700 dark:text-gray-300'>
                  {message}
                </p>
                {suggestion && (
                  <p className='text-sm text-gray-600 dark:text-gray-400 mt-2'>
                    <strong>Suggestion:</strong> {suggestion}
                  </p>
                )}
              </div>
              <div className='mt-4 flex justify-end space-x-3'>
                {onTryAlternative && (
                  <button
                    type='button'
                    onClick={() => {
                      handleDismiss();
                      onTryAlternative();
                    }}
                    className='inline-flex justify-center px-4 py-2 text-sm font-medium text-ocean-deep bg-ocean-light/30 rounded-md hover:bg-ocean-light/50 focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-ocean-light'
                  >
                    Try Alternative
                  </button>
                )}
                <button
                  type='button'
                  onClick={handleDismiss}
                  className='inline-flex justify-center px-4 py-2 text-sm font-medium text-white bg-ocean-medium rounded-md hover:bg-ocean-deep focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-ocean-light'
                >
                  Got it
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/context-warning.tsx">
'use client';

import { useEffect, useState } from 'react';
import safeStorage, {
  isBrowser,
  isUsingFallbackStorage,
} from '@/lib/safe-storage';

export function ContextWarning() {
  const [showWarning, setShowWarning] = useState(false);
  const [warnings, setWarnings] = useState<string[]>([]);

  useEffect(() => {
    // Only run in browser environment
    if (!isBrowser()) return;

    const detectedWarnings: string[] = [];

    // Check if storage is restricted
    if (isUsingFallbackStorage()) {
      detectedWarnings.push(
        'Storage access is restricted. Some features may not work properly.'
      );
    }

    // Check if in secure context - using safer approach
    try {
      if (!window.isSecureContext) {
        detectedWarnings.push(
          'This app is not running in a secure context (HTTPS). Some features like clipboard access may be limited.'
        );
      }
    } catch (e) {
      console.warn('Error checking for secure context:', e);
    }

    // Check if in iframe - using safer approach
    try {
      let isInIframe = false;
      try {
        isInIframe = window.self !== window.top;
      } catch (frameErr) {
        // If this errors, we're probably in a cross-origin iframe
        isInIframe = true;
      }

      if (isInIframe) {
        detectedWarnings.push(
          'This app is running in an iframe. Some features may be restricted.'
        );
      }
    } catch (e) {
      console.warn('Error checking for iframe context:', e);
    }

    if (detectedWarnings.length > 0) {
      setWarnings(detectedWarnings);
      setShowWarning(true);
    }
  }, []);

  // Return null during SSR and initial client-side render
  if (!showWarning || warnings.length === 0 || !isBrowser()) return null;

  return (
    <div className='fixed top-0 left-0 right-0 z-50 bg-yellow-50 dark:bg-yellow-900 border-b border-yellow-200 dark:border-yellow-700'>
      <div className='container mx-auto px-4 py-3'>
        <div className='flex items-start justify-between'>
          <div className='flex-1'>
            <p className='text-sm font-medium text-yellow-800 dark:text-yellow-200'>
              Security Context Warning
            </p>
            <ul className='mt-1 text-sm text-yellow-700 dark:text-yellow-300'>
              {warnings.map((warning, index) => (
                <li key={index} className='list-disc list-inside'>
                  {warning}
                </li>
              ))}
            </ul>
            <p className='mt-2 text-xs text-yellow-600 dark:text-yellow-400'>
              For the best experience, access this app via HTTPS at{' '}
              <code>https://localhost:3001</code> or deploy to a secure domain.
            </p>
          </div>
          <button
            onClick={() => setShowWarning(false)}
            className='ml-4 text-yellow-800 dark:text-yellow-200 hover:text-yellow-900 dark:hover:text-yellow-100'
            aria-label='Dismiss'
          >
            <svg
              className='w-5 h-5'
              fill='none'
              stroke='currentColor'
              viewBox='0 0 24 24'
            >
              <path
                strokeLinecap='round'
                strokeLinejoin='round'
                strokeWidth={2}
                d='M6 18L18 6M6 6l12 12'
              />
            </svg>
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/create-todo-form.tsx">
'use client';

import { useState } from 'react';
import { useWalletContext } from '@/contexts/WalletContext';
import { addTodo } from '@/lib/todo-service';
import { storeTodoOnBlockchain, initializeSuiClient } from '@/lib/sui-client';
import React, { useEffect } from 'react';

type CreateTodoFormProps = {
  listName: string;
  onTodoAdded?: () => void; // Callback to refresh the todo list
};

export default function CreateTodoForm({
  listName,
  onTodoAdded,
}: CreateTodoFormProps) {
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [priority, setPriority] = useState<'low' | 'medium' | 'high'>('medium');
  const [tags, setTags] = useState('');
  const [dueDate, setDueDate] = useState('');
  const [useAI, setUseAI] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isCreatingOnChain, setIsCreatingOnChain] = useState(false);
  const [createOnBlockchain, setCreateOnBlockchain] = useState(true); // Default to blockchain creation

  const { address, connected, signAndExecuteTransaction } = useWalletContext();

  // Initialize Sui client when component mounts
  useEffect(() => {
    try {
      initializeSuiClient('testnet');
    } catch (error) {
      console.warn('Sui client initialization:', error);
    }
  }, []);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!title.trim()) return;

    // Allow creating todos without wallet connection (local storage only)
    // if (!connected) {
    //   setError('Please connect your wallet to add todos')
    //   return
    // }

    setIsSubmitting(true);
    setError(null);

    try {
      // Create the todo object
      const todoData = {
        title: title.trim(),
        description: description.trim() || undefined,
        completed: false,
        priority,
        tags: tags
          ? tags
              .split(',')
              .map(tag => tag.trim())
              .filter(Boolean)
          : undefined,
        dueDate: dueDate || undefined,
      };

      let newTodo;

      // Always create local todo first
      newTodo = addTodo(listName, todoData, address || undefined);

      // Attempt blockchain creation only if explicitly requested and wallet is fully connected
      if (
        createOnBlockchain &&
        connected &&
        address &&
        signAndExecuteTransaction
      ) {
        setIsCreatingOnChain(true);

        try {
          const blockchainParams = {
            title: todoData.title,
            description: todoData.description || '',
            imageUrl: 'https://walrus-todo.vercel.app/images/todo-default.png', // Default image
            metadata: JSON.stringify({
              priority: todoData.priority,
              tags: todoData.tags,
              dueDate: todoData.dueDate,
              listName,
            }),
            isPrivate: false,
          };

          const blockchainResult = await storeTodoOnBlockchain(
            blockchainParams,
            signAndExecuteTransaction,
            address
          );

          if (
            blockchainResult.success &&
            newTodo &&
            blockchainResult.objectId
          ) {
            // Mark as blockchain stored after creation
            newTodo.blockchainStored = true;
            newTodo.objectId = blockchainResult.objectId;
            console.log(' Todo created on blockchain:', blockchainResult);
          }
        } catch (blockchainError) {
          console.warn(
            'Blockchain creation failed, but local todo was created:',
            blockchainError
          );
          // Don't throw - local todo creation succeeded
        }
      }

      // Reset form on success
      setTitle('');
      setDescription('');
      setPriority('medium');
      setTags('');
      setDueDate('');
      setUseAI(false);

      // Notify parent component to refresh
      onTodoAdded?.();

      console.log('Todo created successfully:', newTodo);

      // Show success message for blockchain creation
      if (createOnBlockchain && newTodo.blockchainStored) {
        // Could add a success toast here
        console.log(' Todo NFT created on Sui blockchain!');
      }
    } catch (error) {
      console.error('Failed to create todo:', error);
      setError('Failed to create todo. Please try again.');
    } finally {
      setIsSubmitting(false);
      setIsCreatingOnChain(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className='space-y-4'>
      {/* Error display */}
      {error && (
        <div className='bg-red-50 border border-red-200 rounded-lg p-3'>
          <p className='text-sm text-red-700'>{error}</p>
        </div>
      )}

      {/* Wallet connection warning */}
      {!connected && (
        <div className='bg-amber-50 border border-amber-200 rounded-lg p-3'>
          <p className='text-sm text-amber-700'>
            Connect your wallet to create and manage your personal todos
          </p>
        </div>
      )}

      <div>
        <input
          type='text'
          value={title}
          onChange={e => setTitle(e.target.value)}
          placeholder='What needs to be done?'
          className='ocean-input w-full'
          required
        />
      </div>

      <div>
        <textarea
          value={description}
          onChange={e => setDescription(e.target.value)}
          placeholder='Add a description (optional)'
          className='ocean-input w-full h-20 resize-none'
        />
      </div>

      <div className='grid grid-cols-1 md:grid-cols-3 gap-4'>
        <div>
          <label className='block text-sm text-ocean-medium dark:text-ocean-light mb-1'>
            Priority
          </label>
          <select
            value={priority}
            onChange={e =>
              setPriority(e.target.value as 'low' | 'medium' | 'high')
            }
            className='ocean-input w-full'
          >
            <option value='low'>Low</option>
            <option value='medium'>Medium</option>
            <option value='high'>High</option>
          </select>
        </div>

        <div>
          <label className='block text-sm text-ocean-medium dark:text-ocean-light mb-1'>
            Tags (comma separated)
          </label>
          <input
            type='text'
            value={tags}
            onChange={e => setTags(e.target.value)}
            placeholder='work, important, etc.'
            className='ocean-input w-full'
          />
        </div>

        <div>
          <label className='block text-sm text-ocean-medium dark:text-ocean-light mb-1'>
            Due Date (optional)
          </label>
          <input
            type='date'
            value={dueDate}
            onChange={e => setDueDate(e.target.value)}
            className='ocean-input w-full'
          />
        </div>
      </div>

      <div className='space-y-3'>
        <div className='flex items-center'>
          <input
            type='checkbox'
            id='useAI'
            checked={useAI}
            onChange={e => setUseAI(e.target.checked)}
            className='w-4 h-4 rounded text-ocean-medium focus:ring-ocean-light'
          />
          <label
            htmlFor='useAI'
            className='ml-2 text-sm text-ocean-medium dark:text-ocean-light'
          >
            Use AI to suggest tags and priority
          </label>
        </div>

        {connected && (
          <div className='flex items-center'>
            <input
              type='checkbox'
              id='createOnBlockchain'
              checked={createOnBlockchain}
              onChange={e => setCreateOnBlockchain(e.target.checked)}
              className='w-4 h-4 rounded text-ocean-medium focus:ring-ocean-light'
            />
            <label
              htmlFor='createOnBlockchain'
              className='ml-2 text-sm text-ocean-medium dark:text-ocean-light'
            >
              Create as NFT on Sui blockchain
              {isCreatingOnChain && (
                <span className='ml-2 text-xs text-blue-600 animate-pulse'>
                  Creating on-chain...
                </span>
              )}
            </label>
          </div>
        )}
      </div>

      <div className='flex justify-between items-center pt-2'>
        <div className='text-sm text-ocean-medium dark:text-ocean-light'>
          Adding to: <span className='font-medium'>{listName}</span>
        </div>

        <button
          type='submit'
          disabled={
            isSubmitting || !title.trim() || (createOnBlockchain && !connected)
          }
          className={`ocean-button ${
            isSubmitting || !title.trim() ? 'opacity-70 cursor-not-allowed' : ''
          }`}
        >
          {isSubmitting
            ? isCreatingOnChain
              ? 'Creating NFT...'
              : 'Adding...'
            : createOnBlockchain && !connected
              ? 'Connect Wallet for NFT'
              : createOnBlockchain && connected
                ? 'Create NFT Todo'
                : 'Add Todo'}
        </button>
      </div>
    </form>
  );
}
</file>

<file path="src/components/ErrorBoundary.tsx">
'use client';

import React, { ReactNode, useEffect, useState } from 'react';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

export function ErrorBoundary({ children, fallback }: ErrorBoundaryProps) {
  const [hasError, setHasError] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    // Only run in the browser
    if (typeof window === 'undefined') return;

    // Set up global error handler for uncaught errors
    const errorHandler = (event: ErrorEvent) => {
      console.error('[ErrorBoundary] Caught error:', event.error);

      // Special handling for storage access errors
      if (
        event.error?.message?.includes('Access to storage is not allowed') ||
        event.error?.message?.includes('localStorage') ||
        event.error?.message?.includes('sessionStorage')
      ) {
        console.warn(
          '[ErrorBoundary] Storage access error caught. Using in-memory fallback.'
        );
        // Don't set error state for these specific errors
        // They'll be handled by the storage utility's fallback

        // Still prevent default to stop error propagation
        event.preventDefault();
        return;
      }

      setError(
        event.error instanceof Error
          ? event.error
          : new Error(String(event.error))
      );
      setHasError(true);

      // Prevent the error from propagating
      event.preventDefault();
    };

    // Set up handler for unhandled promise rejections
    const rejectionHandler = (event: PromiseRejectionEvent) => {
      console.error('[ErrorBoundary] Unhandled rejection:', event.reason);

      // Special handling for storage access rejections
      const rejectionString = String(event.reason);
      if (
        rejectionString.includes('Access to storage is not allowed') ||
        rejectionString.includes('localStorage') ||
        rejectionString.includes('sessionStorage')
      ) {
        console.warn(
          '[ErrorBoundary] Storage access rejection caught. Using in-memory fallback.'
        );
        // Don't set error state for these specific errors

        // Still prevent default to stop error propagation
        event.preventDefault();
        return;
      }

      // Special handling for wallet errors that should not crash the app
      if (
        rejectionString.includes('select failed: wallet') ||
        rejectionString.includes('UNKNOWN_ERROR') ||
        rejectionString.includes('KIT.UNKNOWN_ERROR') ||
        rejectionString.includes('is not available') ||
        rejectionString.includes('wallet Slush') ||
        rejectionString.includes('all wallets are listed here: []') ||
        rejectionString.includes('Wallet Standard has already been loaded')
      ) {
        console.warn(
          '[ErrorBoundary] Wallet availability error suppressed. This is expected when wallets are not installed.'
        );
        // Don't set error state for wallet availability issues

        // Still prevent default to stop error propagation
        event.preventDefault();
        return;
      }

      // Only set error state for genuine errors that should show error UI
      setError(
        event.reason instanceof Error
          ? event.reason
          : new Error(String(event.reason))
      );
      setHasError(true);

      // Prevent the error from propagating
      event.preventDefault();
    };

    // Add event listeners
    window.addEventListener('error', errorHandler);
    window.addEventListener('unhandledrejection', rejectionHandler);

    // Clean up on unmount
    return () => {
      window.removeEventListener('error', errorHandler);
      window.removeEventListener('unhandledrejection', rejectionHandler);
    };
  }, []);

  // Reset error state
  const resetError = () => {
    setHasError(false);
    setError(null);
  };

  // Default fallback UI
  const defaultFallback = (
    <div className='p-4 border border-red-500 rounded bg-red-50 text-red-900 m-4'>
      <h2 className='text-lg font-bold mb-2'>Something went wrong</h2>
      <p className='mb-2'>{error?.message || 'An unexpected error occurred'}</p>
      {process.env.NODE_ENV !== 'production' && error?.stack && (
        <pre className='text-xs mt-2 p-2 bg-red-100 overflow-auto max-h-[200px]'>
          {error.stack}
        </pre>
      )}
      <button
        onClick={resetError}
        className='mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600'
      >
        Try Again
      </button>
    </div>
  );

  // Show the fallback UI if there's an error
  if (hasError) {
    return fallback || defaultFallback;
  }

  // Otherwise, render children normally
  return <div>{children}</div>;
}
</file>

<file path="src/components/ErrorHandlingProvider.tsx">
'use client';

import React, { ReactNode } from 'react';
import { StorageContextWarning } from './StorageContextWarning';
import { isUsingFallbackStorage } from '@/lib/storage-utils';

interface ErrorHandlingProviderProps {
  children: ReactNode;
}

/**
 * Global error handling provider that wraps the application
 * and provides warnings and fallbacks for common errors
 */
export function ErrorHandlingProvider({
  children,
}: ErrorHandlingProviderProps) {
  // Only show storage warning if fallback is in use
  const showStorageWarning = isUsingFallbackStorage();

  return (
    <div className='relative'>
      {/* Show storage context warning at the top of the app when needed */}
      {showStorageWarning && (
        <div className='sticky top-0 z-50 w-full'>
          <StorageContextWarning />
        </div>
      )}

      {/* Render the application */}
      {children}
    </div>
  );
}
</file>

<file path="src/components/ErrorSuppressor.tsx">
'use client';

import { useEffect } from 'react';

/**
 * Component that suppresses known wallet extension errors
 * This handles errors that occur at the Next.js/React level
 */
export function ErrorSuppressor() {
  useEffect(() => {
    // List of error patterns to suppress
    const suppressedPatterns = [
      'dApp.connect',
      'query #1',
      'query #2',
      'query #3',
      'dapp-interface.js',
      'opcgpfmipidbgpenhmajoajpbobppdil',
      'chrome-extension://',
      '[[ << query #',
      'Error: [[ << query #',
      'Invalid prop `type` supplied to `React.Fragment`',
      'React.Fragment can only have `key` and `children` props',
    ];

    // Store original error handler
    const originalErrorHandler = window.onerror;
    const originalUnhandledRejection = window.onunhandledrejection;

    // Override window.onerror
    window.onerror = (message, source, lineno, colno, error) => {
      const errorMessage = String(message);

      // Check if this error should be suppressed
      const shouldSuppress = suppressedPatterns.some(
        pattern =>
          errorMessage.includes(pattern) || (source && source.includes(pattern))
      );

      if (shouldSuppress) {
        // Prevent the error from being logged
        return true;
      }

      // Call original handler for genuine errors
      if (originalErrorHandler) {
        return originalErrorHandler.call(
          window,
          message,
          source,
          lineno,
          colno,
          error
        );
      }

      return false;
    };

    // Override unhandled promise rejection
    window.onunhandledrejection = event => {
      const errorMessage = String(event.reason);

      // Check if this error should be suppressed
      const shouldSuppress = suppressedPatterns.some(pattern =>
        errorMessage.includes(pattern)
      );

      if (shouldSuppress) {
        event.preventDefault();
        return;
      }

      // Call original handler for genuine errors
      if (originalUnhandledRejection) {
        return originalUnhandledRejection.call(window, event);
      }
    };

    // Override console.error to catch React/Next.js errors
    const originalConsoleError = console.error;
    console.error = (...args) => {
      const errorMessage = args.join(' ');

      // Check if this error should be suppressed
      const shouldSuppress = suppressedPatterns.some(pattern =>
        errorMessage.includes(pattern)
      );

      if (shouldSuppress) {
        // Silently suppress the error
        return;
      }

      // Call original console.error for genuine errors
      originalConsoleError.apply(console, args);
    };

    // Cleanup function
    return () => {
      window.onerror = originalErrorHandler;
      window.onunhandledrejection = originalUnhandledRejection;
      console.error = originalConsoleError;
    };
  }, []);

  // This component doesn't render anything
  return null;
}
</file>

<file path="src/components/navbar.tsx">
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { WalletConnectButton } from '@/components/WalletConnectButton';

type NavbarProps = {
  currentPage: string;
};

export default function Navbar({ currentPage }: NavbarProps) {
  const [isWalletModalOpen, setIsWalletModalOpen] = useState(false);

  return (
    <header className='py-4 mb-8'>
      <nav className='ocean-card flex justify-between items-center'>
        <div className='flex items-center gap-2'>
          <div className='w-10 h-10 rounded-full bg-gradient-to-br from-ocean-light to-dream-teal shadow-dreamy flex items-center justify-center text-lg text-white font-bold'>
            WT
          </div>
          <Link
            href='/'
            className='text-xl font-bold text-ocean-deep dark:text-ocean-foam'
          >
            Walrus Todo
          </Link>
        </div>

        <div className='hidden md:flex items-center space-x-6'>
          <Link
            href='/'
            className={`transition-colors ${
              currentPage === 'home'
                ? 'text-ocean-deep dark:text-ocean-foam font-medium'
                : 'text-ocean-medium dark:text-ocean-light hover:text-ocean-deep dark:hover:text-ocean-foam'
            }`}
          >
            Home
          </Link>
          <Link
            href='/dashboard'
            className={`transition-colors ${
              currentPage === 'dashboard'
                ? 'text-ocean-deep dark:text-ocean-foam font-medium'
                : 'text-ocean-medium dark:text-ocean-light hover:text-ocean-deep dark:hover:text-ocean-foam'
            }`}
          >
            Dashboard
          </Link>
          <Link
            href='/blockchain'
            className={`transition-colors ${
              currentPage === 'blockchain'
                ? 'text-ocean-deep dark:text-ocean-foam font-medium'
                : 'text-ocean-medium dark:text-ocean-light hover:text-ocean-deep dark:hover:text-ocean-foam'
            }`}
          >
            NFT Todos
          </Link>
        </div>

        <div>
          <WalletConnectButton />
        </div>
      </nav>
    </header>
  );
}
</file>

<file path="src/components/RealtimeTodoList.tsx">
/**
 * Enhanced TodoList component with real-time blockchain event updates
 * Automatically syncs with blockchain events and displays live updates
 */

'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { Todo } from '@/lib/sui-client';
import { useTodoStateSync, useTodoEvents } from '@/hooks/useBlockchainEvents';
import { useWalletContext } from '@/contexts/WalletContext';
import { BlockchainEventIndicator } from './BlockchainEventStatus';

interface RealtimeTodoListProps {
  initialTodos: Todo[];
  listName: string;
  onTodoUpdate?: (todos: Todo[]) => void;
  onTodoComplete?: (todo: Todo) => void;
  onTodoDelete?: (todoId: string) => void;
  className?: string;
  showEventIndicator?: boolean;
}

export function RealtimeTodoList({
  initialTodos,
  listName,
  onTodoUpdate,
  onTodoComplete,
  onTodoDelete,
  className = '',
  showEventIndicator = true,
}: RealtimeTodoListProps) {
  const { address, connected } = useWalletContext();
  const [todos, setTodos] = useState<Todo[]>(initialTodos);
  const [notifications, setNotifications] = useState<
    Array<{
      id: string;
      message: string;
      type: 'created' | 'updated' | 'completed' | 'deleted';
      timestamp: number;
    }>
  >([]);

  // Enable blockchain events for real-time updates
  const { syncedTodos, isConnected, connectionState } = useTodoStateSync({
    todos,
    onTodoChange: updatedTodos => {
      setTodos(updatedTodos);
      if (onTodoUpdate) {
        onTodoUpdate(updatedTodos);
      }
    },
    owner: address || undefined,
    autoStart: connected,
  });

  // Enable individual todo events for real-time notifications
  const { recentEvents } = useTodoEvents({
    owner: address || undefined,
    autoStart: connected,
    onTodoCreated: todo => {
      addNotification({
        id: `created-${todo.id}-${Date.now()}`,
        message: `New todo created: ${todo.title}`,
        type: 'created',
        timestamp: Date.now(),
      });
    },
    onTodoUpdated: todo => {
      addNotification({
        id: `updated-${todo.id}-${Date.now()}`,
        message: `Todo updated: ${todo.title || 'Unknown'}`,
        type: 'updated',
        timestamp: Date.now(),
      });
    },
    onTodoCompleted: todo => {
      addNotification({
        id: `completed-${todo.id}-${Date.now()}`,
        message: `Todo completed: ${todo.title || 'Unknown'}`,
        type: 'completed',
        timestamp: Date.now(),
      });
    },
    onTodoDeleted: todoId => {
      addNotification({
        id: `deleted-${todoId}-${Date.now()}`,
        message: `Todo deleted`,
        type: 'deleted',
        timestamp: Date.now(),
      });
    },
  });

  const addNotification = useCallback(
    (notification: (typeof notifications)[0]) => {
      setNotifications(prev => [notification, ...prev.slice(0, 4)]); // Keep last 5 notifications

      // Auto-remove notification after 5 seconds
      setTimeout(() => {
        setNotifications(prev => prev.filter(n => n.id !== notification.id));
      }, 5000);
    },
    []
  );

  const handleTodoComplete = useCallback(
    async (todo: Todo) => {
      if (onTodoComplete) {
        await onTodoComplete(todo);
      }
    },
    [onTodoComplete]
  );

  const handleTodoDelete = useCallback(
    async (todoId: string) => {
      if (onTodoDelete) {
        await onTodoDelete(todoId);
      }
    },
    [onTodoDelete]
  );

  // Update todos when initial todos change
  useEffect(() => {
    setTodos(initialTodos);
  }, [initialTodos]);

  const getNotificationIcon = (type: string) => {
    switch (type) {
      case 'created':
        return '';
      case 'updated':
        return '';
      case 'completed':
        return '';
      case 'deleted':
        return '';
      default:
        return '';
    }
  };

  const getNotificationColor = (type: string) => {
    switch (type) {
      case 'created':
        return 'bg-green-100 border-green-300 text-green-800';
      case 'updated':
        return 'bg-blue-100 border-blue-300 text-blue-800';
      case 'completed':
        return 'bg-purple-100 border-purple-300 text-purple-800';
      case 'deleted':
        return 'bg-red-100 border-red-300 text-red-800';
      default:
        return 'bg-gray-100 border-gray-300 text-gray-800';
    }
  };

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'high':
        return 'text-red-600 bg-red-50 border-red-200';
      case 'medium':
        return 'text-yellow-600 bg-yellow-50 border-yellow-200';
      case 'low':
        return 'text-green-600 bg-green-50 border-green-200';
      default:
        return 'text-gray-600 bg-gray-50 border-gray-200';
    }
  };

  if (!connected) {
    return (
      <div className={`text-center p-8 ${className}`}>
        <div className='bg-blue-50 border border-blue-200 rounded-lg p-4'>
          <p className='text-blue-800'>
            Connect your wallet to see real-time todo updates from the
            blockchain.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className={`relative ${className}`}>
      {/* Event connection status */}
      {showEventIndicator && (
        <div className='mb-4 flex justify-between items-center'>
          <h3 className='text-lg font-semibold text-gray-900 dark:text-gray-100'>
            {listName} Todos
          </h3>
          <div className='w-2 h-2 bg-blue-500 rounded-full' />
        </div>
      )}

      {/* Live notifications */}
      {notifications.length > 0 && (
        <div className='mb-4 space-y-2'>
          {notifications.map(notification => (
            <div
              key={notification.id}
              className={`flex items-center p-3 rounded-lg border ${getNotificationColor(notification.type)} transition-all duration-300`}
            >
              <span className='mr-2 text-lg'>
                {getNotificationIcon(notification.type)}
              </span>
              <span className='flex-1'>{notification.message}</span>
              <button
                onClick={() =>
                  setNotifications(prev =>
                    prev.filter(n => n.id !== notification.id)
                  )
                }
                className='ml-2 text-gray-500 hover:text-gray-700'
              >
                
              </button>
            </div>
          ))}
        </div>
      )}

      {/* Todo list */}
      <div className='space-y-3'>
        {todos.length === 0 ? (
          <div className='text-center p-8 bg-gray-50 dark:bg-gray-800 rounded-lg'>
            <p className='text-gray-600 dark:text-gray-400'>
              No todos found. Create your first todo to get started!
            </p>
          </div>
        ) : (
          todos.map(todo => (
            <div
              key={todo.id}
              className={`bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-4 transition-all duration-200 ${
                todo.completed ? 'opacity-60' : ''
              }`}
            >
              <div className='flex items-start justify-between'>
                <div className='flex-1'>
                  <div className='flex items-center space-x-2 mb-2'>
                    <input
                      type='checkbox'
                      checked={todo.completed}
                      onChange={() => handleTodoComplete(todo)}
                      className='h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded'
                    />
                    <h4
                      className={`font-medium ${
                        todo.completed
                          ? 'line-through text-gray-500 dark:text-gray-400'
                          : 'text-gray-900 dark:text-gray-100'
                      }`}
                    >
                      {todo.title}
                    </h4>
                    {todo.blockchainStored && (
                      <span className='inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800'>
                         On-chain
                      </span>
                    )}
                  </div>

                  {todo.description && (
                    <p className='text-sm text-gray-600 dark:text-gray-400 mb-2'>
                      {todo.description}
                    </p>
                  )}

                  <div className='flex items-center space-x-2 text-xs'>
                    <span
                      className={`inline-flex items-center px-2 py-1 rounded-full border ${getPriorityColor(todo.priority)}`}
                    >
                      {todo.priority}
                    </span>

                    {todo.tags && todo.tags.length > 0 && (
                      <div className='flex space-x-1'>
                        {todo.tags.map((tag, index) => (
                          <span
                            key={index}
                            className='inline-flex items-center px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800'
                          >
                            #{tag}
                          </span>
                        ))}
                      </div>
                    )}

                    {todo.dueDate && (
                      <span className='text-gray-500'>
                        Due: {new Date(todo.dueDate).toLocaleDateString()}
                      </span>
                    )}
                  </div>
                </div>

                <div className='flex items-center space-x-2 ml-4'>
                  {todo.objectId && (
                    <a
                      href={`https://suiexplorer.com/object/${todo.objectId}?network=${connectionState.connected ? 'testnet' : 'mainnet'}`}
                      target='_blank'
                      rel='noopener noreferrer'
                      className='text-blue-600 hover:text-blue-800 text-sm'
                      title='View on Sui Explorer'
                    >
                      
                    </a>
                  )}

                  <button
                    onClick={() => handleTodoDelete(todo.id)}
                    className='text-red-600 hover:text-red-800 text-sm'
                    title='Delete todo'
                  >
                    
                  </button>
                </div>
              </div>
            </div>
          ))
        )}
      </div>

      {/* Recent events debug info (dev mode) */}
      {process.env.NODE_ENV === 'development' && recentEvents.length > 0 && (
        <div className='mt-6 p-4 bg-gray-100 rounded-lg'>
          <h4 className='font-medium mb-2'>Recent Events (Dev Mode)</h4>
          <div className='space-y-1 text-xs'>
            {recentEvents.slice(0, 5).map((event, index) => (
              <div key={index} className='font-mono text-gray-600'>
                {event.type}: {JSON.stringify(event.data)}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/SessionTimeoutWarning.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { useWalletContext } from '@/contexts/WalletContext';

// Session timeout in milliseconds (30 minutes)
const SESSION_TIMEOUT = 30 * 60 * 1000;

// Warning threshold in milliseconds (5 minutes before timeout)
const WARNING_THRESHOLD = 5 * 60 * 1000;

export function SessionTimeoutWarning() {
  const { connected, lastActivity, resetActivityTimer } = useWalletContext();
  const [showWarning, setShowWarning] = useState(false);
  const [timeRemaining, setTimeRemaining] = useState<number>(0);

  useEffect(() => {
    if (!connected) {
      setShowWarning(false);
      return;
    }

    // Check every 30 seconds to see if we're approaching timeout
    const interval = setInterval(() => {
      const now = Date.now();
      const timeSinceLastActivity = now - lastActivity;
      const timeUntilTimeout = SESSION_TIMEOUT - timeSinceLastActivity;

      // If we're within the warning threshold, show the warning
      if (timeUntilTimeout <= WARNING_THRESHOLD && timeUntilTimeout > 0) {
        setShowWarning(true);
        setTimeRemaining(timeUntilTimeout);
      } else {
        setShowWarning(false);
      }
    }, 30000); // Check every 30 seconds

    return () => clearInterval(interval);
  }, [connected, lastActivity]);

  // Update countdown timer every second when warning is shown
  useEffect(() => {
    if (!showWarning) return;

    const timer = setInterval(() => {
      const now = Date.now();
      const timeSinceLastActivity = now - lastActivity;
      const timeUntilTimeout = SESSION_TIMEOUT - timeSinceLastActivity;

      if (timeUntilTimeout <= 0) {
        setShowWarning(false);
        clearInterval(timer);
      } else {
        setTimeRemaining(timeUntilTimeout);
      }
    }, 1000);

    return () => clearInterval(timer);
  }, [showWarning, lastActivity]);

  // Format time remaining in minutes and seconds
  const formatTimeRemaining = () => {
    const minutes = Math.floor(timeRemaining / 60000);
    const seconds = Math.floor((timeRemaining % 60000) / 1000);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  // Stay active button handler
  const handleStayActive = () => {
    resetActivityTimer();
    setShowWarning(false);
  };

  if (!showWarning) return null;

  return (
    <div className='fixed bottom-4 right-4 w-80 bg-white dark:bg-slate-800 shadow-lg rounded-lg overflow-hidden border border-yellow-500 z-50'>
      <div className='bg-yellow-100 dark:bg-yellow-900/30 px-4 py-2 flex items-center gap-2'>
        <svg
          className='w-5 h-5 text-yellow-600 dark:text-yellow-500'
          fill='none'
          stroke='currentColor'
          viewBox='0 0 24 24'
        >
          <path
            strokeLinecap='round'
            strokeLinejoin='round'
            strokeWidth={2}
            d='M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z'
          />
        </svg>
        <h3 className='font-medium text-yellow-800 dark:text-yellow-200'>
          Session Timeout Warning
        </h3>
      </div>
      <div className='p-4'>
        <p className='text-sm text-gray-700 dark:text-gray-300 mb-3'>
          Your wallet session will expire in{' '}
          <span className='font-bold'>{formatTimeRemaining()}</span> due to
          inactivity.
        </p>
        <div className='mt-3 flex justify-between'>
          <button
            onClick={handleStayActive}
            className='px-4 py-2 bg-ocean-deep text-white text-sm rounded hover:bg-ocean-deep/80 transition-colors'
          >
            Stay Active
          </button>
          <button
            onClick={() => setShowWarning(false)}
            className='px-4 py-2 bg-transparent text-gray-500 text-sm hover:text-gray-700 transition-colors'
          >
            Dismiss
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/StorageContextWarning.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import safeStorage, {
  isBrowser,
  isUsingFallbackStorage,
} from '@/lib/safe-storage';

// Define context types for storage environments
type StorageContext =
  | 'browser' // Standard browser context with storage access
  | 'extension' // Browser extension context
  | 'iframe' // Embedded in an iframe
  | 'insecure' // Non-HTTPS context with restricted features
  | 'incognito' // Private/incognito browsing mode
  | 'server' // Server-side rendering context
  | 'hydrating' // During hydration phase of React
  | 'unknown'; // Context could not be determined

interface WarningMessageProps {
  context: StorageContext;
  usingFallback: boolean;
}

const WarningMessage: React.FC<WarningMessageProps> = ({
  context,
  usingFallback,
}) => {
  if (!usingFallback) return null;

  const getMessageForContext = (): { title: string; message: string } => {
    switch (context) {
      case 'extension':
        return {
          title: 'Extension Storage Mode',
          message:
            'Your data will not persist between sessions in this extension context.',
        };
      case 'iframe':
        return {
          title: 'Restricted Storage',
          message:
            'This app is running in an iframe with limited storage access. Your data will not persist.',
        };
      case 'incognito':
        return {
          title: 'Private Browsing Detected',
          message:
            'In private/incognito mode, data will not persist between sessions.',
        };
      case 'insecure':
        return {
          title: 'Non-Secure Context',
          message:
            'For full functionality including persistent storage, please use HTTPS.',
        };
      case 'server':
        return {
          title: 'Server Rendering',
          message: 'Storage is not available during server rendering.',
        };
      case 'hydrating':
        return {
          title: 'App is Initializing',
          message:
            'Storage access is temporarily restricted during app initialization.',
        };
      default:
        return {
          title: 'Limited Storage Access',
          message:
            'Your preferences and data will not persist between sessions.',
        };
    }
  };

  const { title, message } = getMessageForContext();

  return (
    <div className='p-2 border-l-4 border-yellow-500 bg-yellow-50 dark:bg-yellow-900/20 dark:text-yellow-100 rounded mb-4'>
      <h4 className='font-medium text-yellow-800 dark:text-yellow-200'>
        {title}
      </h4>
      <p className='text-sm text-yellow-700 dark:text-yellow-300'>{message}</p>
    </div>
  );
};

// Helper function to detect current context
function detectStorageContext(): StorageContext {
  // Check for server-side rendering
  if (!isBrowser()) {
    return 'server';
  }

  // Check for hydration phase
  if (typeof document !== 'undefined' && document.readyState === 'loading') {
    return 'hydrating';
  }

  // Safe check for extension context
  try {
    if (
      typeof (window as any).chrome !== 'undefined' &&
      (window as any).chrome.storage
    ) {
      return 'extension';
    }
  } catch (e) {
    console.warn('Error checking for extension context:', e);
  }

  // Safe check for iframe
  try {
    if (window.top !== window.self) {
      return 'iframe';
    }
  } catch (e) {
    // If this errors, we're probably in a cross-origin iframe
    console.warn('Error checking for iframe context:', e);
    return 'iframe'; // Assume iframe with restrictions
  }

  // Check for insecure context (non-HTTPS except localhost)
  try {
    if (!window.isSecureContext) {
      return 'insecure';
    }
  } catch (e) {
    console.warn('Error checking for secure context:', e);
  }

  // Check for incognito/private mode or storage restrictions
  try {
    const testKey = '__storage_test__';
    localStorage.setItem(testKey, testKey);
    localStorage.removeItem(testKey);
    sessionStorage.setItem(testKey, testKey);
    sessionStorage.removeItem(testKey);
    return 'browser';
  } catch (e) {
    // If storage test fails but browser isn't otherwise identified as a specific context
    return 'incognito';
  }
}

export function StorageContextWarning() {
  const [context, setContext] = useState<StorageContext>('unknown');
  const [usingFallback, setUsingFallback] = useState(false);
  const [showWarning, setShowWarning] = useState(true);
  const [mounted, setMounted] = useState(false);

  // Use two-phase mounting to ensure complete client-side initialization
  useEffect(() => {
    // First phase - mark component as mounted
    setMounted(true);

    // Cleanup function to handle component unmounting
    return () => setMounted(false);
  }, []);

  // Second phase - only run detection logic after initial mount
  useEffect(() => {
    // Skip if not mounted or not in browser
    if (!mounted || !isBrowser()) return;

    // Use setTimeout with a delay to ensure this runs after Next.js hydration is complete
    const timer = setTimeout(() => {
      try {
        // Safely detect context with error handling
        let detectedContext: StorageContext = 'unknown';
        try {
          detectedContext = detectStorageContext();
        } catch (error) {
          console.warn('Error detecting storage context:', error);
          detectedContext = 'unknown';
        }
        setContext(detectedContext);

        // Safely check if using fallback storage
        let fallbackStatus = true; // Default to true for safety
        try {
          fallbackStatus = isUsingFallbackStorage();
        } catch (error) {
          console.warn('Error checking fallback storage status:', error);
        }
        setUsingFallback(fallbackStatus);
      } catch (e) {
        console.error('Error in StorageContextWarning useEffect:', e);
        // Set safe defaults
        setContext('unknown');
        setUsingFallback(true);
      }
    }, 100); // Short delay to ensure hydration is complete

    return () => clearTimeout(timer);
  }, [mounted]);

  // Only render on client side after mounting
  if (!mounted || !isBrowser() || !showWarning) {
    // Return null during SSR and initial client-side render
    return null;
  }

  // Only render the component content after mounting
  return (
    <div className='relative'>
      <WarningMessage context={context} usingFallback={usingFallback} />
      {usingFallback && (
        <button
          onClick={() => setShowWarning(false)}
          className='absolute top-2 right-2 text-yellow-700 dark:text-yellow-300 hover:text-yellow-900 dark:hover:text-yellow-100'
          aria-label='Dismiss'
        >
          <svg className='w-4 h-4' viewBox='0 0 20 20' fill='currentColor'>
            <path
              fillRule='evenodd'
              d='M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z'
              clipRule='evenodd'
            />
          </svg>
        </button>
      )}
    </div>
  );
}
</file>

<file path="src/components/todo-list.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Todo } from '@/lib/sui-client';
// import { useTodoStateSync } from '@/hooks/useBlockchainEvents'
// import { BlockchainEventIndicator } from './BlockchainEventStatus'
import { useWalletContext } from '@/contexts/WalletContext';
import { getTodos, updateTodo } from '@/lib/todo-service';
import {
  getTodosFromBlockchain,
  completeTodoOnBlockchain,
  deleteTodoOnBlockchain,
  initializeSuiClient,
} from '@/lib/sui-client';

type TodoListProps = {
  listName: string;
};

export default function TodoList({ listName }: TodoListProps) {
  const [todos, setTodos] = useState<Todo[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [blockchainTodos, setBlockchainTodos] = useState<Todo[]>([]);
  const [loadingBlockchain, setLoadingBlockchain] = useState(false);
  const { address, connected, signAndExecuteTransaction } = useWalletContext();

  // Disable blockchain events to prevent console spam
  // const { syncedTodos, isConnected: eventsConnected } = useTodoStateSync({
  //   todos,
  //   onTodoChange: (updatedTodos) => {
  //     setTodos(updatedTodos)
  //   },
  //   owner: address || undefined,
  //   autoStart: connected,
  // })
  const eventsConnected = false;

  // Load blockchain todos when wallet is connected
  const loadBlockchainTodos = useCallback(async () => {
    if (!connected || !address) {
      setBlockchainTodos([]);
      return;
    }

    setLoadingBlockchain(true);
    try {
      // Initialize Sui client
      try {
        initializeSuiClient('testnet');
      } catch (e) {
        console.warn('Sui client already initialized');
      }

      // Fetch todos from blockchain
      const fetchedTodos = await getTodosFromBlockchain(address);
      setBlockchainTodos(fetchedTodos);
    } catch (error) {
      console.error('Failed to load blockchain todos:', error);
      setBlockchainTodos([]);
    } finally {
      setLoadingBlockchain(false);
    }
  }, [connected, address]); // useCallback dependencies

  // Load initial todos from local storage for the connected wallet
  useEffect(() => {
    const loadTodos = async () => {
      setIsLoading(true);
      try {
        // Load wallet-specific todos from local storage
        const localTodos = getTodos(listName, address || undefined);
        setTodos(localTodos);

        // Also load blockchain todos if wallet is connected
        if (connected && address) {
          await loadBlockchainTodos();
        }
      } catch (error) {
        console.error('Failed to load todos:', error);
        // Fallback to empty array
        setTodos([]);
      } finally {
        setIsLoading(false);
      }
    };

    loadTodos();
  }, [listName, address, connected, loadBlockchainTodos]); // Re-load when wallet address changes

  // Merge local and blockchain todos, prioritizing blockchain todos
  const mergedTodos = [...todos, ...blockchainTodos].reduce(
    (acc: Todo[], todo) => {
      // Remove duplicates based on objectId (blockchain todos take precedence)
      const existing = acc.find(
        t => t.objectId && t.objectId === todo.objectId
      );
      if (!existing) {
        acc.push(todo);
      } else if (todo.blockchainStored && !existing.blockchainStored) {
        // Replace local todo with blockchain version
        const index = acc.indexOf(existing);
        acc[index] = todo;
      }
      return acc;
    },
    []
  );

  // Use merged todos since blockchain events are disabled
  const displayTodos = mergedTodos;

  const toggleTodoCompletion = async (id: string) => {
    const todo = displayTodos.find(t => t.id === id);
    if (!todo) return;

    // Update local state immediately for optimistic UI
    const updatedTodos = displayTodos.map(todoItem =>
      todoItem.id === id
        ? {
            ...todoItem,
            completed: !todoItem.completed,
            completedAt: !todoItem.completed ? Date.now() : undefined,
          }
        : todoItem
    );
    setTodos(updatedTodos);

    try {
      if (todo.blockchainStored && todo.objectId && signAndExecuteTransaction) {
        // Complete todo on blockchain
        console.log('Completing todo on blockchain:', todo.objectId);
        const result = await completeTodoOnBlockchain(
          todo.objectId,
          signAndExecuteTransaction,
          address || ''
        );

        if (result.success) {
          console.log(' Todo completed on blockchain:', result.digest);
          // Refresh blockchain todos to get updated state
          await loadBlockchainTodos();
        } else {
          throw new Error(
            result.error || 'Failed to complete todo on blockchain'
          );
        }
      } else {
        // Update in wallet-specific local storage
        const updatedTodo = {
          ...todo,
          completed: !todo.completed,
          completedAt: !todo.completed ? Date.now() : undefined,
        };
        const success = updateTodo(listName, updatedTodo, address || undefined);

        if (!success) {
          console.error('Failed to update todo in storage');
          // Revert optimistic update by reloading from storage
          const localTodos = getTodos(listName, address || undefined);
          setTodos(localTodos);
        }
      }
    } catch (error) {
      console.error('Failed to toggle todo completion:', error);
      // Revert optimistic update by reloading from storage and blockchain
      const localTodos = getTodos(listName, address || undefined);
      setTodos(localTodos);
      if (connected && address) {
        await loadBlockchainTodos();
      }
    }
  };

  if (isLoading) {
    return (
      <div className='flex justify-center py-12'>
        <div className='w-12 h-12 rounded-full border-4 border-ocean-light border-t-ocean-deep animate-spin'></div>
      </div>
    );
  }

  if (displayTodos.length === 0) {
    return (
      <div className='text-center py-12'>
        <p className='text-ocean-medium dark:text-ocean-light mb-4'>
          No todos in this list yet.
        </p>
        <p className='text-sm text-ocean-medium/70 dark:text-ocean-light/70'>
          Create your first todo using the form above!
        </p>
        {connected && (
          <div className='mt-4'>
            <div className='flex items-center space-x-2'>
              <div className='w-2 h-2 bg-blue-500 rounded-full' />
              <span className='text-xs text-ocean-medium/70'>
                Blockchain Connected
              </span>
            </div>
            <p className='text-xs text-ocean-medium/50 dark:text-ocean-light/50 mt-2'>
              Blockchain integration active
            </p>
            {loadingBlockchain && (
              <p className='text-xs text-blue-600 dark:text-blue-400 mt-1 animate-pulse'>
                Loading blockchain todos...
              </p>
            )}
          </div>
        )}
      </div>
    );
  }

  // Handle storing local todo on blockchain
  const handleStoreOnBlockchain = async (todo: Todo) => {
    if (!connected || !address || !signAndExecuteTransaction) return;

    try {
      console.log('Storing todo on blockchain:', todo.title);
      // This would create an NFT version of the local todo
      // Implementation would involve calling storeTodoOnBlockchain
      // For now, just show a placeholder
      alert(
        'Feature coming soon: Store existing todo as NFT on Sui blockchain'
      );
    } catch (error) {
      console.error('Failed to store todo on blockchain:', error);
    }
  };

  // Handle deleting todo (local or blockchain)
  const handleDeleteTodo = async (todo: Todo) => {
    if (!confirm(`Are you sure you want to delete "${todo.title}"?`)) return;

    try {
      if (todo.blockchainStored && todo.objectId && signAndExecuteTransaction) {
        // Delete from blockchain
        console.log('Deleting todo from blockchain:', todo.objectId);
        const result = await deleteTodoOnBlockchain(
          todo.objectId,
          signAndExecuteTransaction,
          address || ''
        );

        if (result.success) {
          console.log(' Todo deleted from blockchain:', result.digest);
          // Refresh blockchain todos
          await loadBlockchainTodos();
        } else {
          throw new Error(
            result.error || 'Failed to delete todo from blockchain'
          );
        }
      } else {
        // Delete from local storage
        const updatedTodos = todos.filter(t => t.id !== todo.id);
        setTodos(updatedTodos);
        // Update storage would happen here
      }
    } catch (error) {
      console.error('Failed to delete todo:', error);
      alert('Failed to delete todo. Please try again.');
    }
  };

  return (
    <div className='space-y-4'>
      {/* Event connection indicator - temporarily disabled */}
      {connected && (
        <div className='flex items-center justify-between mb-4 p-3 bg-white/30 dark:bg-ocean-deep/30 rounded-lg border border-ocean-light/20'>
          <div className='flex items-center space-x-2'>
            <div className='w-2 h-2 bg-blue-500 rounded-full' />
            <span className='text-sm text-ocean-medium dark:text-ocean-light'>
              Blockchain integration active
            </span>
          </div>
          <div className='text-xs text-ocean-medium/70 dark:text-ocean-light/70'>
            {displayTodos.length} todos
          </div>
        </div>
      )}

      {displayTodos.map(todo => (
        <div
          key={todo.id}
          data-testid='todo-item'
          className={`p-4 rounded-lg transition-all ${
            todo.completed
              ? 'bg-green-50/50 dark:bg-green-900/30 border border-green-200 dark:border-green-800/50'
              : 'bg-white/50 dark:bg-ocean-deep/30 border border-ocean-light/20'
          }`}
        >
          <div className='flex items-start gap-3'>
            <button
              onClick={() => toggleTodoCompletion(todo.id)}
              data-testid='todo-checkbox'
              className={`mt-1 w-5 h-5 rounded-full flex-shrink-0 ${
                todo.completed
                  ? 'bg-green-500 text-white flex items-center justify-center'
                  : 'border-2 border-ocean-medium'
              }`}
            >
              {todo.completed && (
                <svg
                  xmlns='http://www.w3.org/2000/svg'
                  viewBox='0 0 20 20'
                  fill='currentColor'
                  className='w-3 h-3'
                >
                  <path
                    fillRule='evenodd'
                    d='M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z'
                    clipRule='evenodd'
                  />
                </svg>
              )}
            </button>

            <div className='flex-grow'>
              <div className='flex items-start justify-between'>
                <h3
                  data-testid='todo-title'
                  className={`font-medium ${todo.completed ? 'line-through text-ocean-medium/70 dark:text-ocean-light/70 completed' : 'text-ocean-deep dark:text-ocean-foam'}`}
                >
                  {todo.title}
                </h3>

                <div className='flex items-center gap-2'>
                  {todo.blockchainStored && (
                    <span className='flex items-center text-xs bg-dream-purple/20 text-dream-purple px-2 py-0.5 rounded-full'>
                      <span className='w-1.5 h-1.5 bg-dream-purple rounded-full mr-1'></span>
                      NFT
                    </span>
                  )}

                  {todo.objectId && (
                    <a
                      href={`https://suiexplorer.com/object/${todo.objectId}?network=testnet`}
                      target='_blank'
                      rel='noopener noreferrer'
                      className='text-xs text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam transition-colors'
                      title='View on Sui Explorer'
                    >
                      
                    </a>
                  )}

                  <span
                    className={`text-xs px-2 py-0.5 rounded-full ${
                      todo.priority === 'high'
                        ? 'bg-red-100 text-red-600 dark:bg-red-900/30 dark:text-red-300'
                        : todo.priority === 'medium'
                          ? 'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-300'
                          : 'bg-blue-100 text-blue-600 dark:bg-blue-900/30 dark:text-blue-300'
                    }`}
                  >
                    {todo.priority}
                  </span>
                </div>
              </div>

              {todo.description && (
                <p className='mt-1 text-sm text-ocean-medium dark:text-ocean-light/80'>
                  {todo.description}
                </p>
              )}

              <div className='mt-2 flex flex-wrap items-center gap-2'>
                {todo.tags &&
                  todo.tags.map(tag => (
                    <span
                      key={tag}
                      className='text-xs bg-ocean-light/30 dark:bg-ocean-medium/30 text-ocean-deep dark:text-ocean-foam px-2 py-0.5 rounded-full'
                    >
                      #{tag}
                    </span>
                  ))}

                {todo.dueDate && (
                  <span className='text-xs text-ocean-medium dark:text-ocean-light flex items-center'>
                    <svg
                      xmlns='http://www.w3.org/2000/svg'
                      className='h-3 w-3 mr-1'
                      fill='none'
                      viewBox='0 0 24 24'
                      stroke='currentColor'
                    >
                      <path
                        strokeLinecap='round'
                        strokeLinejoin='round'
                        strokeWidth={2}
                        d='M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z'
                      />
                    </svg>
                    Due: {todo.dueDate}
                  </span>
                )}

                {todo.blockchainStored && (
                  <span className='text-xs text-purple-600 dark:text-purple-400 flex items-center'>
                     On-chain todo
                  </span>
                )}
              </div>
            </div>
          </div>

          <div className='mt-3 pt-3 border-t border-ocean-light/20 dark:border-ocean-medium/20 flex justify-end gap-2'>
            <button className='text-xs text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam transition-colors'>
              Edit
            </button>
            {!todo.blockchainStored && connected && (
              <button
                onClick={() => handleStoreOnBlockchain(todo)}
                className='text-xs text-purple-600 hover:text-purple-800 dark:text-purple-400 dark:hover:text-purple-300 transition-colors'
              >
                Store as NFT
              </button>
            )}
            <button
              onClick={() => handleDeleteTodo(todo)}
              className='text-xs text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 transition-colors'
            >
              Delete
            </button>
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src/components/TransactionHistory.tsx">
'use client';

import React, { useState } from 'react';
import { useWalletContext } from '@/contexts/WalletContext';
import type { TransactionRecord } from '@/contexts/WalletContext';

interface TransactionHistoryProps {
  maxItems?: number;
}

export function TransactionHistory({ maxItems = 5 }: TransactionHistoryProps) {
  const { transactions } = useWalletContext();
  const [expanded, setExpanded] = useState(false);

  // Get transactions to display based on expanded state and maxItems
  const displayTransactions = expanded
    ? transactions
    : transactions.slice(0, maxItems);

  if (transactions.length === 0) {
    return (
      <div className='p-4 ocean-card'>
        <p className='text-ocean-medium dark:text-ocean-light text-sm'>
          No transactions yet
        </p>
      </div>
    );
  }

  // Format relative time using Intl.RelativeTimeFormat
  const formatRelativeTime = (timestamp: number) => {
    if (typeof Intl === 'undefined' || !Intl.RelativeTimeFormat) {
      // Fallback for environments without Intl.RelativeTimeFormat
      return formatRelativeTimeFallback(timestamp);
    }

    const now = Date.now();
    const diffSeconds = Math.floor((now - timestamp) / 1000);

    const rtf = new Intl.RelativeTimeFormat('en', { numeric: 'auto' });

    if (diffSeconds < 60) {
      return rtf.format(-diffSeconds, 'second');
    }

    const diffMinutes = Math.floor(diffSeconds / 60);
    if (diffMinutes < 60) {
      return rtf.format(-diffMinutes, 'minute');
    }

    const diffHours = Math.floor(diffMinutes / 60);
    if (diffHours < 24) {
      return rtf.format(-diffHours, 'hour');
    }

    const diffDays = Math.floor(diffHours / 24);
    return rtf.format(-diffDays, 'day');
  };

  // Fallback formatter for environments without Intl.RelativeTimeFormat
  const formatRelativeTimeFallback = (timestamp: number) => {
    const now = Date.now();
    const diffSeconds = Math.floor((now - timestamp) / 1000);

    if (diffSeconds < 60) {
      return `${diffSeconds} seconds ago`;
    }

    const diffMinutes = Math.floor(diffSeconds / 60);
    if (diffMinutes < 60) {
      return `${diffMinutes} minute${diffMinutes !== 1 ? 's' : ''} ago`;
    }

    const diffHours = Math.floor(diffMinutes / 60);
    if (diffHours < 24) {
      return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
    }

    const diffDays = Math.floor(diffHours / 24);
    return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
  };

  // Get status icon based on transaction status
  const getStatusIcon = (status: 'pending' | 'success' | 'error') => {
    switch (status) {
      case 'pending':
        return (
          <div
            className='w-4 h-4 bg-yellow-400 rounded-full animate-pulse'
            title='Pending transaction'
          ></div>
        );
      case 'success':
        return (
          <svg
            className='w-4 h-4 text-green-500'
            fill='none'
            stroke='currentColor'
            viewBox='0 0 24 24'
          >
            <path
              strokeLinecap='round'
              strokeLinejoin='round'
              strokeWidth={2}
              d='M5 13l4 4L19 7'
            />
          </svg>
        );
      case 'error':
        return (
          <svg
            className='w-4 h-4 text-red-500'
            fill='none'
            stroke='currentColor'
            viewBox='0 0 24 24'
          >
            <path
              strokeLinecap='round'
              strokeLinejoin='round'
              strokeWidth={2}
              d='M6 18L18 6M6 6l12 12'
            />
          </svg>
        );
    }
  };

  // Render a single transaction row
  const renderTransaction = (tx: TransactionRecord) => {
    return (
      <div
        key={tx.id}
        className='border-b border-ocean-light/20 last:border-0 py-3 flex items-center gap-3'
      >
        <div className='flex-shrink-0'>{getStatusIcon(tx.status)}</div>
        <div className='flex-1 min-w-0'>
          <div className='flex justify-between'>
            <p className='text-sm font-medium truncate'>
              {tx.type}
              {tx.hash && (
                <span className='ml-2 text-xs text-ocean-medium dark:text-ocean-light truncate'>
                  {tx.hash.slice(0, 8)}...{tx.hash.slice(-6)}
                </span>
              )}
            </p>
            <p className='text-xs text-ocean-medium dark:text-ocean-light ml-2'>
              {formatRelativeTime(tx.timestamp)}
            </p>
          </div>
          {tx.status === 'error' && tx.message && (
            <p className='text-xs text-red-500 mt-1 truncate'>{tx.message}</p>
          )}
        </div>
      </div>
    );
  };

  return (
    <div className='rounded-lg overflow-hidden bg-white dark:bg-slate-800 shadow-sm border border-ocean-light/20'>
      <div className='bg-ocean-light/10 dark:bg-ocean-deep/20 px-4 py-2 flex justify-between items-center'>
        <h3 className='font-medium text-sm text-ocean-deep dark:text-ocean-foam'>
          Transaction History
        </h3>
        {transactions.length > maxItems && (
          <button
            onClick={() => setExpanded(!expanded)}
            className='text-xs text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam'
          >
            {expanded ? 'Show less' : `Show all (${transactions.length})`}
          </button>
        )}
      </div>
      <div className='px-4 py-2 divide-y divide-ocean-light/10'>
        {displayTransactions.map(renderTransaction)}
      </div>
    </div>
  );
}
</file>

<file path="src/components/TransactionSigner.tsx">
'use client';

import React, { useState } from 'react';
import { useWalletContext } from '@/contexts/WalletContext';

interface TransactionSignerProps {
  transactionData: any;
  onSuccess?: (result: any) => void;
  onError?: (error: Error) => void;
  children?: (props: {
    isLoading: boolean;
    error: Error | null;
    signAndExecute: () => Promise<void>;
  }) => React.ReactNode;
}

export function TransactionSigner({
  transactionData,
  onSuccess,
  onError,
  children,
}: TransactionSignerProps) {
  const { connected, signAndExecuteTransaction, trackTransaction } =
    useWalletContext();

  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const signAndExecute = async () => {
    if (!connected || !signAndExecuteTransaction) {
      const err = new Error(
        "Wallet not connected or doesn't support transaction signing"
      );
      setError(err);
      onError?.(err);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      // Sign and execute the transaction
      const result = await signAndExecuteTransaction(transactionData);

      // Track the transaction if trackTransaction is available
      if (trackTransaction) {
        await trackTransaction(Promise.resolve(result), 'Custom Transaction');
      }

      onSuccess?.(result);
    } catch (err) {
      const error =
        err instanceof Error ? err : new Error('Transaction failed');
      setError(error);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  };

  // If children function is provided, use render props pattern
  if (children) {
    return children({ isLoading, error, signAndExecute }) as React.ReactElement;
  }

  // Default UI
  return (
    <div className='space-y-4'>
      {error && (
        <div className='p-4 bg-red-50 border border-red-200 rounded-lg'>
          <p className='text-red-800 font-medium'>Transaction Error</p>
          <p className='text-red-600 text-sm'>{error.message}</p>
        </div>
      )}

      <button
        onClick={signAndExecute}
        disabled={!connected || isLoading}
        className='px-4 py-2 bg-ocean-deep text-white rounded-lg hover:bg-ocean-deep/80 disabled:bg-gray-400 disabled:cursor-not-allowed flex items-center gap-2'
      >
        {isLoading && (
          <svg
            className='animate-spin h-4 w-4'
            xmlns='http://www.w3.org/2000/svg'
            fill='none'
            viewBox='0 0 24 24'
          >
            <circle
              className='opacity-25'
              cx='12'
              cy='12'
              r='10'
              stroke='currentColor'
              strokeWidth='4'
            ></circle>
            <path
              className='opacity-75'
              fill='currentColor'
              d='M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z'
            ></path>
          </svg>
        )}
        {isLoading ? 'Signing...' : 'Sign Transaction'}
      </button>
    </div>
  );
}
</file>

<file path="src/components/WalletConnectButton.tsx">
'use client';

import React, { useState } from 'react';
import { useWalletContext } from '@/contexts/WalletContext';
import {
  copyToClipboard,
  getClipboardCapabilities,
  ClipboardError,
} from '@/lib/clipboard';
import { WalletErrorModal } from './WalletErrorModal';
import { ClipboardErrorModal } from './ClipboardErrorModal';
import { WalletError } from '@/lib/wallet-errors';
import { ErrorBoundary } from './ErrorBoundary';
import { WalletSelector } from './WalletSelector';

export function WalletConnectButton() {
  const {
    connected,
    connecting,
    disconnect,
    account,
    currentNetwork,
    error,
    clearError,
    switchNetwork,
    connect,
  } = useWalletContext();

  const address = account?.address || null;
  const chainId = currentNetwork;

  const [copyStatus, setCopyStatus] = useState<'idle' | 'success' | 'error'>(
    'idle'
  );
  const [copyError, setCopyError] = useState<string | null>(null);
  const [clipboardError, setClipboardError] = useState<ClipboardError | null>(
    null
  );
  const [showNetworkOptions, setShowNetworkOptions] = useState(false);
  const [isNetworkSwitching, setIsNetworkSwitching] = useState(false);

  // Helper function to truncate address
  const truncateAddress = (address: string) => {
    if (!address) return '';
    return `${address.slice(0, 6)}...${address.slice(-4)}`;
  };

  // Handle copying address to clipboard
  const handleCopyAddress = async () => {
    // Prevent function execution if no address exists
    if (!address) {
      console.warn('Attempted to copy address but no address is available');
      setCopyStatus('error');
      setCopyError('No wallet address available');
      return;
    }

    setCopyStatus('idle');
    setCopyError(null);
    setClipboardError(null);

    try {
      const result = await copyToClipboard(address || '');

      if (result.success) {
        setCopyStatus('success');
        // Reset success status after 2 seconds
        setTimeout(() => setCopyStatus('idle'), 2000);
      } else {
        setCopyStatus('error');
        setCopyError(result.error?.message || 'Unknown error');

        // If it's a ClipboardError, show the modal
        if (result.error instanceof ClipboardError) {
          setClipboardError(result.error);
        }

        console.error('Failed to copy address:', result.error);
      }
    } catch (error) {
      setCopyStatus('error');
      const message = error instanceof Error ? error.message : 'Failed to copy';
      setCopyError(message);

      // If it's a ClipboardError, show the modal
      if (error instanceof ClipboardError) {
        setClipboardError(error);
      }

      console.error('Copy operation failed:', error);
    }
  };

  // Add clipboard manual fallback option
  const handleManualCopy = () => {
    try {
      // Prevent function execution if no address exists
      if (!address) {
        console.warn('Attempted manual copy but no address is available');
        return;
      }

      // Create a temporary input element to display the address for manual copying
      const tempInput = document.createElement('textarea');
      tempInput.value = address || '';
      tempInput.setAttribute('readonly', '');
      tempInput.style.position = 'fixed';
      tempInput.style.top = '0';
      tempInput.style.opacity = '1'; // Make visible but out of normal flow
      tempInput.style.zIndex = '1000';
      document.body.appendChild(tempInput);

      try {
        tempInput.focus();
        tempInput.select();

        // Show instructions
        alert(
          'Please use keyboard shortcut to copy:\n' +
            ' Windows/Linux: Press Ctrl+C\n' +
            ' Mac: Press Command+C\n\n' +
            'Then click OK to continue.'
        );
      } finally {
        // Always clean up, even if there's an error
        try {
          document.body.removeChild(tempInput);
        } catch (err) {
          console.error('Error removing temporary input element:', err);
        }
      }
    } catch (error) {
      console.error('Error in manual copy function:', error);
    }
  };

  // Handle network switching
  const handleNetworkSwitch = async (
    network: 'mainnet' | 'testnet' | 'devnet'
  ) => {
    if (isNetworkSwitching) return; // Prevent multiple clicks

    setIsNetworkSwitching(true);

    try {
      await switchNetwork(network);
      setShowNetworkOptions(false);
    } catch (error) {
      console.error(`Failed to switch to ${network}:`, error);
      // Note: clearError is available, but we'd need an setError function for this
    } finally {
      setIsNetworkSwitching(false);
    }
  };

  // Convert network string to display name
  const getNetworkDisplayName = (networkId: string | null) => {
    if (networkId === null) return 'Unknown';

    // Convert network ID to readable name as needed
    const networkMap: Record<string, string> = {
      mainnet: 'Mainnet',
      testnet: 'Testnet',
      devnet: 'Devnet',
    };

    // Return formatted name or the original if not in our map
    return networkMap[String(networkId)] || String(networkId);
  };

  // Render the connected wallet UI
  const renderConnectedUI = () => {
    if (!connected || !address) return null;

    // Get clipboard capabilities to determine what UI to show
    const clipboardCapabilities = getClipboardCapabilities();
    const showClipboardButton =
      clipboardCapabilities.hasModernApi ||
      clipboardCapabilities.hasLegacySupport;

    return (
      <div className='flex items-center gap-4'>
        <div className='px-4 py-2 bg-ocean-deep/20 dark:bg-ocean-foam/20 rounded-lg flex items-center gap-2 relative'>
          <div className='flex flex-col'>
            <p className='text-sm text-ocean-deep dark:text-ocean-foam'>
              Wallet: {truncateAddress(address)}
            </p>
            <p className='text-xs text-ocean-medium dark:text-ocean-light'>
              {getNetworkDisplayName(chainId)}
              {!isNetworkSwitching ? (
                <button
                  onClick={() => setShowNetworkOptions(!showNetworkOptions)}
                  className='ml-2 text-xs text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam'
                  disabled={isNetworkSwitching}
                >
                  (change)
                </button>
              ) : (
                <span className='ml-2 text-xs text-yellow-500 animate-pulse'>
                  (switching...)
                </span>
              )}
            </p>

            {/* Network selection dropdown */}
            {showNetworkOptions && !isNetworkSwitching && (
              <div className='absolute top-full left-0 mt-2 p-2 bg-white dark:bg-slate-800 rounded-lg shadow-lg z-10 w-full min-w-[150px]'>
                <div className='flex flex-col gap-2'>
                  <button
                    onClick={() => handleNetworkSwitch('mainnet')}
                    disabled={isNetworkSwitching || chainId === 'mainnet'}
                    className={`text-sm px-3 py-1 rounded-md ${
                      chainId === 'mainnet'
                        ? 'bg-ocean-deep text-white'
                        : isNetworkSwitching
                          ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                          : 'hover:bg-ocean-light/20 text-gray-700 dark:text-gray-300'
                    }`}
                  >
                    Mainnet
                  </button>
                  <button
                    onClick={() => handleNetworkSwitch('testnet')}
                    disabled={isNetworkSwitching || chainId === 'testnet'}
                    className={`text-sm px-3 py-1 rounded-md ${
                      chainId === 'testnet'
                        ? 'bg-ocean-deep text-white'
                        : isNetworkSwitching
                          ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                          : 'hover:bg-ocean-light/20 text-gray-700 dark:text-gray-300'
                    }`}
                  >
                    Testnet
                  </button>
                  <button
                    onClick={() => handleNetworkSwitch('devnet')}
                    disabled={isNetworkSwitching || chainId === 'devnet'}
                    className={`text-sm px-3 py-1 rounded-md ${
                      chainId === 'devnet'
                        ? 'bg-ocean-deep text-white'
                        : isNetworkSwitching
                          ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                          : 'hover:bg-ocean-light/20 text-gray-700 dark:text-gray-300'
                    }`}
                  >
                    Devnet
                  </button>
                </div>
              </div>
            )}
          </div>

          {showClipboardButton && (
            <button
              onClick={handleCopyAddress}
              className={`text-ocean-medium hover:text-ocean-deep dark:text-ocean-light dark:hover:text-ocean-foam transition-colors ${
                copyStatus === 'error'
                  ? 'text-red-500 dark:text-red-400'
                  : copyStatus === 'success'
                    ? 'text-green-500 dark:text-green-400'
                    : ''
              }`}
              title={
                copyStatus === 'error'
                  ? 'Copy failed'
                  : copyStatus === 'success'
                    ? 'Copied!'
                    : 'Copy address'
              }
            >
              {copyStatus === 'success' ? (
                <svg
                  className='w-4 h-4'
                  fill='none'
                  stroke='currentColor'
                  viewBox='0 0 24 24'
                >
                  <path
                    strokeLinecap='round'
                    strokeLinejoin='round'
                    strokeWidth={2}
                    d='M5 13l4 4L19 7'
                  />
                </svg>
              ) : copyStatus === 'error' ? (
                <svg
                  className='w-4 h-4'
                  fill='none'
                  stroke='currentColor'
                  viewBox='0 0 24 24'
                >
                  <path
                    strokeLinecap='round'
                    strokeLinejoin='round'
                    strokeWidth={2}
                    d='M6 18L18 6M6 6l12 12'
                  />
                </svg>
              ) : (
                <svg
                  className='w-4 h-4'
                  fill='none'
                  stroke='currentColor'
                  viewBox='0 0 24 24'
                >
                  <path
                    strokeLinecap='round'
                    strokeLinejoin='round'
                    strokeWidth={2}
                    d='M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z'
                  />
                </svg>
              )}
            </button>
          )}

          {/* Error tooltip */}
          {copyStatus === 'error' && copyError && (
            <div className='absolute top-full left-0 mt-2 p-2 bg-red-100 text-red-800 text-xs rounded shadow-md z-10'>
              {copyError}
            </div>
          )}

          {/* Success tooltip */}
          {copyStatus === 'success' && (
            <div className='absolute top-full left-0 mt-2 p-2 bg-green-100 text-green-800 text-xs rounded shadow-md z-10'>
              Address copied to clipboard!
            </div>
          )}
        </div>
        <button
          onClick={() => {
            try {
              disconnect();
            } catch (error) {
              console.error('Error in disconnect handler:', error);
            }
          }}
          disabled={isNetworkSwitching}
          className='px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors disabled:bg-red-300 disabled:cursor-not-allowed'
        >
          Disconnect
        </button>
      </div>
    );
  };

  // Render the connecting UI
  const renderConnectingUI = () => {
    if (!connecting) return null;

    return (
      <div className='px-4 py-2 bg-ocean-deep/20 dark:bg-ocean-foam/20 rounded-lg'>
        <p className='text-sm text-ocean-deep dark:text-ocean-foam flex items-center'>
          <svg
            className='animate-spin -ml-1 mr-2 h-4 w-4 text-ocean-deep dark:text-ocean-foam'
            xmlns='http://www.w3.org/2000/svg'
            fill='none'
            viewBox='0 0 24 24'
          >
            <circle
              className='opacity-25'
              cx='12'
              cy='12'
              r='10'
              stroke='currentColor'
              strokeWidth='4'
            ></circle>
            <path
              className='opacity-75'
              fill='currentColor'
              d='M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z'
            ></path>
          </svg>
          Connecting...
        </p>
      </div>
    );
  };

  // Render the connect button UI with wallet selector
  const renderConnectUI = () => {
    if (connected || connecting) return null;

    // Use the WalletSelector component instead of a simple button
    return <WalletSelector />;
  };

  // Wrap the entire component in an ErrorBoundary
  return (
    <ErrorBoundary>
      <div>
        {renderConnectedUI() || renderConnectingUI() || renderConnectUI()}

        <WalletErrorModal
          error={error ? new WalletError(error) : null}
          onDismiss={clearError}
        />
        <ClipboardErrorModal
          error={clipboardError}
          onDismiss={() => setClipboardError(null)}
          onTryAlternative={handleManualCopy}
        />
      </div>
    </ErrorBoundary>
  );
}
</file>

<file path="src/components/WalletErrorModal.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import {
  WalletError,
  getWalletErrorMessage,
  WalletNotInstalledError,
} from '@/lib/wallet-errors';

interface WalletErrorModalProps {
  error: WalletError | null;
  onDismiss: () => void;
}

export function WalletErrorModal({ error, onDismiss }: WalletErrorModalProps) {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (error) {
      setIsVisible(true);
    } else {
      setIsVisible(false);
    }
  }, [error]);

  if (!error || !isVisible) {
    return null;
  }

  const { message, suggestion } = getWalletErrorMessage(error);

  const handleDismiss = () => {
    setIsVisible(false);
    onDismiss();
  };

  // Determine icon and color based on error type
  const getIconAndColor = () => {
    const errorName = error.name;

    if (errorName === 'WalletNotInstalledError') {
      return {
        icon: (
          <svg
            className='w-6 h-6 text-yellow-400'
            fill='none'
            stroke='currentColor'
            viewBox='0 0 24 24'
          >
            <path
              strokeLinecap='round'
              strokeLinejoin='round'
              strokeWidth={2}
              d='M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z'
            />
          </svg>
        ),
        bgColor: 'bg-yellow-50 dark:bg-yellow-900/20',
        borderColor: 'border-yellow-400',
        textColor: 'text-yellow-700 dark:text-yellow-200',
      };
    }

    if (errorName === 'WalletConnectionRejectedError') {
      return {
        icon: (
          <svg
            className='w-6 h-6 text-red-400'
            fill='none'
            stroke='currentColor'
            viewBox='0 0 24 24'
          >
            <path
              strokeLinecap='round'
              strokeLinejoin='round'
              strokeWidth={2}
              d='M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z'
            />
          </svg>
        ),
        bgColor: 'bg-red-50 dark:bg-red-900/20',
        borderColor: 'border-red-400',
        textColor: 'text-red-700 dark:text-red-200',
      };
    }

    // Default case
    return {
      icon: (
        <svg
          className='w-6 h-6 text-blue-400'
          fill='none'
          stroke='currentColor'
          viewBox='0 0 24 24'
        >
          <path
            strokeLinecap='round'
            strokeLinejoin='round'
            strokeWidth={2}
            d='M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z'
          />
        </svg>
      ),
      bgColor: 'bg-blue-50 dark:bg-blue-900/20',
      borderColor: 'border-blue-400',
      textColor: 'text-blue-700 dark:text-blue-200',
    };
  };

  const { icon, bgColor, borderColor, textColor } = getIconAndColor();

  return (
    <div className='fixed inset-0 flex items-center justify-center p-4 bg-black/50 z-50'>
      <div
        className={`max-w-md w-full rounded-lg ${bgColor} border ${borderColor} shadow-lg overflow-hidden transform transition-all`}
      >
        <div className='p-4'>
          <div className='flex items-start'>
            <div className='flex-shrink-0'>{icon}</div>
            <div className='ml-3 flex-1'>
              <h3 className={`text-lg font-medium ${textColor}`}>{message}</h3>
              <div className='mt-2'>
                <p className={`text-sm ${textColor}`}>{suggestion}</p>
              </div>

              {/* Installation links for wallet not installed errors */}
              {error instanceof WalletNotInstalledError && (
                <div className='mt-3'>
                  {error.walletName.includes('Phantom') && (
                    <a
                      href='https://phantom.app/download'
                      target='_blank'
                      rel='noopener noreferrer'
                      className='inline-flex items-center px-4 py-2 text-sm text-white bg-purple-600 rounded-md hover:bg-purple-700'
                    >
                      Install Phantom
                    </a>
                  )}

                  {(error.walletName.includes('Sui') ||
                    error.walletName.includes('Slush')) && (
                    <a
                      href='https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil'
                      target='_blank'
                      rel='noopener noreferrer'
                      className='inline-flex items-center px-4 py-2 text-sm text-white bg-blue-600 rounded-md hover:bg-blue-700'
                    >
                      Install Sui/Slush
                    </a>
                  )}

                  {error.walletName.includes('Backpack') && (
                    <a
                      href='https://www.backpack.app/download'
                      target='_blank'
                      rel='noopener noreferrer'
                      className='inline-flex items-center px-4 py-2 text-sm text-white bg-orange-600 rounded-md hover:bg-orange-700'
                    >
                      Install Backpack
                    </a>
                  )}
                </div>
              )}

              <div className='mt-4 flex justify-end'>
                <button
                  type='button'
                  onClick={handleDismiss}
                  className={`inline-flex justify-center px-4 py-2 text-sm font-medium text-white bg-ocean-medium rounded-md hover:bg-ocean-deep focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-ocean-light`}
                >
                  Got it
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/WalletSelector.tsx">
'use client';

import React, { useState } from 'react';
import { useWalletContext } from '@/contexts/WalletContext';
import { WalletType } from '@/types/wallet';
import { WalletErrorModal } from './WalletErrorModal';
import { WalletNotInstalledError } from '@/lib/wallet-errors';

interface WalletOption {
  type: WalletType;
  name: string;
  icon: React.ReactNode;
  description: string;
}

export function WalletSelector() {
  const { connected, connecting, connect, error, clearError } =
    useWalletContext();

  const [isOpen, setIsOpen] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [selectedWallet, setSelectedWallet] = useState<WalletType | null>(null);

  // Disable the selector if already connected or connecting
  if (connected || connecting) {
    return null;
  }

  // Define wallet options - simplified to Sui wallets primarily
  const walletOptions: WalletOption[] = [
    {
      type: 'sui',
      name: 'Sui Wallet',
      icon: (
        <svg
          className='w-6 h-6'
          viewBox='0 0 24 24'
          fill='none'
          xmlns='http://www.w3.org/2000/svg'
        >
          <path
            d='M13.2 12L12 13.2L10.8 12L12 10.8L13.2 12Z'
            fill='currentColor'
          />
          <path d='M12 6L13.2 7.2L12 8.4L10.8 7.2L12 6Z' fill='currentColor' />
          <path
            d='M12 15.6L13.2 16.8L12 18L10.8 16.8L12 15.6Z'
            fill='currentColor'
          />
          <path
            d='M16.8 10.8L18 12L16.8 13.2L15.6 12L16.8 10.8Z'
            fill='currentColor'
          />
          <path
            d='M7.2 10.8L8.4 12L7.2 13.2L6 12L7.2 10.8Z'
            fill='currentColor'
          />
          <path
            d='M18 7.2L19.2 8.4L18 9.6L16.8 8.4L18 7.2Z'
            fill='currentColor'
          />
          <path
            d='M8.4 16.8L9.6 18L8.4 19.2L7.2 18L8.4 16.8Z'
            fill='currentColor'
          />
          <path
            d='M16.8 15.6L18 16.8L16.8 18L15.6 16.8L16.8 15.6Z'
            fill='currentColor'
          />
          <path
            d='M7.2 15.6L8.4 16.8L7.2 18L6 16.8L7.2 15.6Z'
            fill='currentColor'
          />
        </svg>
      ),
      description: 'Connect with any Sui-compatible wallet',
    },
  ];

  // Check if a wallet is installed before connecting
  const checkWalletInstalled = (walletType: WalletType): boolean => {
    if (typeof window === 'undefined') return false;

    switch (walletType) {
      case 'sui':
        // Check for any Sui wallet
        return true; // Always assume available since we support any Sui wallet
      default:
        return false;
    }
  };

  // Handle wallet selection
  const handleSelectWallet = async (walletType: WalletType) => {
    setSelectedWallet(walletType);
    setIsConnecting(true);
    setIsOpen(false);

    try {
      // First check if the wallet is installed
      const isInstalled = checkWalletInstalled(walletType);

      // Add diagnostic logging for wallet detection
      console.log(`Checking ${walletType} wallet availability:`, isInstalled);

      // If wallet is not installed, show error directly
      if (!isInstalled) {
        const walletName =
          walletType === 'sui'
            ? 'Sui'
            : walletType === 'slush'
              ? 'Slush'
              : walletType === 'phantom'
                ? 'Phantom'
                : walletType === 'backpack'
                  ? 'Backpack'
                  : 'Wallet';

        const error = new WalletNotInstalledError(walletName);
        console.error('Wallet not installed:', error);
        return;
      }

      // If Backpack, add extra diagnostic info
      if (walletType === 'backpack') {
        console.log('Trying to connect to Backpack wallet');
        console.log('Checking for Backpack availability:', {
          windowDefined: typeof window !== 'undefined',
          xnft: typeof window !== 'undefined' ? !!window.xnft : false,
          backpack: typeof window !== 'undefined' ? !!window.backpack : false,
          solana: typeof window !== 'undefined' ? !!window.solana : false,
          solanaIsBackpack:
            typeof window !== 'undefined' && window.solana
              ? !!window.solana.isBackpack
              : false,
        });
      }

      // Proceed with connection if wallet is installed
      if (walletType === 'sui') {
        connect(); // This opens the modal
      }
    } catch (err) {
      console.error(`Error connecting to ${walletType} wallet:`, err);
      // Error is already handled by the wallet context
    } finally {
      setIsConnecting(false);
    }
  };

  // Handle error dismissal
  const handleDismissError = () => {
    clearError();
  };

  return (
    <div className='relative'>
      {/* Show error modal when there's a wallet error */}
      {error && (
        <WalletErrorModal error={error} onDismiss={handleDismissError} />
      )}

      <button
        onClick={() => setIsOpen(!isOpen)}
        disabled={isConnecting}
        className='px-4 py-2 bg-ocean-deep text-white rounded-lg hover:bg-ocean-deep/80 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed flex items-center gap-2'
        aria-expanded={isOpen}
      >
        {isConnecting ? (
          <>
            <svg
              className='animate-spin h-4 w-4'
              xmlns='http://www.w3.org/2000/svg'
              fill='none'
              viewBox='0 0 24 24'
            >
              <circle
                className='opacity-25'
                cx='12'
                cy='12'
                r='10'
                stroke='currentColor'
                strokeWidth='4'
              ></circle>
              <path
                className='opacity-75'
                fill='currentColor'
                d='M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z'
              ></path>
            </svg>
            <span>Connecting...</span>
          </>
        ) : (
          <>
            <svg
              className='h-5 w-5'
              fill='none'
              stroke='currentColor'
              viewBox='0 0 24 24'
              xmlns='http://www.w3.org/2000/svg'
            >
              <path
                strokeLinecap='round'
                strokeLinejoin='round'
                strokeWidth='2'
                d='M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z'
              ></path>
            </svg>
            <span>Connect Wallet</span>
          </>
        )}
      </button>

      {isOpen && (
        <div className='absolute z-10 mt-2 w-72 rounded-md shadow-lg bg-white dark:bg-slate-800 ring-1 ring-black ring-opacity-5 divide-y divide-gray-200 dark:divide-gray-700'>
          <div className='p-2'>
            <h3 className='text-sm font-medium text-gray-900 dark:text-gray-100 p-2'>
              Select a wallet
            </h3>
            <div className='mt-1 divide-y divide-gray-200 dark:divide-gray-700'>
              {walletOptions.map(option => (
                <button
                  key={option.type}
                  className='w-full flex items-start p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors'
                  onClick={() => handleSelectWallet(option.type)}
                >
                  <div className='flex-shrink-0 text-ocean-deep dark:text-ocean-foam'>
                    {option.icon}
                  </div>
                  <div className='ml-3 text-left'>
                    <p className='text-sm font-medium text-gray-900 dark:text-gray-100'>
                      {option.name}
                    </p>
                    <p className='text-xs text-gray-500 dark:text-gray-400'>
                      {option.description}
                    </p>
                  </div>
                </button>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/WalletStatus.tsx">
'use client';

import React from 'react';
import { useWalletContext } from '@/contexts/WalletContext';

export function WalletStatus() {
  const { connected, address, name, network, error } = useWalletContext();

  if (error) {
    return (
      <div className='inline-flex items-center gap-2 px-3 py-1 bg-red-100 dark:bg-red-900/20 rounded-full'>
        <div className='w-2 h-2 rounded-full bg-red-500' />
        <span className='text-sm text-red-700 dark:text-red-300'>
          Wallet Error
        </span>
      </div>
    );
  }

  if (!connected || !address) {
    return (
      <div className='inline-flex items-center gap-2 px-3 py-1 bg-gray-100 dark:bg-gray-800 rounded-full'>
        <div className='w-2 h-2 rounded-full bg-gray-400' />
        <span className='text-sm text-gray-600 dark:text-gray-400'>
          Not Connected
        </span>
      </div>
    );
  }

  return (
    <div className='inline-flex items-center gap-2 px-3 py-1 bg-ocean-deep/10 dark:bg-ocean-foam/10 rounded-full'>
      <div className='w-2 h-2 rounded-full bg-green-500' />
      <span className='text-sm text-ocean-deep dark:text-ocean-foam'>
        {name || 'Sui Wallet'}  {network}
      </span>
    </div>
  );
}
</file>

<file path="src/components/WalrusStorageManager.tsx">
'use client';

import { useState } from 'react';
import Image from 'next/image';
import { walrusClient } from '@/lib/walrus-client';

export default function WalrusStorageManager() {
  const [uploadStatus, setUploadStatus] = useState<string>('');
  const [blobId, setBlobId] = useState<string>('');
  const [imageUrl, setImageUrl] = useState<string>('');
  const [isUploading, setIsUploading] = useState(false);

  const handleImageUpload = async (
    event: React.ChangeEvent<HTMLInputElement>
  ) => {
    const file = event.target.files?.[0];
    if (!file) return;

    setIsUploading(true);
    setUploadStatus('Uploading to Walrus...');

    try {
      // Upload image to Walrus
      const result = await walrusClient.uploadImage(file, { epochs: 5 });

      setBlobId(result.blobId);
      const url = walrusClient.getBlobUrl(result.blobId);
      setImageUrl(url);

      setUploadStatus(` Upload successful! Blob ID: ${result.blobId}`);
      console.log('Upload result:', result);
    } catch (error) {
      console.error('Upload error:', error);
      setUploadStatus(
        ` Upload failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    } finally {
      setIsUploading(false);
    }
  };

  const handleTextUpload = async () => {
    const text = prompt('Enter text to upload:');
    if (!text) return;

    setIsUploading(true);
    setUploadStatus('Uploading text to Walrus...');

    try {
      const result = await walrusClient.upload(text, {
        epochs: 5,
        contentType: 'text/plain',
      });

      setBlobId(result.blobId);
      setUploadStatus(` Text uploaded! Blob ID: ${result.blobId}`);

      // Test downloading it back
      const downloaded = await walrusClient.download(result.blobId);
      const downloadedText = new TextDecoder().decode(downloaded.data);
      console.log('Downloaded text:', downloadedText);
    } catch (error) {
      console.error('Upload error:', error);
      setUploadStatus(
        ` Upload failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    } finally {
      setIsUploading(false);
    }
  };

  const testJsonUpload = async () => {
    const testData = {
      message: 'Hello from Walrus!',
      timestamp: new Date().toISOString(),
      data: {
        numbers: [1, 2, 3],
        nested: { key: 'value' },
      },
    };

    setIsUploading(true);
    setUploadStatus('Uploading JSON to Walrus...');

    try {
      const result = await walrusClient.uploadJson(testData, { epochs: 5 });

      setBlobId(result.blobId);
      setUploadStatus(` JSON uploaded! Blob ID: ${result.blobId}`);

      // Test downloading it back
      const downloaded = await walrusClient.downloadJson(result.blobId);
      console.log('Downloaded JSON:', downloaded);
    } catch (error) {
      console.error('Upload error:', error);
      setUploadStatus(
        ` Upload failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <div className='ocean-card'>
      <h2 className='text-xl font-semibold mb-4'>Walrus Storage Manager</h2>

      <div className='space-y-4'>
        <div>
          <h3 className='font-medium mb-2'>Upload Image</h3>
          <input
            type='file'
            accept='image/*'
            onChange={handleImageUpload}
            disabled={isUploading}
            className='block w-full text-sm text-gray-500
              file:mr-4 file:py-2 file:px-4
              file:rounded-full file:border-0
              file:text-sm file:font-semibold
              file:bg-blue-50 file:text-blue-700
              hover:file:bg-blue-100
              disabled:opacity-50'
          />
        </div>

        <div className='flex gap-2'>
          <button
            onClick={handleTextUpload}
            disabled={isUploading}
            className='ocean-button'
          >
            Upload Text
          </button>

          <button
            onClick={testJsonUpload}
            disabled={isUploading}
            className='ocean-button'
          >
            Upload JSON
          </button>
        </div>

        {uploadStatus && (
          <div className='p-4 bg-gray-100 rounded'>
            <p className='text-sm'>{uploadStatus}</p>
          </div>
        )}

        {blobId && (
          <div className='p-4 bg-blue-50 rounded'>
            <p className='text-sm font-medium'>Blob ID:</p>
            <code className='text-xs break-all'>{blobId}</code>

            {imageUrl && (
              <div className='mt-4'>
                <p className='text-sm font-medium mb-2'>Uploaded Image:</p>
                <div className='relative max-w-xs'>
                  <Image
                    src={imageUrl}
                    alt='Uploaded to Walrus'
                    width={320}
                    height={240}
                    className='rounded shadow'
                    style={{ width: 'auto', height: 'auto' }}
                  />
                </div>
                <p className='text-xs mt-2'>
                  URL:{' '}
                  <a
                    href={imageUrl}
                    target='_blank'
                    rel='noopener noreferrer'
                    className='text-blue-600 underline'
                  >
                    {imageUrl}
                  </a>
                </p>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/contexts/SimpleWalletContext.tsx">
'use client';

import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  ReactNode,
} from 'react';

// Simple wallet interface that avoids complex dependencies
interface SimpleWalletContextValue {
  connected: boolean;
  connecting: boolean;
  address: string | null;
  name: string | null;
  chainId: string | null;
  error: Error | null;
  setError: (error: Error | null) => void;
  connect: () => Promise<void>;
  disconnect: () => Promise<void>;
  switchNetwork: (network: string) => Promise<void>;
}

// Create context with default values
const SimpleWalletContext = createContext<SimpleWalletContextValue | null>(
  null
);

// Mock wallet data for development
const MOCK_ADDRESS = '0x7a40eb2bb8dcf8abe508e3f0dc49bade2935bd8c';
const MOCK_WALLET_NAME = 'Development Wallet';

// Create a provider component
export function SimpleWalletProvider({ children }: { children: ReactNode }) {
  const [connected, setConnected] = useState(false);
  const [connecting, setConnecting] = useState(false);
  const [address, setAddress] = useState<string | null>(null);
  const [name, setName] = useState<string | null>(null);
  const [chainId, setChainId] = useState<string | null>('testnet');
  const [error, setError] = useState<Error | null>(null);

  // Safe local storage access
  const getStorage = (key: string): string | null => {
    try {
      if (typeof window === 'undefined') return null;
      return localStorage.getItem(key);
    } catch (e) {
      console.warn('Storage access failed:', e);
      return null;
    }
  };

  const setStorage = (key: string, value: string): void => {
    try {
      if (typeof window === 'undefined') return;
      localStorage.setItem(key, value);
    } catch (e) {
      console.warn('Storage write failed:', e);
    }
  };

  // Auto-connect based on stored data
  useEffect(() => {
    const autoConnect = async () => {
      try {
        const savedState = getStorage('wallet_connected');
        if (savedState === 'true' && !connected && !connecting) {
          try {
            // Simulate connection process
            const savedAddress = getStorage('wallet_address');
            const savedName = getStorage('wallet_name');
            const savedChain = getStorage('wallet_chain');

            if (savedAddress) {
              setAddress(savedAddress);
              setName(savedName || MOCK_WALLET_NAME);
              setChainId(savedChain || 'testnet');
              setConnected(true);
            }
          } catch (e) {
            console.warn('Auto-connect failed:', e);
            // Clean up storage
            try {
              localStorage.removeItem('wallet_connected');
              localStorage.removeItem('wallet_address');
              localStorage.removeItem('wallet_name');
              localStorage.removeItem('wallet_chain');
            } catch (error) {
              // Ignore storage errors
            }
          }
        }
      } catch (error) {
        console.warn('Error during auto-connect check:', error);
      }
    };

    if (typeof window !== 'undefined') {
      autoConnect();
    }
  }, [connected, connecting]);

  // Connect function
  const connect = async (): Promise<void> => {
    if (connected) return;

    setConnecting(true);
    setError(null);

    try {
      // Simulate connecting to a wallet with a short delay
      await new Promise(resolve => setTimeout(resolve, 500));

      // Set connected state
      setAddress(MOCK_ADDRESS);
      setName(MOCK_WALLET_NAME);
      setChainId('testnet');
      setConnected(true);

      // Store connection state
      setStorage('wallet_connected', 'true');
      setStorage('wallet_address', MOCK_ADDRESS);
      setStorage('wallet_name', MOCK_WALLET_NAME);
      setStorage('wallet_chain', 'testnet');

      return Promise.resolve();
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Connection failed');
      setError(error);
      console.error('Wallet connection error:', error);
      return Promise.reject(error);
    } finally {
      setConnecting(false);
    }
  };

  // Disconnect function
  const disconnect = async (): Promise<void> => {
    if (!connected) return;

    setError(null);

    try {
      // Simulate disconnecting from wallet with a short delay
      await new Promise(resolve => setTimeout(resolve, 300));

      // Clear state
      setConnected(false);
      setAddress(null);
      setName(null);

      // Clear stored data
      try {
        localStorage.removeItem('wallet_connected');
        localStorage.removeItem('wallet_address');
        localStorage.removeItem('wallet_name');
        localStorage.removeItem('wallet_chain');
      } catch (e) {
        // Ignore storage errors
      }

      return Promise.resolve();
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Disconnect failed');
      setError(error);
      console.error('Wallet disconnect error:', error);
      return Promise.reject(error);
    }
  };

  // Enhanced switch network function
  const switchNetwork = async (network: string): Promise<void> => {
    if (!connected) {
      const error = new Error('Not connected to any wallet');
      setError(error);
      return Promise.reject(error);
    }

    try {
      // Show switching UI
      setError(null);

      // Simulate network switching with a delay
      await new Promise(resolve => setTimeout(resolve, 500));

      // Validate network value
      const validNetworks = ['mainnet', 'testnet', 'devnet'];
      if (!validNetworks.includes(network)) {
        throw new Error(
          `Invalid network: ${network}. Must be one of: ${validNetworks.join(', ')}`
        );
      }

      // Update chain ID
      setChainId(network);
      setStorage('wallet_chain', network);

      // Dispatch network change event for any listeners
      if (typeof window !== 'undefined') {
        const networkSwitchEvent = new CustomEvent(
          'simpleWalletNetworkSwitch',
          {
            detail: { network },
          }
        );
        window.dispatchEvent(networkSwitchEvent);
      }

      console.log(`Switched to ${network} network`);
      return Promise.resolve();
    } catch (err) {
      const error =
        err instanceof Error ? err : new Error('Network switch failed');
      setError(error);
      console.error('Network switch error:', error);
      return Promise.reject(error);
    }
  };

  // Create context value
  const contextValue: SimpleWalletContextValue = {
    connected,
    connecting,
    address,
    name,
    chainId,
    error,
    setError,
    connect,
    disconnect,
    switchNetwork,
  };

  return (
    <SimpleWalletContext.Provider value={contextValue}>
      {children}
    </SimpleWalletContext.Provider>
  );
}

// Custom hook to use wallet context
export function useWalletContext() {
  const context = useContext(SimpleWalletContext);
  if (!context) {
    throw new Error(
      'useWalletContext must be used within SimpleWalletProvider'
    );
  }
  return context;
}
</file>

<file path="src/contexts/WalletContext.tsx">
// WalletContext.tsx - Modern simplified wallet management for Sui blockchain
'use client';

import React, { createContext, useContext, useEffect, useState, useCallback, ReactNode } from 'react';
import { 
  createNetworkConfig,
  SuiClientProvider, 
  WalletProvider,
  useCurrentAccount,
  useConnectWallet,
  useDisconnectWallet,
  useSignAndExecuteTransaction,
  ConnectModal,
  useWallets
} from '@mysten/dapp-kit';
import { getFullnodeUrl } from '@mysten/sui/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Transaction } from '@mysten/sui/transactions';
import { useInactivityTimer } from '@/hooks/useInactivityTimer';

// Network Configuration using createNetworkConfig
const { networkConfig } = createNetworkConfig({
  testnet: { url: getFullnodeUrl('testnet') },
  devnet: { url: getFullnodeUrl('devnet') },
  mainnet: { url: getFullnodeUrl('mainnet') },
});

// Types
export interface WalletContextType {
  // Connection state
  connected: boolean;
  connecting: boolean;
  account: { address: string } | null;
  
  // Wallet actions
  connect: () => void;
  disconnect: () => void;
  
  // Transaction handling
  signAndExecuteTransaction: (txb: Transaction) => Promise<any>;
  
  // Session management
  sessionExpired: boolean;
  resetSession: () => void;
  lastActivity: number;
  resetActivityTimer: () => void;
  
  // Transaction history
  transactionHistory: TransactionRecord[];
  addTransaction: (tx: TransactionRecord) => void;
  
  // Network management
  currentNetwork: string;
  switchNetwork: (network: string) => void;
  
  // Error handling
  error: string | null;
  clearError: () => void;

  // Modal control
  isModalOpen: boolean;
  openModal: () => void;
  closeModal: () => void;
}

export interface TransactionRecord {
  id: string;
  status: 'pending' | 'success' | 'failed';
  timestamp: Date;
  type: string;
  details?: any;
}

// Create context
export const WalletContext = createContext<WalletContextType | null>(null);

// Hook to use wallet context
export const useWalletContext = () => {
  const context = useContext(WalletContext);
  if (!context) {
    throw new Error('useWalletContext must be used within a WalletProvider');
  }
  return context;
};

// Session timeout configuration (30 minutes)
const SESSION_TIMEOUT = 30 * 60 * 1000;

// Inner wallet context provider that uses the wallet hooks
function WalletContextProvider({ children }: { children: ReactNode }) {
  // Mysten dApp Kit hooks
  const account = useCurrentAccount();
  const { mutate: connectWallet, isPending: connecting } = useConnectWallet();
  const { mutate: disconnectWallet } = useDisconnectWallet();
  const { mutateAsync: signAndExecute } = useSignAndExecuteTransaction();
  const wallets = useWallets();
  
  // Local state
  const [transactionHistory, setTransactionHistory] = useState<TransactionRecord[]>([]);
  const [currentNetwork, setCurrentNetwork] = useState('testnet');
  const [error, setError] = useState<string | null>(null);
  const [sessionExpired, setSessionExpired] = useState(false);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [lastActivity, setLastActivity] = useState(Date.now());
  
  // Session timeout - temporarily disabled for debugging
  const resetActivityTimer = useCallback(() => {
    console.log('[WalletContext] Activity timer reset (disabled)');
    setLastActivity(Date.now());
  }, []);
  const isActive = true;
  
  /*
  const { isActive, resetActivityTimer } = useInactivityTimer({
    timeout: SESSION_TIMEOUT,
    onTimeout: () => {
      if (connected) {
        console.log('[WalletContext] Session expired due to inactivity');
        setSessionExpired(true);
      }
    }
  });
  */
  
  // Connection state
  const connected = Boolean(account);

  // Auto-reconnect logic - temporarily disabled for debugging
  useEffect(() => {
    // Commenting out auto-reconnect to isolate loading issue
    console.log('[WalletContext] Auto-reconnect disabled for debugging');
    /*
    const autoReconnect = async () => {
      try {
        let lastWallet = null;
        try {
          lastWallet = localStorage.getItem('sui-wallet-last-connected');
        } catch (storageError) {
          console.warn('[WalletContext] localStorage access failed:', storageError);
          return; // Skip auto-reconnect if localStorage is not available
        }

        if (lastWallet && !connected && !connecting && wallets.length > 0) {
          console.log('[WalletContext] Attempting auto-reconnect to:', lastWallet);
          const wallet = wallets.find(w => w.name === lastWallet);
          if (wallet) {
            connectWallet(
              { wallet },
              {
                onSuccess: () => {
                  console.log('[WalletContext] Auto-reconnect successful');
                  resetActivityTimer();
                },
                onError: (error) => {
                  console.error('[WalletContext] Auto-reconnect failed:', error);
                  try {
                    localStorage.removeItem('sui-wallet-last-connected');
                  } catch (storageError) {
                    console.warn('[WalletContext] Failed to remove localStorage item:', storageError);
                  }
                }
              }
            );
          }
        }
      } catch (error) {
        console.error('[WalletContext] Auto-reconnect error:', error);
        try {
          localStorage.removeItem('sui-wallet-last-connected');
        } catch (storageError) {
          console.warn('[WalletContext] Failed to remove localStorage item:', storageError);
        }
      }
    };

    const timer = setTimeout(autoReconnect, 1000);
    return () => clearTimeout(timer);
    */
  }, []);

  // Clear error when wallet state changes
  useEffect(() => {
    setError(null);
  }, [connected]);

  const connect = useCallback(() => {
    try {
      setError(null);
      console.log('[WalletContext] Opening wallet connection modal...');
      setIsModalOpen(true);
    } catch (error) {
      console.error('[WalletContext] Connect error:', error);
      setError('Failed to open wallet connection');
    }
  }, []);

  const disconnect = useCallback(() => {
    try {
      setError(null);
      console.log('[WalletContext] Disconnecting wallet...');
      disconnectWallet();
      try {
        localStorage.removeItem('sui-wallet-last-connected');
      } catch (storageError) {
        console.warn('[WalletContext] Failed to remove localStorage item:', storageError);
      }
      setTransactionHistory([]);
      console.log('[WalletContext] Wallet disconnected successfully');
    } catch (error) {
      console.error('[WalletContext] Disconnect error:', error);
      setError('Failed to disconnect wallet');
    }
  }, [disconnectWallet]);

  const signAndExecuteTransaction = useCallback(async (txb: Transaction) => {
    try {
      setError(null);
      console.log('[WalletContext] Executing transaction...');
      
      if (!connected) {
        throw new Error('No wallet connected');
      }
      
      const result = await signAndExecute({ transaction: txb });
      
      // Add to transaction history
      const transaction: TransactionRecord = {
        id: result.digest || Date.now().toString(),
        status: 'success',
        timestamp: new Date(),
        type: 'transaction',
        details: result
      };
      
      setTransactionHistory(prev => [transaction, ...prev.slice(0, 49)]); // Keep last 50
      resetActivityTimer();
      
      console.log('[WalletContext] Transaction executed successfully:', result);
      return result;
    } catch (error) {
      console.error('[WalletContext] Transaction error:', error);
      setError(`Transaction failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      throw error;
    }
  }, [connected, signAndExecute, resetActivityTimer]);

  const addTransaction = useCallback((tx: TransactionRecord) => {
    setTransactionHistory(prev => [tx, ...prev.slice(0, 49)]);
  }, []);

  const switchNetwork = useCallback((network: string) => {
    console.log('[WalletContext] Switching network to:', network);
    setCurrentNetwork(network);
    // Note: Network switching would require reconnecting with new network config
  }, []);

  const resetSession = useCallback(() => {
    console.log('[WalletContext] Resetting session');
    setSessionExpired(false);
    resetActivityTimer();
  }, [resetActivityTimer]);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  const openModal = useCallback(() => {
    setIsModalOpen(true);
  }, []);

  const closeModal = useCallback(() => {
    setIsModalOpen(false);
  }, []);

  const contextValue: WalletContextType = {
    connected,
    connecting,
    account,
    connect,
    disconnect,
    signAndExecuteTransaction,
    sessionExpired,
    resetSession,
    transactionHistory,
    addTransaction,
    currentNetwork,
    switchNetwork,
    error,
    clearError,
    isModalOpen,
    openModal,
    closeModal,
    lastActivity,
    resetActivityTimer,
  };

  return (
    <WalletContext.Provider value={contextValue}>
      {children}
      <div>
        <ConnectModal
          open={isModalOpen}
          onOpenChange={(open) => {
            setIsModalOpen(open);
            if (!open) {
              // Modal was closed, save the connected wallet
              if (connected && account) {
                const connectedWallet = wallets.find(w => w.accounts?.some(acc => acc.address === account.address));
                if (connectedWallet) {
                  try {
                    localStorage.setItem('sui-wallet-last-connected', connectedWallet.name);
                  } catch (storageError) {
                    console.warn('[WalletContext] Failed to save wallet to localStorage:', storageError);
                  }
                  resetActivityTimer();
                }
              }
            }
          }}
        />
      </div>
    </WalletContext.Provider>
  );
}

// Query client for React Query
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 3,
      staleTime: 30000,
    },
  },
});

// Main app wallet provider component with Slush wallet support
export function AppWalletProvider({ children }: { children: ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      <SuiClientProvider 
        networks={networkConfig} 
        defaultNetwork="testnet"
      >
        <WalletProvider
          slushWallet={{
            name: 'Walrus Todo',
          }}
          autoConnect={true}
        >
          <WalletContextProvider>
            {children}
          </WalletContextProvider>
        </WalletProvider>
      </SuiClientProvider>
    </QueryClientProvider>
  );
}
</file>

<file path="src/examples/blockchain-events-usage.tsx">
/**
 * Usage examples for blockchain event system
 * Demonstrates various ways to integrate real-time events
 */

'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { Todo } from '@/lib/sui-client';
import {
  useBlockchainEvents,
  useTodoEvents,
  useTodoStateSync,
  useEventConnectionStatus,
} from '@/hooks/useBlockchainEvents';
import {
  BlockchainEventStatus,
  BlockchainEventIndicator,
} from '@/components/BlockchainEventStatus';
import { RealtimeTodoList } from '@/components/RealtimeTodoList';
import { useWalletContext } from '@/contexts/WalletContext';

/**
 * Example 1: Basic Event Subscription
 */
export function BasicEventSubscription() {
  const { address } = useWalletContext();
  const {
    isConnected,
    isConnecting,
    error,
    startSubscription,
    stopSubscription,
  } = useBlockchainEvents({
    autoStart: true,
    owner: address || undefined,
    enableReconnect: true,
  });

  return (
    <div className='p-4 border rounded-lg'>
      <h3 className='text-lg font-semibold mb-4'>Basic Event Subscription</h3>

      <div className='space-y-2'>
        <p>
          Status:{' '}
          {isConnecting
            ? 'Connecting...'
            : isConnected
              ? 'Connected'
              : 'Disconnected'}
        </p>
        {error && <p className='text-red-600'>Error: {error.message}</p>}

        <div className='space-x-2'>
          <button
            onClick={startSubscription}
            disabled={isConnected || isConnecting}
            className='px-4 py-2 bg-blue-600 text-white rounded disabled:opacity-50'
          >
            Start Subscription
          </button>
          <button
            onClick={stopSubscription}
            disabled={!isConnected}
            className='px-4 py-2 bg-red-600 text-white rounded disabled:opacity-50'
          >
            Stop Subscription
          </button>
        </div>
      </div>
    </div>
  );
}

/**
 * Example 2: Todo Event Handlers
 */
export function TodoEventHandlers() {
  const { address } = useWalletContext();
  const [notifications, setNotifications] = useState<string[]>([]);

  const addNotification = useCallback((message: string) => {
    setNotifications(prev => [message, ...prev.slice(0, 9)]); // Keep last 10
  }, []);

  const { recentEvents, isConnected } = useTodoEvents({
    autoStart: true,
    owner: address || undefined,
    onTodoCreated: todo => {
      addNotification(` New todo created: "${todo.title}"`);
    },
    onTodoCompleted: todo => {
      addNotification(` Todo completed: "${todo.title || 'Unknown'}"`);
    },
    onTodoUpdated: todo => {
      addNotification(` Todo updated: "${todo.title || 'Unknown'}"`);
    },
    onTodoDeleted: todoId => {
      addNotification(` Todo deleted: ${todoId}`);
    },
  });

  return (
    <div className='p-4 border rounded-lg'>
      <h3 className='text-lg font-semibold mb-4'>Todo Event Handlers</h3>

      <div className='grid grid-cols-2 gap-4'>
        <div>
          <h4 className='font-medium mb-2'>Live Notifications</h4>
          <div className='space-y-1 max-h-40 overflow-y-auto'>
            {notifications.length === 0 ? (
              <p className='text-gray-500 text-sm'>No notifications yet</p>
            ) : (
              notifications.map((notification, index) => (
                <div key={index} className='text-sm p-2 bg-gray-100 rounded'>
                  {notification}
                </div>
              ))
            )}
          </div>
        </div>

        <div>
          <h4 className='font-medium mb-2'>
            Recent Events ({recentEvents.length})
          </h4>
          <div className='space-y-1 max-h-40 overflow-y-auto'>
            {recentEvents.slice(0, 5).map((event, index) => (
              <div key={index} className='text-xs p-2 bg-blue-50 rounded'>
                <span className='font-mono'>{event.type}</span>:{' '}
                {JSON.stringify(event.data, null, 2).substring(0, 50)}...
              </div>
            ))}
          </div>
        </div>
      </div>

      <div className='mt-4'>
        <BlockchainEventIndicator />
        <span className='ml-2 text-sm text-gray-600'>
          {isConnected
            ? 'Receiving live updates'
            : 'Connect wallet for live updates'}
        </span>
      </div>
    </div>
  );
}

/**
 * Example 3: Real-time Todo State Sync
 */
export function TodoStateSync() {
  const { address } = useWalletContext();
  const [localTodos, setLocalTodos] = useState<Todo[]>([
    {
      id: '1',
      title: 'Example Local Todo',
      completed: false,
      priority: 'medium',
      blockchainStored: false,
    },
  ]);

  const { syncedTodos, isConnected } = useTodoStateSync({
    todos: localTodos,
    onTodoChange: updatedTodos => {
      console.log('Todos synchronized from blockchain:', updatedTodos);
      setLocalTodos(updatedTodos);
    },
    owner: address || undefined,
    autoStart: true,
  });

  const handleAddTodo = () => {
    const newTodo: Todo = {
      id: Date.now().toString(),
      title: `New Todo ${Date.now()}`,
      completed: false,
      priority: 'medium',
      blockchainStored: false,
    };
    setLocalTodos(prev => [...prev, newTodo]);
  };

  return (
    <div className='p-4 border rounded-lg'>
      <h3 className='text-lg font-semibold mb-4'>Real-time Todo State Sync</h3>

      <div className='mb-4'>
        <button
          onClick={handleAddTodo}
          className='px-4 py-2 bg-green-600 text-white rounded'
        >
          Add Local Todo
        </button>
        <span className='ml-4 text-sm text-gray-600'>
          Total todos: {syncedTodos.length} | Connected:{' '}
          {isConnected ? '' : ''}
        </span>
      </div>

      <div className='space-y-2'>
        {syncedTodos.map(todo => (
          <div
            key={todo.id}
            className='flex items-center justify-between p-2 bg-gray-50 rounded'
          >
            <div>
              <span
                className={todo.completed ? 'line-through text-gray-500' : ''}
              >
                {todo.title}
              </span>
              {todo.blockchainStored && (
                <span className='ml-2 px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded'>
                  On-chain
                </span>
              )}
            </div>
            <div className='text-xs text-gray-500'>
              {todo.priority} priority
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

/**
 * Example 4: Connection Status Management
 */
export function ConnectionStatusManagement() {
  const { connectionState, statusColor, statusText, canReconnect, reconnect } =
    useEventConnectionStatus();

  return (
    <div className='p-4 border rounded-lg'>
      <h3 className='text-lg font-semibold mb-4'>
        Connection Status Management
      </h3>

      <div className='grid grid-cols-2 gap-4'>
        <div>
          <h4 className='font-medium mb-2'>Current Status</h4>
          <div className='space-y-2'>
            <div className='flex items-center'>
              <div
                className={`w-3 h-3 rounded-full mr-2 bg-${statusColor}-500`}
              ></div>
              <span>{statusText}</span>
            </div>
            <div className='text-sm text-gray-600'>
              Reconnect attempts: {connectionState.reconnectAttempts}
            </div>
          </div>
        </div>

        <div>
          <h4 className='font-medium mb-2'>Actions</h4>
          <div className='space-y-2'>
            <button
              onClick={reconnect}
              disabled={!canReconnect}
              className='w-full px-4 py-2 bg-blue-600 text-white rounded disabled:opacity-50'
            >
              Reconnect
            </button>
          </div>
        </div>
      </div>

      <div className='mt-4'>
        <BlockchainEventStatus showReconnectButton={true} showDetails={true} />
      </div>
    </div>
  );
}

/**
 * Example 5: Complete Real-time Todo Application
 */
export function CompleteRealtimeTodoApp() {
  const { address, connected } = useWalletContext();
  const [todos, setTodos] = useState<Todo[]>([]);

  const handleTodoComplete = async (todo: Todo) => {
    // Simulate blockchain completion
    console.log('Completing todo on blockchain:', todo);

    // Update local state immediately for optimistic UI
    setTodos(prev =>
      prev.map(t =>
        t.id === todo.id
          ? { ...t, completed: true, completedAt: Date.now() }
          : t
      )
    );
  };

  const handleTodoDelete = async (todoId: string) => {
    // Simulate blockchain deletion
    console.log('Deleting todo from blockchain:', todoId);

    // Update local state immediately for optimistic UI
    setTodos(prev => prev.filter(t => t.id !== todoId));
  };

  const handleTodoUpdate = (updatedTodos: Todo[]) => {
    setTodos(updatedTodos);
    // Optionally save to local storage
    localStorage.setItem('realtimeTodos', JSON.stringify(updatedTodos));
  };

  // Load todos from local storage on mount
  useEffect(() => {
    const savedTodos = localStorage.getItem('realtimeTodos');
    if (savedTodos) {
      setTodos(JSON.parse(savedTodos));
    }
  }, []);

  if (!connected) {
    return (
      <div className='p-4 border rounded-lg text-center'>
        <h3 className='text-lg font-semibold mb-4'>
          Complete Real-time Todo App
        </h3>
        <p className='text-gray-600 mb-4'>
          Please connect your wallet to use the real-time todo application.
        </p>
      </div>
    );
  }

  return (
    <div className='p-4 border rounded-lg'>
      <h3 className='text-lg font-semibold mb-4'>
        Complete Real-time Todo App
      </h3>

      <RealtimeTodoList
        initialTodos={todos}
        listName='My Real-time Todos'
        onTodoUpdate={handleTodoUpdate}
        onTodoComplete={handleTodoComplete}
        onTodoDelete={handleTodoDelete}
        showEventIndicator={true}
      />

      <div className='mt-4 p-3 bg-blue-50 rounded text-sm'>
        <p>
          <strong>Tips:</strong>
        </p>
        <ul className='list-disc list-inside mt-1 space-y-1'>
          <li>Real-time updates when todos are modified on the blockchain</li>
          <li>Visual notifications for new events</li>
          <li>Connection status indicator shows event subscription health</li>
          <li>Automatic reconnection on network issues</li>
        </ul>
      </div>
    </div>
  );
}

/**
 * Demo page showing all examples
 */
export default function BlockchainEventsDemo() {
  const [selectedExample, setSelectedExample] = useState('basic');

  const examples = {
    basic: {
      component: BasicEventSubscription,
      title: 'Basic Event Subscription',
    },
    handlers: { component: TodoEventHandlers, title: 'Todo Event Handlers' },
    sync: { component: TodoStateSync, title: 'Todo State Sync' },
    status: {
      component: ConnectionStatusManagement,
      title: 'Connection Status',
    },
    complete: {
      component: CompleteRealtimeTodoApp,
      title: 'Complete Todo App',
    },
  };

  const SelectedComponent =
    examples[selectedExample as keyof typeof examples].component;

  return (
    <div className='container mx-auto px-4 py-8'>
      <div className='mb-8'>
        <h1 className='text-3xl font-bold mb-4'>
          Blockchain Events Usage Examples
        </h1>
        <p className='text-gray-600 mb-6'>
          Interactive examples demonstrating real-time blockchain event
          integration for TodoNFT smart contracts.
        </p>

        <div className='flex space-x-2 mb-6'>
          {Object.entries(examples).map(([key, { title }]) => (
            <button
              key={key}
              onClick={() => setSelectedExample(key)}
              className={`px-4 py-2 rounded ${
                selectedExample === key
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
              }`}
            >
              {title}
            </button>
          ))}
        </div>
      </div>

      <div className='mb-8'>
        <SelectedComponent />
      </div>

      <div className='mt-8 p-4 bg-yellow-50 border-l-4 border-yellow-400'>
        <h4 className='font-semibold text-yellow-800'>Development Notes</h4>
        <ul className='mt-2 text-sm text-yellow-700 space-y-1'>
          <li> Make sure you have the Sui wallet extension installed</li>
          <li> Connect to testnet for testing TodoNFT events</li>
          <li> Check browser console for detailed event logs</li>
          <li>
             Some features require actual blockchain transactions to trigger
            events
          </li>
        </ul>
      </div>
    </div>
  );
}

/**
 * Individual usage examples for integration
 */

// Simple event listener setup
export function SimpleEventSetup() {
  const { addEventListener } = useBlockchainEvents({ autoStart: true });

  useEffect(() => {
    const unsubscribe = addEventListener('*', event => {
      console.log('Received event:', event);
    });

    return unsubscribe;
  }, [addEventListener]);

  return <div>Event listener active</div>;
}

// Todo creation with real-time feedback
export function TodoCreationWithFeedback() {
  const [isCreating, setIsCreating] = useState(false);
  const { addEventListener } = useBlockchainEvents({ autoStart: true });

  useEffect(() => {
    const unsubscribe = addEventListener('created', event => {
      if (isCreating) {
        setIsCreating(false);
        alert(`Todo created successfully`);
      }
    });

    return unsubscribe;
  }, [addEventListener, isCreating]);

  const createTodo = async () => {
    setIsCreating(true);
    // Trigger blockchain transaction to create todo
    // Event listener will handle success notification
  };

  return (
    <button onClick={createTodo} disabled={isCreating}>
      {isCreating ? 'Creating...' : 'Create Todo'}
    </button>
  );
}
</file>

<file path="src/hooks/useBlockchainEvents.ts">
/**
 * React hooks for blockchain event subscriptions
 * Provides real-time updates for TodoNFT events with automatic state management
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import {
  BlockchainEventManager,
  TodoNFTEvent,
  EventConnectionState,
  EventListener,
  getEventManager,
  transformEventToTodoUpdate,
} from '@/lib/blockchain-events';
import { Todo } from '@/lib/sui-client';
import { useWalletContext } from '@/contexts/WalletContext';

/**
 * Hook for managing blockchain event subscriptions
 */
export function useBlockchainEvents(
  options: {
    autoStart?: boolean;
    owner?: string;
    enableReconnect?: boolean;
  } = {}
) {
  const { autoStart = true, owner, enableReconnect = true } = options;
  const [connectionState, setConnectionState] = useState<EventConnectionState>({
    connected: false,
    connecting: false,
    error: null,
    lastReconnectAttempt: 0,
    reconnectAttempts: 0,
  });

  const eventManagerRef = useRef<BlockchainEventManager | null>(null);
  const { address } = useWalletContext();

  // Use wallet address if no owner specified
  const targetOwner = owner || address;

  /**
   * Initialize event manager
   */
  const initialize = useCallback(async () => {
    try {
      if (!eventManagerRef.current) {
        eventManagerRef.current = getEventManager({
          autoReconnect: enableReconnect,
        });
      }

      await eventManagerRef.current.initialize();
      setConnectionState(eventManagerRef.current.getConnectionState());
    } catch (error) {
      console.error('Failed to initialize blockchain events:', error);
      setConnectionState(prev => ({
        ...prev,
        error: error as Error,
        connecting: false,
      }));
    }
  }, [enableReconnect]);

  /**
   * Start event subscriptions
   */
  const startSubscription = useCallback(async () => {
    if (!eventManagerRef.current) {
      await initialize();
    }

    if (!eventManagerRef.current) return;

    try {
      setConnectionState(prev => ({ ...prev, connecting: true }));
      await eventManagerRef.current.subscribeToEvents(targetOwner || undefined);
      setConnectionState(eventManagerRef.current.getConnectionState());
    } catch (error) {
      console.error('Failed to start event subscription:', error);
      setConnectionState(prev => ({
        ...prev,
        error: error as Error,
        connecting: false,
      }));
    }
  }, [initialize, targetOwner]);

  /**
   * Stop event subscriptions
   */
  const stopSubscription = useCallback(() => {
    if (eventManagerRef.current) {
      eventManagerRef.current.unsubscribeAll();
      setConnectionState(eventManagerRef.current.getConnectionState());
    }
  }, []);

  /**
   * Restart event subscriptions
   */
  const restartSubscription = useCallback(async () => {
    stopSubscription();
    await startSubscription();
  }, [stopSubscription, startSubscription]);

  /**
   * Add event listener
   */
  const addEventListener = useCallback(
    (eventType: string | '*', listener: EventListener): (() => void) => {
      if (!eventManagerRef.current) {
        // Don't spam console with warnings, just return noop
        return () => {};
      }

      return eventManagerRef.current.addEventListener(eventType, listener);
    },
    []
  );

  // Auto-start subscription when wallet connects
  useEffect(() => {
    if (autoStart && targetOwner) {
      startSubscription();
    }

    return () => {
      if (eventManagerRef.current) {
        eventManagerRef.current.destroy();
      }
    };
  }, [autoStart, targetOwner, startSubscription]);

  // Update connection state periodically
  useEffect(() => {
    if (!eventManagerRef.current) return;

    const interval = setInterval(() => {
      setConnectionState(eventManagerRef.current!.getConnectionState());
    }, 5000);

    return () => clearInterval(interval);
  }, []);

  return {
    connectionState,
    startSubscription,
    stopSubscription,
    restartSubscription,
    addEventListener,
    isConnected: connectionState.connected,
    isConnecting: connectionState.connecting,
    error: connectionState.error,
  };
}

/**
 * Hook for real-time todo updates from blockchain events
 */
export function useTodoEvents(
  options: {
    onTodoCreated?: (todo: Partial<Todo>) => void;
    onTodoUpdated?: (todo: Partial<Todo>) => void;
    onTodoCompleted?: (todo: Partial<Todo>) => void;
    onTodoDeleted?: (todoId: string) => void;
    owner?: string;
    autoStart?: boolean;
  } = {}
) {
  const {
    onTodoCreated,
    onTodoUpdated,
    onTodoCompleted,
    onTodoDeleted,
    owner,
    autoStart = true,
  } = options;

  const [recentEvents, setRecentEvents] = useState<TodoNFTEvent[]>([]);
  const { addEventListener, ...eventHookResult } = useBlockchainEvents({
    autoStart,
    owner,
  });

  // Handle todo events
  useEffect(() => {
    const unsubscribe = addEventListener('*', (event: TodoNFTEvent) => {
      // Add to recent events list
      setRecentEvents(prev => [event, ...prev.slice(0, 49)]); // Keep last 50 events

      // Transform event to todo update
      const todoUpdate = transformEventToTodoUpdate(event);

      // Call appropriate callback
      switch (event.type) {
        case 'created':
          if (todoUpdate && onTodoCreated) {
            onTodoCreated(todoUpdate);
          }
          break;
        case 'updated':
          if (todoUpdate && onTodoUpdated) {
            onTodoUpdated(todoUpdate);
          }
          break;
        case 'completed':
          if (todoUpdate && onTodoCompleted) {
            onTodoCompleted(todoUpdate);
          }
          break;
        case 'deleted':
          if (onTodoDeleted) {
            onTodoDeleted(event.data.todo_id);
          }
          break;
      }
    });

    return unsubscribe;
  }, [
    addEventListener,
    onTodoCreated,
    onTodoUpdated,
    onTodoCompleted,
    onTodoDeleted,
  ]);

  return {
    ...eventHookResult,
    recentEvents,
    clearRecentEvents: () => setRecentEvents([]),
  };
}

/**
 * Hook for real-time todo state synchronization
 * Automatically updates local state when blockchain events occur
 */
export function useTodoStateSync(
  options: {
    todos: Todo[];
    onTodoChange: (todos: Todo[]) => void;
    owner?: string;
    autoStart?: boolean;
  } = {} as any
) {
  const { todos, onTodoChange, owner, autoStart = true } = options;
  const [syncedTodos, setSyncedTodos] = useState<Todo[]>(todos || []);

  const { ...eventHookResult } = useTodoEvents({
    owner,
    autoStart,
    onTodoCreated: todoUpdate => {
      setSyncedTodos(prev => {
        // Check if todo already exists
        const existingIndex = prev.findIndex(
          t => t.id === todoUpdate.id || t.objectId === todoUpdate.id
        );
        if (existingIndex >= 0) {
          // Update existing todo
          const updated = [...prev];
          updated[existingIndex] = { ...updated[existingIndex], ...todoUpdate };
          return updated;
        } else {
          // Add new todo
          const newTodo: Todo = {
            id: todoUpdate.id || '',
            title: todoUpdate.title || 'Untitled',
            completed: false,
            priority: 'medium',
            blockchainStored: true,
            ...todoUpdate,
          };
          return [...prev, newTodo];
        }
      });
    },
    onTodoUpdated: todoUpdate => {
      setSyncedTodos(prev => {
        const index = prev.findIndex(
          t => t.id === todoUpdate.id || t.objectId === todoUpdate.id
        );
        if (index >= 0) {
          const updated = [...prev];
          updated[index] = { ...updated[index], ...todoUpdate };
          return updated;
        }
        return prev;
      });
    },
    onTodoCompleted: todoUpdate => {
      setSyncedTodos(prev => {
        const index = prev.findIndex(
          t => t.id === todoUpdate.id || t.objectId === todoUpdate.id
        );
        if (index >= 0) {
          const updated = [...prev];
          updated[index] = { ...updated[index], ...todoUpdate };
          return updated;
        }
        return prev;
      });
    },
    onTodoDeleted: todoId => {
      setSyncedTodos(prev =>
        prev.filter(t => t.id !== todoId && t.objectId !== todoId)
      );
    },
  });

  // Update parent component when todos change
  useEffect(() => {
    if (onTodoChange) {
      onTodoChange(syncedTodos);
    }
  }, [syncedTodos, onTodoChange]);

  // Update local state when external todos change
  useEffect(() => {
    setSyncedTodos(todos || []);
  }, [todos]);

  return {
    ...eventHookResult,
    syncedTodos,
  };
}

/**
 * Hook for connection status with visual indicators
 */
export function useEventConnectionStatus() {
  const { connectionState, restartSubscription } = useBlockchainEvents({
    autoStart: false,
  });

  const getStatusColor = useCallback(() => {
    if (connectionState.connecting) return 'yellow';
    if (connectionState.connected) return 'green';
    if (connectionState.error) return 'red';
    return 'gray';
  }, [connectionState]);

  const getStatusText = useCallback(() => {
    if (connectionState.connecting) return 'Connecting...';
    if (connectionState.connected) return 'Connected';
    if (connectionState.error) return `Error: ${connectionState.error.message}`;
    return 'Disconnected';
  }, [connectionState]);

  const canReconnect = useCallback(() => {
    return !connectionState.connecting && !connectionState.connected;
  }, [connectionState]);

  return {
    connectionState,
    statusColor: getStatusColor(),
    statusText: getStatusText(),
    canReconnect: canReconnect(),
    reconnect: restartSubscription,
  };
}
</file>

<file path="src/hooks/useInactivityTimer.ts">
/**
 * Hook for managing user inactivity timing
 * Used by wallet context for session management
 */

import { useState, useEffect, useCallback } from 'react';

interface UseInactivityTimerOptions {
  timeout: number; // timeout in milliseconds
  onTimeout: () => void;
  events?: string[]; // activity events to listen for
  throttle?: number; // throttle activity updates (ms)
}

const DEFAULT_EVENTS = ['mousedown', 'keydown', 'touchstart', 'scroll'];

export function useInactivityTimer({
  timeout,
  onTimeout,
  events = DEFAULT_EVENTS,
  throttle = 1000,
}: UseInactivityTimerOptions) {
  const [lastActivity, setLastActivity] = useState<number>(Date.now());
  const [isActive, setIsActive] = useState<boolean>(true);

  const resetActivityTimer = useCallback(() => {
    const now = Date.now();

    // Throttle updates to avoid excessive state changes
    if (now - lastActivity > throttle) {
      setLastActivity(now);
      setIsActive(true);
    }
  }, [lastActivity, throttle]);

  useEffect(() => {
    if (typeof window === 'undefined') return;

    const handleActivity = () => resetActivityTimer();

    // Set up event listeners to track activity
    events.forEach(event => {
      window.addEventListener(event, handleActivity, { passive: true });
    });

    // Check for timeout periodically
    const interval = setInterval(() => {
      const now = Date.now();
      const timeSinceLastActivity = now - lastActivity;

      if (timeSinceLastActivity >= timeout) {
        setIsActive(false);
        onTimeout();
      }
    }, 60000); // Check every minute

    return () => {
      events.forEach(event => {
        window.removeEventListener(event, handleActivity);
      });
      clearInterval(interval);
    };
  }, [lastActivity, timeout, onTimeout, events, resetActivityTimer]);

  return {
    lastActivity,
    isActive,
    resetActivityTimer,
    timeUntilTimeout: Math.max(0, timeout - (Date.now() - lastActivity)),
  };
}
</file>

<file path="src/hooks/useSuiTodos.ts">
/**
 * React hook for TodoNFT operations with wallet integration
 * Provides easy-to-use interface for blockchain todo operations
 */

'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';

// Use the Todo type from sui-client
type Todo = SuiTodo;

interface CreateTodoParams {
  title: string;
  description: string;
  priority?: 'low' | 'medium' | 'high';
  dueDate?: string;
  tags?: string[];
}

interface UpdateTodoParams {
  objectId: string;
  title?: string;
  description?: string;
  priority?: 'low' | 'medium' | 'high';
  dueDate?: string;
}

interface TransactionResult {
  success: boolean;
  digest?: string;
  error?: string;
}

type NetworkType = 'mainnet' | 'testnet' | 'devnet' | 'localnet';

interface UseSuiTodosState {
  todos: Todo[];
  loading: boolean;
  error: string | null;
  networkHealth: boolean;
  refreshing: boolean;
}

interface UseSuiTodosActions {
  createTodo: (params: CreateTodoParams) => Promise<TransactionResult>;
  updateTodo: (params: UpdateTodoParams) => Promise<TransactionResult>;
  completeTodo: (objectId: string) => Promise<TransactionResult>;
  deleteTodo: (objectId: string) => Promise<TransactionResult>;
  refreshTodos: () => Promise<void>;
  switchToNetwork: (network: NetworkType) => Promise<void>;
  checkHealth: () => Promise<void>;
  clearError: () => void;
}

interface UseSuiTodosReturn {
  state: UseSuiTodosState;
  actions: UseSuiTodosActions;
  network: NetworkType;
  isWalletReady: boolean;
}

import { useWalletContext } from '@/contexts/WalletContext';
import {
  storeTodoOnBlockchain,
  retrieveTodosFromBlockchain,
  completeTodoOnBlockchain,
  transferTodoNFT,
  addTodo,
  getTodos,
  getTodoList,
  updateTodo as updateLocalTodo,
  deleteTodo as deleteLocalTodo,
  type WalletSigner,
} from '@/lib/todo-service';
import { Todo as SuiTodo, TodoList } from '@/lib/sui-client';

/**
 * Hook for managing TodoNFTs on Sui blockchain
 */
export function useSuiTodos(): UseSuiTodosReturn {
  const walletContext = useWalletContext();
  const {
    connected,
    address,
    trackTransaction,
    error: walletError,
    setError: setWalletError,
  } = walletContext;

  const [state, setState] = useState<UseSuiTodosState>({
    todos: [],
    loading: false,
    error: null,
    networkHealth: true,
    refreshing: false,
  });

  const [currentNetwork, setCurrentNetwork] = useState<NetworkType>('testnet');

  // Check if wallet is ready for operations
  const isWalletReady = useMemo(() => {
    return Boolean(connected && address && !walletError);
  }, [connected, address, walletError]);

  // Set error helper
  const setError = useCallback((error: string | null) => {
    setState(prev => ({ ...prev, error }));
  }, []);

  // Set loading helper
  const setLoading = useCallback((loading: boolean) => {
    setState(prev => ({ ...prev, loading }));
  }, []);

  // Set refreshing helper
  const setRefreshing = useCallback((refreshing: boolean) => {
    setState(prev => ({ ...prev, refreshing }));
  }, []);

  // Clear error
  const clearError = useCallback(() => {
    setError(null);
    setWalletError(null);
  }, [setError, setWalletError]);

  // Check network health
  const checkHealth = useCallback(async () => {
    try {
      // Mock health check - always returns healthy
      setState(prev => ({ ...prev, networkHealth: true }));
    } catch (error) {
      setState(prev => ({ ...prev, networkHealth: false }));
      setError(
        `Health check failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }, [setError]);

  // Fetch todos from blockchain and local storage
  const refreshTodos = useCallback(async () => {
    if (!address) {
      // Load anonymous todos when no wallet connected
      const localTodos = getTodos('default');
      setState(prev => ({ ...prev, todos: localTodos }));
      return;
    }

    setRefreshing(true);
    setError(null);

    try {
      // Fetch todos from blockchain
      const blockchainTodos = await retrieveTodosFromBlockchain(address);

      // Also get local todos for this wallet
      const localTodos = getTodos('default', address);

      // Merge blockchain and local todos (blockchain takes precedence for duplicates)
      const todoMap = new Map<string, Todo>();

      // Add local todos first
      localTodos.forEach(todo => {
        todoMap.set(todo.id, todo);
      });

      // Add/override with blockchain todos
      blockchainTodos.forEach(todo => {
        todoMap.set(todo.id, todo);
      });

      const mergedTodos = Array.from(todoMap.values());

      setState(prev => ({ ...prev, todos: mergedTodos }));
    } catch (error) {
      setError('Failed to fetch todos');
      console.error('Error fetching todos:', error);

      // Fallback to local todos only
      const localTodos = getTodos('default', address);
      setState(prev => ({ ...prev, todos: localTodos }));
    } finally {
      setRefreshing(false);
    }
  }, [address, setError, setRefreshing]);

  // Switch to different network
  const switchToNetwork = useCallback(
    async (network: NetworkType) => {
      setLoading(true);
      setError(null);

      try {
        // Update network state
        setCurrentNetwork(network);

        // Refresh todos after network switch
        if (isWalletReady) {
          await refreshTodos();
        }
      } catch (error) {
        setError(`Failed to switch to ${network} network`);
        console.error('Network switch error:', error);
      } finally {
        setLoading(false);
      }
    },
    [isWalletReady, refreshTodos, setError, setLoading]
  );

  // Create todo (locally first, then optionally on blockchain)
  const createTodo = useCallback(
    async (params: CreateTodoParams): Promise<TransactionResult> => {
      setLoading(true);
      setError(null);

      try {
        // First, create the todo locally
        const newTodo = addTodo(
          'default',
          {
            title: params.title,
            description: params.description,
            completed: false,
            priority: params.priority || 'medium',
            tags: params.tags,
            dueDate: params.dueDate,
          },
          address || undefined
        );

        // If wallet is connected, also store on blockchain
        if (
          isWalletReady &&
          address &&
          walletContext.signAndExecuteTransaction
        ) {
          const walletSigner: WalletSigner = {
            signAndExecuteTransaction: walletContext.signAndExecuteTransaction,
            address,
          };

          const todoPromise = storeTodoOnBlockchain(
            'default',
            newTodo.id,
            walletSigner,
            address
          ).then(objectId => ({ digest: objectId || undefined }));

          const result = await trackTransaction(todoPromise, 'Create Todo NFT');
          const objectId = result.digest;

          if (objectId) {
            // Refresh to get updated blockchain state
            await refreshTodos();
            return { success: true, digest: objectId };
          }
        }

        // For local-only todos, still refresh to update UI
        await refreshTodos();
        return { success: true, digest: newTodo.id };
      } catch (error) {
        const message =
          error instanceof Error ? error.message : 'Failed to create todo';
        setError(message);
        return { success: false, error: message };
      } finally {
        setLoading(false);
      }
    },
    [
      isWalletReady,
      address,
      trackTransaction,
      refreshTodos,
      setError,
      setLoading,
      walletContext.signAndExecuteTransaction,
    ]
  );

  // Update todo on blockchain
  const updateTodo = useCallback(
    async (params: UpdateTodoParams): Promise<TransactionResult> => {
      if (!isWalletReady || !address) {
        throw new Error('Wallet not connected');
      }

      setLoading(true);
      setError(null);

      try {
        // Mock transaction
        const result: TransactionResult = {
          success: true,
          digest: 'mock_digest_' + Date.now(),
        };

        // Simulate transaction delay
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Update mock todo in state
        setState(prev => ({
          ...prev,
          todos: prev.todos.map(todo =>
            todo.objectId === params.objectId
              ? {
                  ...todo,
                  title: params.title || todo.title,
                  description: params.description || todo.description,
                  priority: params.priority || todo.priority,
                  dueDate: params.dueDate || todo.dueDate,
                  updatedAt: new Date().toISOString(),
                }
              : todo
          ),
        }));

        return result;
      } catch (error) {
        const message =
          error instanceof Error ? error.message : 'Failed to update todo';
        setError(message);
        throw error;
      } finally {
        setLoading(false);
      }
    },
    [isWalletReady, address, setError, setLoading]
  );

  // Complete todo
  const completeTodo = useCallback(
    async (todoId: string): Promise<TransactionResult> => {
      setLoading(true);
      setError(null);

      try {
        // Find the todo
        const todo = state.todos.find(
          t => t.id === todoId || t.objectId === todoId
        );
        if (!todo) {
          throw new Error('Todo not found');
        }

        // Update locally first
        todo.completed = true;
        updateLocalTodo('default', todo, address || undefined);

        // If it's a blockchain todo and wallet is connected, complete on blockchain
        if (
          todo.blockchainStored &&
          todo.objectId &&
          isWalletReady &&
          address &&
          walletContext.signAndExecuteTransaction
        ) {
          const walletSigner: WalletSigner = {
            signAndExecuteTransaction: walletContext.signAndExecuteTransaction,
            address,
          };

          const completePromise = completeTodoOnBlockchain(
            'default',
            todo.id,
            walletSigner,
            address
          ).then(success => ({ digest: success ? 'completed' : undefined }));

          const result = await trackTransaction(
            completePromise,
            'Complete Todo NFT'
          );
          const success = !!result.digest;

          if (!success) {
            throw new Error('Failed to complete todo on blockchain');
          }
        }

        // Refresh todos
        await refreshTodos();
        return { success: true, digest: todo.objectId || todo.id };
      } catch (error) {
        const message =
          error instanceof Error ? error.message : 'Failed to complete todo';
        setError(message);
        return { success: false, error: message };
      } finally {
        setLoading(false);
      }
    },
    [
      state.todos,
      isWalletReady,
      address,
      trackTransaction,
      refreshTodos,
      setError,
      setLoading,
      walletContext.signAndExecuteTransaction,
    ]
  );

  // Transfer todo NFT (delete locally after transfer)
  const deleteTodo = useCallback(
    async (todoId: string): Promise<TransactionResult> => {
      setLoading(true);
      setError(null);

      try {
        // Find the todo
        const todo = state.todos.find(
          t => t.id === todoId || t.objectId === todoId
        );
        if (!todo) {
          throw new Error('Todo not found');
        }

        // For blockchain todos, we can't delete - only transfer
        // For local todos, we can delete directly
        if (!todo.blockchainStored) {
          // Delete local todo
          const deleted = deleteLocalTodo(
            'default',
            todo.id,
            address || undefined
          );
          if (deleted) {
            await refreshTodos();
            return { success: true, digest: todo.id };
          }
        } else {
          // For blockchain todos, inform user they need to transfer it
          throw new Error(
            'Blockchain todos cannot be deleted, only transferred to another address'
          );
        }

        return { success: false, error: 'Failed to delete todo' };
      } catch (error) {
        const message =
          error instanceof Error ? error.message : 'Failed to delete todo';
        setError(message);
        return { success: false, error: message };
      } finally {
        setLoading(false);
      }
    },
    [state.todos, address, refreshTodos, setError, setLoading]
  );

  // Auto-refresh todos when wallet connects
  useEffect(() => {
    if (isWalletReady) {
      refreshTodos();
      checkHealth();
    }
  }, [isWalletReady, refreshTodos, checkHealth]);

  // Auto-check health periodically
  useEffect(() => {
    if (!isWalletReady) return;

    const interval = setInterval(() => {
      checkHealth();
    }, 30000); // Check every 30 seconds

    return () => clearInterval(interval);
  }, [isWalletReady, checkHealth]);

  return {
    state,
    actions: {
      createTodo,
      updateTodo,
      completeTodo,
      deleteTodo,
      refreshTodos,
      switchToNetwork,
      checkHealth,
      clearError,
    },
    network: currentNetwork,
    isWalletReady,
  };
}

// Helper hook for individual todo operations
export function useTodoOperation() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [result, setResult] = useState<TransactionResult | null>(null);

  const executeOperation = useCallback(
    async (operation: () => Promise<TransactionResult>) => {
      setLoading(true);
      setError(null);
      setResult(null);

      try {
        const operationResult = await operation();
        setResult(operationResult);
        return operationResult;
      } catch (error) {
        const message =
          error instanceof Error ? error.message : 'Operation failed';
        setError(message);
        throw error;
      } finally {
        setLoading(false);
      }
    },
    []
  );

  const clearState = useCallback(() => {
    setError(null);
    setResult(null);
  }, []);

  return {
    loading,
    error,
    result,
    executeOperation,
    clearState,
  };
}

export type {
  Todo,
  CreateTodoParams,
  UpdateTodoParams,
  TransactionResult,
  NetworkType,
  UseSuiTodosState,
  UseSuiTodosActions,
  UseSuiTodosReturn,
};
</file>

<file path="src/hooks/useWalrusStorage.ts">
/**
 * React Hook for Walrus Protocol Storage Operations
 *
 * This hook provides a React interface to Walrus storage operations
 * with proper state management, error handling, and loading states.
 */

import { useState, useCallback, useRef, useEffect } from 'react';
import {
  WalrusTodoManager,
  WalrusTodo,
  WalrusTodoCreateResult,
  WalrusTodoUploadOptions,
  TodoStorageMetadata,
  WalrusClientError,
  type WalrusNetwork,
} from '@/lib/walrus-todo-integration';
import { useWalletContext } from '@/contexts/WalletContext';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import type { Signer } from '@mysten/sui/cryptography';

// Hook state interface
interface WalrusStorageState {
  loading: boolean;
  uploading: boolean;
  downloading: boolean;
  deleting: boolean;
  progress: number;
  progressMessage: string;
  error: WalrusClientError | null;
  walBalance: string | null;
  storageUsage: { used: string; total: string } | null;
}

// Hook return interface
interface UseWalrusStorageReturn extends WalrusStorageState {
  // Todo operations
  createTodo: (
    todo: Omit<
      WalrusTodo,
      'id' | 'createdAt' | 'updatedAt' | 'blockchainStored'
    >,
    options?: WalrusTodoUploadOptions
  ) => Promise<WalrusTodoCreateResult | null>;

  retrieveTodo: (walrusBlobId: string) => Promise<WalrusTodo | null>;

  updateTodo: (
    todo: WalrusTodo,
    options?: Partial<WalrusTodoUploadOptions>
  ) => Promise<boolean>;

  deleteTodo: (walrusBlobId: string) => Promise<boolean>;

  // Batch operations
  createMultipleTodos: (
    todos: Array<
      Omit<WalrusTodo, 'id' | 'createdAt' | 'updatedAt' | 'blockchainStored'>
    >,
    options?: WalrusTodoUploadOptions
  ) => Promise<WalrusTodoCreateResult[]>;

  // Storage info operations
  getTodoStorageInfo: (walrusBlobId: string) => Promise<{
    exists: boolean;
    blobInfo?: any;
    storageCost?: { total: bigint; storage: bigint; write: bigint };
  } | null>;

  estimateStorageCosts: (
    todos: Array<
      Omit<WalrusTodo, 'id' | 'createdAt' | 'updatedAt' | 'blockchainStored'>
    >,
    epochs?: number
  ) => Promise<{
    totalCost: bigint;
    totalSize: number;
    perTodoCost: Array<{ totalCost: bigint; size: number }>;
  } | null>;

  // Utility operations
  refreshWalBalance: () => Promise<void>;
  refreshStorageUsage: () => Promise<void>;
  clearError: () => void;
  reset: () => void;
}

// Options for the hook
interface UseWalrusStorageOptions {
  network?: WalrusNetwork;
  autoRefreshBalance?: boolean;
  autoRefreshUsage?: boolean;
  refreshInterval?: number;
}

/**
 * React hook for Walrus Protocol storage operations
 */
export function useWalrusStorage(
  options: UseWalrusStorageOptions = {}
): UseWalrusStorageReturn {
  const {
    network = 'testnet',
    autoRefreshBalance = true,
    autoRefreshUsage = true,
    refreshInterval = 30000, // 30 seconds
  } = options;

  // Get wallet context
  const { connected, address, error: walletError } = useWalletContext();

  // State management
  const [state, setState] = useState<WalrusStorageState>({
    loading: false,
    uploading: false,
    downloading: false,
    deleting: false,
    progress: 0,
    progressMessage: '',
    error: null,
    walBalance: null,
    storageUsage: null,
  });

  // Walrus manager instance
  const walrusManagerRef = useRef<WalrusTodoManager | null>(null);

  // Initialize manager
  useEffect(() => {
    walrusManagerRef.current = new WalrusTodoManager(network);
  }, [network]);

  // Get current manager
  const getManager = useCallback((): WalrusTodoManager => {
    if (!walrusManagerRef.current) {
      walrusManagerRef.current = new WalrusTodoManager(network);
    }
    return walrusManagerRef.current;
  }, [network]);

  // Helper function to handle errors
  const handleError = useCallback(
    (error: unknown, operation: string): WalrusClientError => {
      let walrusError: WalrusClientError;

      if (error instanceof WalrusClientError) {
        walrusError = error;
      } else {
        walrusError = new WalrusClientError(
          `${operation} failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
          'OPERATION_ERROR',
          error instanceof Error ? error : undefined
        );
      }

      setState(prev => ({ ...prev, error: walrusError, loading: false }));
      return walrusError;
    },
    []
  );

  // Helper function to update progress
  const updateProgress = useCallback((message: string, progress: number) => {
    setState(prev => ({
      ...prev,
      progressMessage: message,
      progress: Math.max(0, Math.min(100, progress)),
    }));
  }, []);

  // Create todo operation
  const createTodo = useCallback(
    async (
      todo: Omit<
        WalrusTodo,
        'id' | 'createdAt' | 'updatedAt' | 'blockchainStored'
      >,
      options: WalrusTodoUploadOptions = {}
    ): Promise<WalrusTodoCreateResult | null> => {
      if (!connected || !address) {
        handleError(new Error('Wallet not connected'), 'Create Todo');
        return null;
      }

      setState(prev => ({
        ...prev,
        uploading: true,
        loading: true,
        error: null,
        progress: 0,
        progressMessage: 'Starting upload...',
      }));

      try {
        const manager = getManager();

        // Create a mock signer for now - in real implementation, get from wallet
        const signer = new Ed25519Keypair();

        const result = await manager.createTodo(
          todo,
          signer,
          undefined, // signAndExecuteTransaction - would come from wallet context
          {
            ...options,
            onProgress: updateProgress,
          }
        );

        setState(prev => ({
          ...prev,
          uploading: false,
          loading: false,
          progress: 100,
          progressMessage: 'Upload complete',
        }));

        return result;
      } catch (error) {
        setState(prev => ({ ...prev, uploading: false }));
        handleError(error, 'Create Todo');
        return null;
      }
    },
    [connected, address, getManager, handleError, updateProgress]
  );

  // Retrieve todo operation
  const retrieveTodo = useCallback(
    async (walrusBlobId: string): Promise<WalrusTodo | null> => {
      setState(prev => ({
        ...prev,
        downloading: true,
        loading: true,
        error: null,
        progressMessage: 'Downloading todo...',
      }));

      try {
        const manager = getManager();
        const result = await manager.retrieveTodo(walrusBlobId);

        setState(prev => ({
          ...prev,
          downloading: false,
          loading: false,
          progressMessage: 'Download complete',
        }));

        return result;
      } catch (error) {
        setState(prev => ({ ...prev, downloading: false }));
        handleError(error, 'Retrieve Todo');
        return null;
      }
    },
    [getManager, handleError]
  );

  // Update todo operation
  const updateTodo = useCallback(
    async (
      todo: WalrusTodo,
      options: Partial<WalrusTodoUploadOptions> = {}
    ): Promise<boolean> => {
      if (!connected || !address) {
        handleError(new Error('Wallet not connected'), 'Update Todo');
        return false;
      }

      setState(prev => ({
        ...prev,
        uploading: true,
        loading: true,
        error: null,
        progressMessage: 'Updating todo...',
      }));

      try {
        const manager = getManager();
        const signer = new Ed25519Keypair(); // Mock signer

        await manager.updateTodo(todo, signer, options);

        setState(prev => ({
          ...prev,
          uploading: false,
          loading: false,
          progressMessage: 'Update complete',
        }));

        return true;
      } catch (error) {
        setState(prev => ({ ...prev, uploading: false }));
        handleError(error, 'Update Todo');
        return false;
      }
    },
    [connected, address, getManager, handleError]
  );

  // Delete todo operation
  const deleteTodo = useCallback(
    async (walrusBlobId: string): Promise<boolean> => {
      if (!connected || !address) {
        handleError(new Error('Wallet not connected'), 'Delete Todo');
        return false;
      }

      setState(prev => ({
        ...prev,
        deleting: true,
        loading: true,
        error: null,
        progressMessage: 'Deleting todo...',
      }));

      try {
        const manager = getManager();
        const signer = new Ed25519Keypair(); // Mock signer

        await manager.deleteTodo(walrusBlobId, signer);

        setState(prev => ({
          ...prev,
          deleting: false,
          loading: false,
          progressMessage: 'Delete complete',
        }));

        return true;
      } catch (error) {
        setState(prev => ({ ...prev, deleting: false }));
        handleError(error, 'Delete Todo');
        return false;
      }
    },
    [connected, address, getManager, handleError]
  );

  // Create multiple todos
  const createMultipleTodos = useCallback(
    async (
      todos: Array<
        Omit<WalrusTodo, 'id' | 'createdAt' | 'updatedAt' | 'blockchainStored'>
      >,
      options: WalrusTodoUploadOptions = {}
    ): Promise<WalrusTodoCreateResult[]> => {
      if (!connected || !address) {
        handleError(new Error('Wallet not connected'), 'Create Multiple Todos');
        return [];
      }

      setState(prev => ({
        ...prev,
        uploading: true,
        loading: true,
        error: null,
        progress: 0,
        progressMessage: 'Starting batch upload...',
      }));

      try {
        const manager = getManager();
        const signer = new Ed25519Keypair(); // Mock signer

        const results = await manager.createMultipleTodos(
          todos,
          signer,
          undefined, // signAndExecuteTransaction
          {
            ...options,
            onProgress: updateProgress,
          }
        );

        setState(prev => ({
          ...prev,
          uploading: false,
          loading: false,
          progress: 100,
          progressMessage: 'Batch upload complete',
        }));

        return results;
      } catch (error) {
        setState(prev => ({ ...prev, uploading: false }));
        handleError(error, 'Create Multiple Todos');
        return [];
      }
    },
    [connected, address, getManager, handleError, updateProgress]
  );

  // Get todo storage info
  const getTodoStorageInfo = useCallback(
    async (walrusBlobId: string) => {
      setState(prev => ({ ...prev, loading: true, error: null }));

      try {
        const manager = getManager();
        const result = await manager.getTodoStorageInfo(walrusBlobId);

        setState(prev => ({ ...prev, loading: false }));
        return result;
      } catch (error) {
        handleError(error, 'Get Storage Info');
        return null;
      }
    },
    [getManager, handleError]
  );

  // Estimate storage costs
  const estimateStorageCosts = useCallback(
    async (
      todos: Array<
        Omit<WalrusTodo, 'id' | 'createdAt' | 'updatedAt' | 'blockchainStored'>
      >,
      epochs: number = 5
    ) => {
      setState(prev => ({ ...prev, loading: true, error: null }));

      try {
        const manager = getManager();
        const result = await manager.estimateStorageCosts(todos, epochs);

        setState(prev => ({ ...prev, loading: false }));
        return result;
      } catch (error) {
        handleError(error, 'Estimate Storage Costs');
        return null;
      }
    },
    [getManager, handleError]
  );

  // Refresh WAL balance
  const refreshWalBalance = useCallback(async () => {
    try {
      const manager = getManager();
      const balance = await manager.getWalBalance();
      setState(prev => ({ ...prev, walBalance: balance }));
    } catch (error) {
      console.warn('Failed to refresh WAL balance:', error);
    }
  }, [getManager]);

  // Refresh storage usage
  const refreshStorageUsage = useCallback(async () => {
    try {
      const manager = getManager();
      const usage = await manager.getStorageUsage();
      setState(prev => ({ ...prev, storageUsage: usage }));
    } catch (error) {
      console.warn('Failed to refresh storage usage:', error);
    }
  }, [getManager]);

  // Clear error state
  const clearError = useCallback(() => {
    setState(prev => ({ ...prev, error: null }));
  }, []);

  // Reset all state
  const reset = useCallback(() => {
    setState({
      loading: false,
      uploading: false,
      downloading: false,
      deleting: false,
      progress: 0,
      progressMessage: '',
      error: null,
      walBalance: null,
      storageUsage: null,
    });
  }, []);

  // Auto-refresh balance and usage
  useEffect(() => {
    if (!connected) return;

    if (autoRefreshBalance) {
      refreshWalBalance();
    }
    if (autoRefreshUsage) {
      refreshStorageUsage();
    }

    if (refreshInterval > 0 && (autoRefreshBalance || autoRefreshUsage)) {
      const interval = setInterval(() => {
        if (autoRefreshBalance) refreshWalBalance();
        if (autoRefreshUsage) refreshStorageUsage();
      }, refreshInterval);

      return () => clearInterval(interval);
    }
  }, [
    connected,
    autoRefreshBalance,
    autoRefreshUsage,
    refreshInterval,
    refreshWalBalance,
    refreshStorageUsage,
  ]);

  // Clear error when wallet error changes
  useEffect(() => {
    if (walletError) {
      setState(prev => ({ ...prev, error: null }));
    }
  }, [walletError]);

  return {
    ...state,
    createTodo,
    retrieveTodo,
    updateTodo,
    deleteTodo,
    createMultipleTodos,
    getTodoStorageInfo,
    estimateStorageCosts,
    refreshWalBalance,
    refreshStorageUsage,
    clearError,
    reset,
  };
}

// Export type for external use
export type {
  UseWalrusStorageReturn,
  WalrusStorageState,
  UseWalrusStorageOptions,
};
</file>

<file path="src/lib/api-client.ts">
import { Todo, TodoList } from '../types/todo';

export interface SyncStatus {
  todoId: string;
  walrusBlobId?: string;
  nftObjectId?: string;
  lastSynced?: Date;
  syncStatus: 'pending' | 'synced' | 'failed';
  error?: string;
}

export interface AIResponse {
  result: any;
  verified?: boolean;
  proof?: string;
}

export class TodoAPIClient {
  private baseURL: string;
  private apiKey?: string;

  constructor() {
    this.baseURL =
      process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api';
    this.apiKey = process.env.NEXT_PUBLIC_API_KEY;
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      ...((options.headers as Record<string, string>) || {}),
    };

    if (this.apiKey) {
      headers['X-API-Key'] = this.apiKey;
    }

    const response = await fetch(`${this.baseURL}${endpoint}`, {
      ...options,
      headers,
    });

    if (!response.ok) {
      const error = await response
        .json()
        .catch(() => ({ message: response.statusText }));
      throw new Error(error.message || `Request failed: ${response.status}`);
    }

    return response.json();
  }

  // Todo operations
  async getTodos(listName: string = 'default'): Promise<Todo[]> {
    return this.request<Todo[]>(`/todos?list=${listName}`);
  }

  async getTodo(id: string): Promise<Todo> {
    return this.request<Todo>(`/todos/${id}`);
  }

  async createTodo(
    todo: Partial<Todo>,
    listName: string = 'default'
  ): Promise<Todo> {
    return this.request<Todo>('/todos', {
      method: 'POST',
      body: JSON.stringify({ ...todo, listName }),
    });
  }

  async updateTodo(id: string, updates: Partial<Todo>): Promise<Todo> {
    return this.request<Todo>(`/todos/${id}`, {
      method: 'PUT',
      body: JSON.stringify(updates),
    });
  }

  async deleteTodo(id: string): Promise<void> {
    await this.request<void>(`/todos/${id}`, {
      method: 'DELETE',
    });
  }

  async completeTodo(id: string): Promise<Todo> {
    return this.request<Todo>(`/todos/${id}/complete`, {
      method: 'POST',
    });
  }

  // List operations
  async getLists(): Promise<string[]> {
    return this.request<string[]>('/lists');
  }

  async createList(name: string): Promise<TodoList> {
    return this.request<TodoList>('/lists', {
      method: 'POST',
      body: JSON.stringify({ name }),
    });
  }

  async deleteList(name: string): Promise<void> {
    await this.request<void>(`/lists/${name}`, {
      method: 'DELETE',
    });
  }

  // AI operations
  async suggestTasks(context: {
    existingTodos: Todo[];
    preferences?: any;
  }): Promise<AIResponse> {
    return this.request<AIResponse>('/ai/suggest', {
      method: 'POST',
      body: JSON.stringify(context),
    });
  }

  async summarizeTodos(todos: Todo[]): Promise<AIResponse> {
    return this.request<AIResponse>('/ai/summarize', {
      method: 'POST',
      body: JSON.stringify({ todos }),
    });
  }

  async categorizeTodos(todos: Todo[]): Promise<AIResponse> {
    return this.request<AIResponse>('/ai/categorize', {
      method: 'POST',
      body: JSON.stringify({ todos }),
    });
  }

  async prioritizeTodos(todos: Todo[]): Promise<AIResponse> {
    return this.request<AIResponse>('/ai/prioritize', {
      method: 'POST',
      body: JSON.stringify({ todos }),
    });
  }

  // Sync operations
  async syncTodoToWalrus(todoId: string): Promise<{ blobId: string }> {
    return this.request<{ blobId: string }>(`/sync/todos/${todoId}/walrus`, {
      method: 'POST',
    });
  }

  async syncTodoToBlockchain(todoId: string): Promise<{ nftObjectId: string }> {
    return this.request<{ nftObjectId: string }>(
      `/sync/todos/${todoId}/blockchain`,
      {
        method: 'POST',
      }
    );
  }

  async syncListToWalrus(listName: string): Promise<{ blobId: string }> {
    return this.request<{ blobId: string }>(`/sync/lists/${listName}/walrus`, {
      method: 'POST',
    });
  }

  async retrieveFromWalrus(blobId: string): Promise<Todo> {
    return this.request<Todo>(`/sync/walrus/${blobId}`);
  }

  async getSyncStatus(todoId: string): Promise<SyncStatus> {
    return this.request<SyncStatus>(`/sync/status/${todoId}`);
  }

  async batchSync(todoIds: string[]): Promise<Record<string, string>> {
    return this.request<Record<string, string>>('/sync/batch', {
      method: 'POST',
      body: JSON.stringify({ todoIds }),
    });
  }

  // Health check
  async healthCheck(): Promise<{ status: string; version: string }> {
    return this.request<{ status: string; version: string }>('/health');
  }
}

// Export singleton instance
export const apiClient = new TodoAPIClient();
</file>

<file path="src/lib/blockchain-events.ts">
/**
 * Mock blockchain events manager to prevent console errors
 * In a real implementation, this would connect to Sui blockchain events
 */

export interface EventConnectionState {
  connected: boolean;
  connecting: boolean;
  error: Error | null;
  lastReconnectAttempt: number;
  reconnectAttempts: number;
  subscriptionCount?: number;
}

export interface TodoNFTEvent {
  type: 'created' | 'completed' | 'updated' | 'deleted';
  data: {
    todo_id: string;
    title?: string;
    owner: string;
    timestamp: string;
  };
}

export type EventListener = (event: TodoNFTEvent) => void;

export class BlockchainEventManager {
  private connected = false;
  private listeners: Map<string, EventListener[]> = new Map();

  async initialize(): Promise<void> {
    console.log('Initializing blockchain event manager (mock)');
    this.connected = true;
  }

  async subscribeToEvents(owner?: string): Promise<void> {
    console.log('Subscribing to blockchain events (mock)', owner);
  }

  unsubscribeAll(): void {
    console.log('Unsubscribing from all events (mock)');
    this.listeners.clear();
  }

  addEventListener(eventType: string, listener: EventListener): () => void {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }
    this.listeners.get(eventType)!.push(listener);

    return () => {
      const listeners = this.listeners.get(eventType);
      if (listeners) {
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      }
    };
  }

  removeEventListener(eventType: string, listener: EventListener): void {
    const listeners = this.listeners.get(eventType);
    if (listeners) {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }

  getConnectionState(): EventConnectionState {
    return {
      connected: this.connected,
      connecting: false,
      error: null,
      lastReconnectAttempt: 0,
      reconnectAttempts: 0,
      subscriptionCount: this.listeners.size,
    };
  }

  destroy(): void {
    this.connected = false;
    this.listeners.clear();
  }
}

// Global event manager instance
let eventManager: BlockchainEventManager | null = null;

export function getEventManager(options?: {
  autoReconnect?: boolean;
}): BlockchainEventManager {
  if (!eventManager) {
    console.log('Creating new blockchain event manager instance');
    eventManager = new BlockchainEventManager();
    // Initialize immediately to prevent "not initialized" errors
    eventManager.initialize().catch(console.error);
  }
  return eventManager;
}

export function transformEventToTodoUpdate(event: TodoNFTEvent): any {
  return {
    id: event.data.todo_id,
    title: event.data.title || 'Updated Todo',
    owner: event.data.owner,
    blockchainStored: true,
    objectId: event.data.todo_id,
    updatedAt: new Date(event.data.timestamp).getTime(),
  };
}
</file>

<file path="src/lib/clipboard.ts">
/**
 * Enhanced clipboard utility with comprehensive error handling and fallbacks
 * for various browser contexts and restrictions
 */

export interface ClipboardResult {
  success: boolean;
  error?: Error;
  method?:
    | 'clipboard-api'
    | 'document-execcommand'
    | 'clipboard-polyfill'
    | 'none';
}

// Custom error types for better error handling
export class ClipboardError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ClipboardError';
  }
}

export class ClipboardApiNotSupportedError extends ClipboardError {
  constructor() {
    super('Clipboard API not supported in this browser');
    this.name = 'ClipboardApiNotSupportedError';
  }
}

export class ClipboardPermissionDeniedError extends ClipboardError {
  constructor() {
    super('Permission to access clipboard was denied');
    this.name = 'ClipboardPermissionDeniedError';
  }
}

export class InsecureContextError extends ClipboardError {
  constructor() {
    super('Clipboard access requires a secure context (HTTPS or localhost)');
    this.name = 'InsecureContextError';
  }
}

export class ClipboardPolyfillError extends ClipboardError {
  constructor(message: string = 'Clipboard polyfill failed') {
    super(message);
    this.name = 'ClipboardPolyfillError';
  }
}

/**
 * Check browser capabilities for clipboard operations
 */
export function getClipboardCapabilities(): {
  hasModernApi: boolean;
  hasLegacySupport: boolean;
  isSecureContext: boolean;
  canPolyfill: boolean;
} {
  if (typeof window === 'undefined') {
    return {
      hasModernApi: false,
      hasLegacySupport: false,
      isSecureContext: false,
      canPolyfill: false,
    };
  }

  // Check for secure context (HTTPS or localhost)
  const isSecureContext = window.isSecureContext === true;

  // Check for modern clipboard API
  const hasModernApi =
    typeof navigator !== 'undefined' &&
    navigator.clipboard !== undefined &&
    typeof navigator.clipboard.writeText === 'function';

  // Check for legacy support via execCommand
  const hasLegacySupport =
    typeof document !== 'undefined' &&
    document.queryCommandSupported &&
    document.queryCommandSupported('copy');

  // Check if we can use any method (including polyfill)
  const canPolyfill = hasLegacySupport || hasModernApi;

  return {
    hasModernApi,
    hasLegacySupport,
    isSecureContext,
    canPolyfill,
  };
}

/**
 * Legacy method using execCommand (works in more browsers but requires user interaction)
 */
function copyWithExecCommand(text: string): boolean {
  try {
    // Create temporary element
    const textArea = document.createElement('textarea');
    textArea.value = text;

    // Hide the element but make it available for selection
    textArea.style.position = 'fixed';
    textArea.style.opacity = '0';
    textArea.style.left = '-999999px';
    textArea.style.top = '0';
    textArea.setAttribute('readonly', '');
    textArea.setAttribute('aria-hidden', 'true');

    // Add to DOM
    document.body.appendChild(textArea);

    // Select text
    textArea.focus();
    textArea.select();

    // For mobile devices
    textArea.setSelectionRange(0, text.length);

    // Execute copy command
    const successful = document.execCommand('copy');

    // Clean up
    document.body.removeChild(textArea);

    return successful;
  } catch (e) {
    console.warn('Legacy clipboard copy failed:', e);
    return false;
  }
}

/**
 * Try to enhance the clipboard error with more specific information
 */
function enhanceClipboardError(error: unknown): Error {
  if (error instanceof DOMException) {
    // Handle specific DOMException types
    if (error.name === 'NotAllowedError') {
      return new ClipboardPermissionDeniedError();
    }
    if (error.name === 'SecurityError') {
      return new InsecureContextError();
    }
  }

  // Return original error if it's already an Error instance
  if (error instanceof Error) {
    return error;
  }

  // Create generic error for other cases
  return new ClipboardError(String(error) || 'Unknown clipboard error');
}

/**
 * Main copy to clipboard function with multiple fallback strategies
 */
export async function copyToClipboard(text: string): Promise<ClipboardResult> {
  // Check for server-side rendering
  if (typeof window === 'undefined') {
    return {
      success: false,
      error: new ClipboardError(
        'Clipboard operations require a browser environment'
      ),
      method: 'none',
    };
  }

  const capabilities = getClipboardCapabilities();

  // Try modern clipboard API first (if available)
  if (capabilities.hasModernApi && capabilities.isSecureContext) {
    try {
      await navigator.clipboard.writeText(text);
      return {
        success: true,
        method: 'clipboard-api',
      };
    } catch (error) {
      console.warn('Modern clipboard API failed, falling back:', error);
      // Continue to fallbacks instead of returning immediately
    }
  }

  // Try legacy method
  if (capabilities.hasLegacySupport) {
    const legacyResult = copyWithExecCommand(text);
    if (legacyResult) {
      return {
        success: true,
        method: 'document-execcommand',
      };
    }
  }

  // If we got here, both modern and legacy methods failed
  // Create appropriate error based on context
  let error: Error;

  if (!capabilities.isSecureContext) {
    error = new InsecureContextError();
  } else if (!capabilities.hasModernApi && !capabilities.hasLegacySupport) {
    error = new ClipboardApiNotSupportedError();
  } else {
    error = new ClipboardError('All clipboard methods failed');
  }

  return {
    success: false,
    error,
    method: 'none',
  };
}

/**
 * Check if clipboard operations are supported
 */
export function isCopySupported(): boolean {
  const capabilities = getClipboardCapabilities();
  return capabilities.hasModernApi || capabilities.hasLegacySupport;
}

/**
 * Get user-friendly message based on clipboard capabilities
 */
export function getClipboardSupportMessage(): string {
  const capabilities = getClipboardCapabilities();

  if (!capabilities.hasModernApi && !capabilities.hasLegacySupport) {
    return 'Copy to clipboard is not supported in this browser';
  }

  if (!capabilities.isSecureContext) {
    return 'Copy requires a secure context (HTTPS). Some features may be limited.';
  }

  if (capabilities.hasModernApi) {
    return 'Clipboard API is fully supported';
  }

  if (capabilities.hasLegacySupport) {
    return 'Using legacy clipboard support';
  }

  return 'Limited clipboard support';
}
</file>

<file path="src/lib/config-loader.ts">
/**
 * Frontend Configuration Loader
 *
 * Loads configuration dynamically based on the current network environment.
 * This system allows the frontend to automatically use the correct contract addresses
 * and network settings that were generated during CLI deployment.
 */

import React from 'react';

/**
 * Network configuration interface
 */
export interface NetworkConfig {
  name: string;
  url: string;
  faucetUrl?: string;
  explorerUrl: string;
}

/**
 * Walrus configuration interface
 */
export interface WalrusConfig {
  networkUrl: string;
  publisherUrl: string;
  aggregatorUrl: string;
  apiPrefix: string;
}

/**
 * Deployment configuration interface
 */
export interface DeploymentConfig {
  packageId: string;
  digest: string;
  timestamp: string;
  deployerAddress: string;
}

/**
 * Complete configuration interface
 */
export interface AppConfig {
  network: NetworkConfig;
  walrus: WalrusConfig;
  deployment: DeploymentConfig;
  contracts: {
    todoNft: {
      packageId: string;
      moduleName: string;
      structName: string;
    };
  };
  features: {
    aiEnabled: boolean;
    blockchainVerification: boolean;
    encryptedStorage: boolean;
  };
}

/**
 * Configuration cache to avoid repeated loading
 */
let cachedConfig: AppConfig | null = null;
let currentNetwork: string | null = null;

/**
 * Fallback configurations for when auto-generated configs are not available
 */
const FALLBACK_CONFIGS: Record<string, Partial<AppConfig>> = {
  testnet: {
    network: {
      name: 'testnet',
      url: 'https://fullnode.testnet.sui.io:443',
      faucetUrl: 'https://faucet.testnet.sui.io',
      explorerUrl: 'https://testnet.suiexplorer.com',
    },
    walrus: {
      networkUrl: 'https://wal.testnet.sui.io',
      publisherUrl: 'https://publisher-testnet.walrus.space',
      aggregatorUrl: 'https://aggregator-testnet.walrus.space',
      apiPrefix: 'https://api-testnet.walrus.tech/1.0',
    },
    deployment: {
      packageId: '0x0', // Placeholder - should be replaced by deployment
      digest: 'unknown',
      timestamp: new Date().toISOString(),
      deployerAddress: '0x0',
    },
    contracts: {
      todoNft: {
        packageId: '0x0',
        moduleName: 'todo_nft',
        structName: 'TodoNFT',
      },
    },
    features: {
      aiEnabled: true,
      blockchainVerification: false,
      encryptedStorage: false,
    },
  },
  devnet: {
    network: {
      name: 'devnet',
      url: 'https://fullnode.devnet.sui.io:443',
      faucetUrl: 'https://faucet.devnet.sui.io',
      explorerUrl: 'https://devnet.suiexplorer.com',
    },
    walrus: {
      networkUrl: 'https://wal.devnet.sui.io',
      publisherUrl: 'https://publisher-devnet.walrus.space',
      aggregatorUrl: 'https://aggregator-devnet.walrus.space',
      apiPrefix: 'https://api-devnet.walrus.tech/1.0',
    },
    deployment: {
      packageId: '0x0',
      digest: 'unknown',
      timestamp: new Date().toISOString(),
      deployerAddress: '0x0',
    },
    contracts: {
      todoNft: {
        packageId: '0x0',
        moduleName: 'todo_nft',
        structName: 'TodoNFT',
      },
    },
    features: {
      aiEnabled: true,
      blockchainVerification: false,
      encryptedStorage: false,
    },
  },
  localnet: {
    network: {
      name: 'localnet',
      url: 'http://localhost:9000',
      explorerUrl: 'http://localhost:9001',
    },
    walrus: {
      networkUrl: 'http://localhost:31415',
      publisherUrl: 'http://localhost:31416',
      aggregatorUrl: 'http://localhost:31417',
      apiPrefix: 'http://localhost:31418/1.0',
    },
    deployment: {
      packageId: '0x0',
      digest: 'unknown',
      timestamp: new Date().toISOString(),
      deployerAddress: '0x0',
    },
    contracts: {
      todoNft: {
        packageId: '0x0',
        moduleName: 'todo_nft',
        structName: 'TodoNFT',
      },
    },
    features: {
      aiEnabled: true,
      blockchainVerification: false,
      encryptedStorage: false,
    },
  },
};

/**
 * Gets the current network from environment variables
 */
function getCurrentNetwork(): string {
  if (typeof window !== 'undefined') {
    // Client-side: use environment variable or default
    return process.env.NEXT_PUBLIC_NETWORK || 'testnet';
  } else {
    // Server-side: use environment variable or default
    return process.env.NEXT_PUBLIC_NETWORK || 'testnet';
  }
}

/**
 * Load network configuration dynamically at runtime
 * This replaces build-time imports with runtime loading
 */
export async function loadNetworkConfig(network: string): Promise<AppConfig | null> {
  try {
    // Try to load the JSON configuration file from public directory
    const configResponse = await fetch(`/config/${network}.json`);
    if (configResponse.ok) {
      const config = await configResponse.json();
      console.log(`Loaded runtime configuration for ${network}`);
      return transformConfigFormat(config);
    }
  } catch (error) {
    console.warn(`Failed to load runtime config for ${network}:`, error);
  }

  return null;
}

/**
 * Transform config from CLI format to frontend format
 */
function transformConfigFormat(config: any): AppConfig {
  return {
    network: {
      name: config.network || 'testnet',
      url: config.rpcUrl || config.environment?.apiEndpoint || 'https://fullnode.testnet.sui.io:443',
      faucetUrl: config.faucetUrl,
      explorerUrl: config.explorerUrl || 'https://testnet.suiexplorer.com',
    },
    walrus: {
      networkUrl: config.walrus?.networkUrl || 'https://wal.testnet.sui.io',
      publisherUrl: config.walrus?.publisherUrl || 'https://publisher-testnet.walrus.space',
      aggregatorUrl: config.walrus?.aggregatorUrl || 'https://aggregator-testnet.walrus.space',
      apiPrefix: config.walrus?.apiPrefix || 'https://api-testnet.walrus.tech/1.0',
    },
    deployment: {
      packageId: config.deployment?.packageId || '0x0',
      digest: config.deployment?.transactionHash || 'unknown',
      timestamp: config.deployment?.timestamp || new Date().toISOString(),
      deployerAddress: config.deployment?.deployerAddress || '0x0',
    },
    contracts: {
      todoNft: {
        packageId: config.deployment?.packageId || '0x0',
        moduleName: 'todo_nft',
        structName: 'TodoNFT',
      },
    },
    features: {
      aiEnabled: config.features?.aiIntegration || false,
      blockchainVerification: config.features?.blockchainVerification || false,
      encryptedStorage: config.features?.encryptedStorage || false,
    },
  };
}

/**
 * Loads configuration from auto-generated files
 */
async function loadGeneratedConfig(network: string): Promise<AppConfig | null> {
  return loadNetworkConfig(network);
}

/**
 * Creates a complete configuration from fallback data
 */
function createFallbackConfig(network: string): AppConfig {
  const fallback = FALLBACK_CONFIGS[network];
  if (!fallback) {
    throw new Error(`No configuration available for network: ${network}`);
  }

  console.warn(
    `Using fallback configuration for ${network} - run 'waltodo deploy' to generate proper config`
  );

  return fallback as AppConfig;
}

/**
 * Loads the application configuration for the current network
 */
export async function loadAppConfig(): Promise<AppConfig> {
  const network = getCurrentNetwork();

  // Return cached config if network hasn't changed
  if (cachedConfig && currentNetwork === network) {
    return cachedConfig;
  }

  console.log(`Loading configuration for ${network} network`);

  // Try to load generated configuration first
  let config = await loadGeneratedConfig(network);

  // Fall back to default configuration if needed
  if (!config) {
    config = createFallbackConfig(network);
  }

  // Validate configuration
  if (!config.deployment.packageId || config.deployment.packageId === '0x0') {
    console.warn('Package ID not set - some blockchain features may not work');
  }

  // Cache the configuration
  cachedConfig = config;
  currentNetwork = network;

  return config;
}

/**
 * Gets the current network configuration synchronously (for client components)
 */
export function getNetworkName(): string {
  return getCurrentNetwork();
}

/**
 * Hook for React components to load configuration
 */
export function useAppConfig() {
  const [config, setConfig] = React.useState<AppConfig | null>(null);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);

  React.useEffect(() => {
    loadAppConfig()
      .then(setConfig)
      .catch(err => {
        setError(err.message);
        console.error('Failed to load app configuration:', err);
      })
      .finally(() => setLoading(false));
  }, []);

  return { config, loading, error };
}

/**
 * Clears the configuration cache (useful for testing or network switching)
 */
export function clearConfigCache(): void {
  cachedConfig = null;
  currentNetwork = null;
}

/**
 * Validates that the configuration has required deployment information
 */
export function isConfigurationComplete(config: AppConfig): boolean {
  return !!(
    config.deployment.packageId &&
    config.deployment.packageId !== '0x0' &&
    config.deployment.deployerAddress &&
    config.deployment.deployerAddress !== '0x0'
  );
}

/**
 * Gets the explorer URL for a specific object
 */
export function getExplorerUrl(config: AppConfig, objectId: string): string {
  return `${config.network.explorerUrl}/object/${objectId}?network=${config.network.name}`;
}

/**
 * Gets the faucet URL for the current network (if available)
 */
export function getFaucetUrl(config: AppConfig): string | null {
  return config.network.faucetUrl || null;
}
</file>

<file path="src/lib/global-error-suppression.ts">
/**
 * Global error suppression for known third-party library issues
 * This prevents console spam from expected errors in wallet libraries
 */

export function setupGlobalErrorSuppression() {
  if (typeof window === 'undefined') {
    return;
  }

  // Store original console methods
  const originalError = console.error;
  const originalWarn = console.warn;
  const originalLog = console.log;

  // List of error patterns to suppress (reduce noise)
  const suppressedErrorPatterns = [
    'Access to storage is not allowed from this context',
    'localStorage',
    'sessionStorage',
    'select failed: wallet',
    'UNKNOWN_ERROR',
    'KIT.UNKNOWN_ERROR',
    'wallet Slush is not available',
    'all wallets are listed here: []',
    'Wallet Standard has already been loaded',
    'Could not determine how to get wallets from wallet kit',
    'Not saving wallet info - wallet not in available list',
    'Auto-reconnect disabled',
    'Failed to load resource: the server responded with a status of 404',
    'Error storing todo on blockchain',
    'Failed to create todo: Error: Wallet not connected',
    'overrideMethod',
    'installHook.js',
    'hook.js',
    'Would execute transaction with dApp Kit',
    'Todo created successfully',
    'dApp.connect',
    'query #1',
    'query #2',
    'query #3',
    'dapp-interface.js',
    'opcgpfmipidbgpenhmajoajpbobppdil',
    'chrome-extension://',
    '[[ << query #',
    'Error: [[ << query #',
  ];

  // Enhanced console.error that filters known issues
  console.error = (...args: any[]) => {
    const errorString = args.join(' ');

    // Check if this is a known, expected error
    const isKnownError = suppressedErrorPatterns.some(pattern =>
      errorString.includes(pattern)
    );

    if (isKnownError) {
      // Completely suppress known errors to clean up console
      return;
    }

    // For genuine errors, use original console.error
    originalError(...args);
  };

  // Enhanced console.warn that filters known issues
  console.warn = (...args: any[]) => {
    const warnString = args.join(' ');

    // Check if this is a known, expected warning
    const isKnownWarning = suppressedErrorPatterns.some(pattern =>
      warnString.includes(pattern)
    );

    if (isKnownWarning) {
      // Completely suppress known warnings to clean up console
      return;
    }

    // For genuine warnings, use original console.warn
    originalWarn(...args);
  };

  // Enhanced console.log that filters repetitive debug messages
  console.log = (...args: any[]) => {
    const logString = args.join(' ');

    // Check if this is repetitive debug logging
    const isRepetitiveLog = suppressedErrorPatterns.some(pattern =>
      logString.includes(pattern)
    );

    if (isRepetitiveLog) {
      // Completely suppress repetitive logs to clean up console
      return;
    }

    // For genuine logs, use original console.log
    originalLog(...args);
  };

  // Global error handler for uncaught errors
  const globalErrorHandler = (event: ErrorEvent) => {
    const errorMessage = event.error?.message || event.message || '';

    // Check if this is a known error pattern
    const isKnownError = suppressedErrorPatterns.some(pattern =>
      errorMessage.includes(pattern)
    );

    if (isKnownError) {
      console.warn('[Global Error Suppressed]', errorMessage);
      event.preventDefault();
      return;
    }

    // Let genuine errors through
    console.error('[Global Error]', event.error || event.message);
  };

  // Global unhandled promise rejection handler
  const globalRejectionHandler = (event: PromiseRejectionEvent) => {
    const rejectionMessage = String(event.reason);

    // Check if this is a known error pattern
    const isKnownError = suppressedErrorPatterns.some(pattern =>
      rejectionMessage.includes(pattern)
    );

    if (isKnownError) {
      console.warn('[Global Rejection Suppressed]', rejectionMessage);
      event.preventDefault();
      return;
    }

    // Let genuine rejections through
    console.error('[Global Rejection]', event.reason);
  };

  // Add global event listeners
  window.addEventListener('error', globalErrorHandler);
  window.addEventListener('unhandledrejection', globalRejectionHandler);

  // Return cleanup function
  return () => {
    // Restore original console methods
    console.error = originalError;
    console.warn = originalWarn;
    console.log = originalLog;

    // Remove event listeners
    window.removeEventListener('error', globalErrorHandler);
    window.removeEventListener('unhandledrejection', globalRejectionHandler);
  };
}

// Don't auto-setup - let the client component handle it
// This prevents issues during SSR/build
</file>

<file path="src/lib/safe-storage.ts">
'use client';

/**
 * Safe Storage - Provides an enhanced localStorage wrapper with:
 * - Error handling for browser restrictions and SSR
 * - In-memory fallback when localStorage isn't available
 * - TypeScript type safety
 */

// In-memory fallback storage
const memoryStore: Record<string, string> = {};

// Check if we're in a browser environment
export const isBrowser = () => typeof window !== 'undefined';

// Global flag to track if we're during initial hydration
let isHydrating = true;

// Set isHydrating to false after proper DOM loading
if (typeof window !== 'undefined') {
  // Use multiple events to ensure hydration is complete
  const markHydrationComplete = () => {
    isHydrating = false;
  };

  // Immediately set to false if the document is already loaded
  if (document.readyState === 'complete') {
    markHydrationComplete();
  } else {
    // Wait for both DOMContentLoaded and window load
    document.addEventListener('DOMContentLoaded', markHydrationComplete);
    window.addEventListener('load', markHydrationComplete);

    // Fallback timeout in case events don't fire
    setTimeout(markHydrationComplete, 1000);
  }
}

// Check if localStorage is available
export function isStorageAvailable(): boolean {
  // Always return false during SSR or hydration
  if (!isBrowser() || isHydrating) return false;

  // Delay access to localStorage until after hydration
  if (typeof document !== 'undefined' && document.readyState !== 'complete') {
    return false;
  }

  try {
    // First check if localStorage is defined
    if (window.localStorage === undefined) {
      return false;
    }

    // Use a safer detection method that doesn't cause errors
    try {
      // Check if we're in a private browsing context
      // This is a safe way to test without triggering errors
      if ('localStorage' in window && window.localStorage !== null) {
        // Don't actually access localStorage during this check
        return true;
      }
      return false;
    } catch (privateBrowsingError) {
      return false;
    }
  } catch (e) {
    return false;
  }
}

/**
 * Safely attempts to access localStorage after hydration
 * Returns a tuple of [success, value]
 */
function safeLocalStorageAccess<T>(
  operation: 'get' | 'set' | 'remove',
  key: string,
  value?: T
): [boolean, string | null] {
  // Don't access localStorage during SSR or hydration
  if (!isBrowser() || isHydrating) {
    return [false, null];
  }

  // Don't access localStorage if document isn't fully loaded
  if (typeof document !== 'undefined' && document.readyState !== 'complete') {
    return [false, null];
  }

  // Additional safety check for iframe/restricted contexts
  try {
    // Quick test to see if localStorage is actually accessible
    // This will throw if we're in a restricted context
    if (!window.localStorage) {
      return [false, null];
    }

    // Test write access (this will fail in private browsing)
    // Skip this test to avoid console errors
    // const testKey = '__test_storage_access__';
    // window.localStorage.setItem(testKey, 'test');
    // window.localStorage.removeItem(testKey);
  } catch (accessError) {
    // Silently return false instead of logging error
    return [false, null];
  }

  try {
    // First verify that localStorage is available
    if (
      typeof window === 'undefined' ||
      typeof window.localStorage === 'undefined'
    ) {
      return [false, null];
    }

    // Perform the requested operation
    switch (operation) {
      case 'get':
        return [true, window.localStorage.getItem(key)];
      case 'set':
        window.localStorage.setItem(key, JSON.stringify(value));
        return [true, null];
      case 'remove':
        window.localStorage.removeItem(key);
        return [true, null];
      default:
        return [false, null];
    }
  } catch (error) {
    // Silently handle errors to avoid console spam
    return [false, null];
  }
}

/**
 * Get item safely from storage with fallback to memory store
 */
export function getItem<T>(key: string, defaultValue?: T): T | null {
  try {
    // Try to get from localStorage safely
    const [success, value] = safeLocalStorageAccess<T>('get', key);

    if (success && value !== null) {
      try {
        return JSON.parse(value);
      } catch (parseError) {
        console.warn(
          `Error parsing localStorage value for key "${key}":`,
          parseError
        );
      }
    }

    // Fallback to memory store if localStorage access failed or returned null
    const memoryValue = memoryStore[key];
    return memoryValue ? JSON.parse(memoryValue) : (defaultValue ?? null);
  } catch (error) {
    // This could be a parsing error or other issue
    console.warn(`Error getting item "${key}" from storage:`, error);

    // Return default value as ultimate fallback
    return defaultValue ?? null;
  }
}

/**
 * Set item safely in storage with fallback to memory store
 */
export function setItem<T>(key: string, value: T): boolean {
  try {
    // Store as JSON string
    const valueString = JSON.stringify(value);

    // Always update memory store regardless of localStorage availability
    memoryStore[key] = valueString;

    // Try to set in localStorage safely
    const [success] = safeLocalStorageAccess<T>('set', key, value);

    // Return true even if localStorage failed but memory store succeeded
    return true;
  } catch (error) {
    console.warn(`Error setting item "${key}" in storage:`, error);

    // Try to update memory store as a fallback
    try {
      memoryStore[key] = JSON.stringify(value);
      return true; // Success with memory fallback
    } catch (e) {
      console.error(`Failed to save in memory store:`, e);
      return false; // Complete failure
    }
  }
}

/**
 * Remove item safely from all storage
 */
export function removeItem(key: string): boolean {
  try {
    // Always remove from memory store
    delete memoryStore[key];

    // Try to remove from localStorage safely
    safeLocalStorageAccess('remove', key);

    return true;
  } catch (error) {
    console.warn(`Error removing item "${key}" from storage:`, error);

    // Ensure it's removed from memory store even if localStorage fails
    delete memoryStore[key];
    return true;
  }
}

/**
 * Clear all storage safely
 */
export function clearStorage(): boolean {
  try {
    // Clear memory store
    Object.keys(memoryStore).forEach(key => delete memoryStore[key]);

    // Try to clear localStorage safely
    if (
      isBrowser() &&
      !isHydrating &&
      typeof window !== 'undefined' &&
      typeof window.localStorage !== 'undefined' &&
      document.readyState === 'complete'
    ) {
      try {
        window.localStorage.clear();
      } catch (clearError) {
        console.warn('Error clearing localStorage:', clearError);
      }
    }

    return true;
  } catch (error) {
    console.warn(`Error clearing storage:`, error);

    // Ensure memory store is cleared even if localStorage fails
    Object.keys(memoryStore).forEach(key => delete memoryStore[key]);
    return true;
  }
}

/**
 * Get all storage keys
 */
export function getAllKeys(): string[] {
  try {
    // Always include memory store keys
    const memoryStoreKeys = Object.keys(memoryStore);

    // Only attempt to get localStorage keys if it's safe to do so
    if (
      isBrowser() &&
      !isHydrating &&
      typeof window !== 'undefined' &&
      typeof window.localStorage !== 'undefined' &&
      document.readyState === 'complete'
    ) {
      try {
        const localStorageKeys = Object.keys(window.localStorage);
        // Combine and remove duplicates
        const allKeys = localStorageKeys.concat(memoryStoreKeys);
        const uniqueKeys = allKeys.filter(
          (key, index) => allKeys.indexOf(key) === index
        );
        return uniqueKeys;
      } catch (storageError) {
        console.warn('Error accessing localStorage keys:', storageError);
        return memoryStoreKeys;
      }
    }

    // Default to memory store keys only
    return memoryStoreKeys;
  } catch (error) {
    console.warn(`Error getting storage keys:`, error);
    return Object.keys(memoryStore);
  }
}

/**
 * Check if we're using fallback storage
 */
export function isUsingFallbackStorage(): boolean {
  return !isStorageAvailable();
}

/**
 * Create a typed storage helper for specific data
 */
export function createTypedStorage<T>(key: string, defaultValue: T) {
  return {
    get: () => getItem<T>(key, defaultValue),
    set: (value: T) => setItem<T>(key, value),
    clear: () => removeItem(key),
  };
}

// Use helper functions directly
const safeStorage = {
  getItem,
  setItem,
  removeItem,
  clear: clearStorage,
  keys: getAllKeys,
  isAvailable: isStorageAvailable,
  isFallback: isUsingFallbackStorage,
  createTyped: createTypedStorage,
};

export default safeStorage;
</file>

<file path="src/lib/storage-utils.ts">
'use client';

/**
 * Enhanced storage utilities with context detection and fallbacks
 * Prevents errors in restricted contexts (extensions, iframes, etc.)
 */

// In-memory fallback when localStorage isn't available
const memoryStorage: Record<string, string> = {};

// Context types
export type StorageContext =
  | 'browser' // Standard browser context with storage access
  | 'extension' // Browser extension context
  | 'iframe' // Embedded in an iframe
  | 'insecure' // Non-HTTPS context with restricted features
  | 'incognito' // Private/incognito browsing mode
  | 'server' // Server-side rendering context
  | 'unknown'; // Context could not be determined

// Check if we're in a browser environment without throwing errors
function isBrowser(): boolean {
  return typeof window !== 'undefined';
}

// Detect current execution context
export function detectContext(): StorageContext {
  // Check for server-side rendering
  if (!isBrowser()) {
    return 'server';
  }

  // Safe check for extension context
  try {
    if (
      typeof (window as any).chrome !== 'undefined' &&
      (window as any).chrome.storage
    ) {
      return 'extension';
    }
  } catch (e) {
    console.warn('Error checking for extension context:', e);
  }

  // Safe check for iframe
  try {
    if (window.top !== window.self) {
      return 'iframe';
    }
  } catch (e) {
    // If this errors, we're probably in a cross-origin iframe
    console.warn('Error checking for iframe context:', e);
    return 'iframe'; // Assume iframe with restrictions
  }

  // Check for insecure context (non-HTTPS except localhost)
  try {
    if (!window.isSecureContext) {
      return 'insecure';
    }
  } catch (e) {
    console.warn('Error checking for secure context:', e);
  }

  // Check for incognito/private mode or storage restrictions
  try {
    localStorage.setItem('__storage_test__', '__storage_test__');
    localStorage.removeItem('__storage_test__');
    sessionStorage.setItem('__storage_test__', '__storage_test__');
    sessionStorage.removeItem('__storage_test__');
    return 'browser';
  } catch (e) {
    // If storage test fails but browser isn't otherwise identified as a specific context
    return 'incognito';
  }
}

// Check if localStorage is available
export function isStorageAvailable(): boolean {
  if (!isBrowser()) return false;

  try {
    // First check if we're in a context that blocks storage APIs
    // Common in SSR, cross-origin iframes, or when "Block all cookies" is enabled
    if (
      window.localStorage === undefined ||
      window.sessionStorage === undefined
    ) {
      return false;
    }

    const testKey = '__storage_test__';
    window.localStorage.setItem(testKey, testKey);
    window.localStorage.removeItem(testKey);
    return true;
  } catch (e) {
    return false;
  }
}

// Get the appropriate storage method based on context
function getStorage(): Storage | Record<string, string> {
  // Always use memory storage in server context
  if (!isBrowser()) {
    return memoryStorage;
  }

  // Try to detect the context, but use memory storage as fallback if detection fails
  try {
    const context = detectContext();

    switch (context) {
      case 'browser':
        // Double-check storage is available
        if (isStorageAvailable()) {
          return localStorage;
        }
        return memoryStorage;
      case 'extension':
      case 'iframe':
      case 'incognito':
      case 'insecure':
      case 'server':
      case 'unknown':
      default:
        return memoryStorage;
    }
  } catch (e) {
    console.warn('Error getting storage, using memory fallback:', e);
    return memoryStorage;
  }
}

/**
 * Safe getItem - retrieves an item from the appropriate storage
 * without throwing errors in any context
 */
export function safeGetItem(key: string): string | null {
  // Always use memory storage in server context
  if (!isBrowser()) {
    return memoryStorage[key] || null;
  }

  try {
    const storage = getStorage();

    if (storage === memoryStorage) {
      return memoryStorage[key] || null;
    }

    return (storage as Storage).getItem(key);
  } catch (e) {
    console.warn(`Safe storage getItem failed for key "${key}":`, e);
    return memoryStorage[key] || null;
  }
}

/**
 * Safe setItem - stores an item in the appropriate storage
 * without throwing errors in any context
 */
export function safeSetItem(key: string, value: string): boolean {
  // Always use memory storage in server context
  if (!isBrowser()) {
    memoryStorage[key] = value;
    return true;
  }

  try {
    const storage = getStorage();

    if (storage === memoryStorage) {
      memoryStorage[key] = value;
      return true;
    }

    (storage as Storage).setItem(key, value);
    return true;
  } catch (e) {
    console.warn(`Safe storage setItem failed for key "${key}":`, e);
    // Fall back to memory storage
    memoryStorage[key] = value;
    return true;
  }
}

/**
 * Safe removeItem - removes an item from the appropriate storage
 * without throwing errors in any context
 */
export function safeRemoveItem(key: string): boolean {
  // Always use memory storage in server context
  if (!isBrowser()) {
    delete memoryStorage[key];
    return true;
  }

  try {
    const storage = getStorage();

    if (storage === memoryStorage) {
      delete memoryStorage[key];
      return true;
    }

    (storage as Storage).removeItem(key);
    return true;
  } catch (e) {
    console.warn(`Safe storage removeItem failed for key "${key}":`, e);
    // Still remove from memory storage
    delete memoryStorage[key];
    return true;
  }
}

/**
 * Safe clear - clears all items from the appropriate storage
 * without throwing errors in any context
 */
export function safeClear(): boolean {
  // Always use memory storage in server context
  if (!isBrowser()) {
    Object.keys(memoryStorage).forEach(key => {
      delete memoryStorage[key];
    });
    return true;
  }

  try {
    const storage = getStorage();

    if (storage === memoryStorage) {
      Object.keys(memoryStorage).forEach(key => {
        delete memoryStorage[key];
      });
      return true;
    }

    (storage as Storage).clear();
    return true;
  } catch (e) {
    console.warn('Safe storage clear failed:', e);
    // Still clear memory storage
    Object.keys(memoryStorage).forEach(key => {
      delete memoryStorage[key];
    });
    return true;
  }
}

// Additional utility for checking if we're using fallback storage
export function isUsingFallbackStorage(): boolean {
  if (!isBrowser()) return true;
  try {
    return getStorage() === memoryStorage;
  } catch (e) {
    return true;
  }
}

// Get all keys from current storage
export function getStorageKeys(): string[] {
  // Always use memory storage in server context
  if (!isBrowser()) {
    return Object.keys(memoryStorage);
  }

  try {
    const storage = getStorage();

    if (storage === memoryStorage) {
      return Object.keys(memoryStorage);
    }

    return Object.keys(storage);
  } catch (e) {
    console.warn('Failed to get storage keys:', e);
    return Object.keys(memoryStorage);
  }
}

// Get context-specific message for user feedback
export function getStorageContextMessage(): string {
  if (!isBrowser()) {
    return 'Server-side rendering detected. Using temporary storage.';
  }

  try {
    const context = detectContext();
    const usingFallback = isUsingFallbackStorage();

    if (usingFallback) {
      switch (context) {
        case 'extension':
          return 'Using extension storage mode. Your data will not persist between sessions.';
        case 'iframe':
          return 'Running in restricted iframe mode. Your data will not persist between sessions.';
        case 'incognito':
          return 'Private browsing detected. Your data will not persist between sessions.';
        case 'insecure':
          return 'Insecure context detected. For persistent storage, please use HTTPS.';
        case 'server':
          return 'Server-side rendering detected. Storage not available.';
        default:
          return 'Using temporary storage. Your data will not persist between sessions.';
      }
    }

    return 'Using persistent storage.';
  } catch (e) {
    return 'Using temporary storage due to browser restrictions.';
  }
}
</file>

<file path="src/lib/sui-client-utils.ts">
/**
 * Utility functions and examples for Sui client usage
 * Comprehensive error handling and usage patterns for TodoNFT operations
 */

import { SuiClient } from '@mysten/sui/client';
import { Transaction } from '@mysten/sui/transactions';

// Types for frontend usage
export interface Todo {
  id: string;
  title: string;
  description: string;
  completed: boolean;
  createdAt: number;
  updatedAt: number;
  imageUrl?: string;
  metadata?: string;
  isPrivate?: boolean;
}

export interface CreateTodoParams {
  title: string;
  description: string;
  imageUrl?: string;
  metadata?: string;
  isPrivate?: boolean;
}

export interface UpdateTodoParams {
  id: string;
  title?: string;
  description?: string;
  completed?: boolean;
  imageUrl?: string;
  metadata?: string;
}

export interface TransactionResult {
  success: boolean;
  digest?: string;
  objectId?: string;
  error?: string;
}

export type NetworkType = 'testnet' | 'devnet' | 'mainnet' | 'localnet';

export interface ErrorContext {
  operation: string;
  network?: NetworkType;
  timestamp?: number;
}

// Mock implementations for basic utility functions
export function initializeSuiClient(): SuiClient {
  return new SuiClient({ url: 'https://fullnode.testnet.sui.io:443' });
}

export function getCurrentNetwork(): NetworkType {
  return 'testnet';
}

export async function getTransactionStatus(digest: string) {
  // Mock implementation
  return { status: 'success' };
}

/**
 * Enhanced error handling with context
 */
export function handleSuiOperationError(
  error: unknown,
  context: ErrorContext
): never {
  const timestamp = Date.now();
  const errorContext = { ...context, timestamp };

  // Log error with context for debugging
  console.error('Sui operation failed:', {
    error,
    context: errorContext,
  });

  if (error instanceof Error) {
    throw new Error(`${context.operation} failed: ${error.message}`);
  }

  throw new Error(`${context.operation} failed: Unknown error occurred`);
}

/**
 * Retry mechanism for blockchain operations
 */
export async function retryOperation<T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  delayMs: number = 1000
): Promise<T> {
  let lastError: Error;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      if (attempt === maxRetries) {
        break;
      }

      // Wait before retrying
      await new Promise(resolve => setTimeout(resolve, delayMs * attempt));
    }
  }

  throw lastError!;
}

/**
 * Validate todo creation parameters
 */
export function validateCreateTodoParams(params: CreateTodoParams): string[] {
  const errors: string[] = [];

  if (!params.title || params.title.trim().length === 0) {
    errors.push('Title is required');
  }

  if (params.title && params.title.length > 100) {
    errors.push('Title must be 100 characters or less');
  }

  if (params.description && params.description.length > 500) {
    errors.push('Description must be 500 characters or less');
  }

  // Note: imageUrl is optional in this frontend version

  return errors;
}

/**
 * Enhanced todo creation with validation and error handling
 */
export async function createTodoSafely(
  params: CreateTodoParams,
  signAndExecuteTransaction: (txb: any) => Promise<any>,
  address: string
): Promise<TransactionResult> {
  const context: ErrorContext = {
    operation: 'create_todo',
    network: getCurrentNetwork(),
    timestamp: Date.now(),
  };

  try {
    // Validate parameters
    const validationErrors = validateCreateTodoParams(params);
    if (validationErrors.length > 0) {
      throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
    }

    // Create transaction block
    const txb = new Transaction();

    // Mock transaction construction
    console.log('Creating todo with params:', params);

    // Execute transaction
    const result = await signAndExecuteTransaction(txb);

    return {
      success: true,
      digest: result.digest,
      objectId: result.objectChanges?.[0]?.objectId,
    };
  } catch (error) {
    handleSuiOperationError(error, context);
  }
}

/**
 * Wait for transaction confirmation
 */
export async function waitForTransactionConfirmation(
  digest: string,
  maxWaitTime: number = 30000
): Promise<boolean> {
  const startTime = Date.now();

  while (Date.now() - startTime < maxWaitTime) {
    try {
      const status = await getTransactionStatus(digest);

      if (status.status === 'success') {
        return true;
      }

      if (status.status === 'failure') {
        throw new Error('Transaction failed');
      }

      // Wait 1 second before checking again
      await new Promise(resolve => setTimeout(resolve, 1000));
    } catch (error) {
      if (
        error instanceof Error &&
        error.message.includes('Transaction failed')
      ) {
        throw error;
      }

      // Continue waiting for other errors (might be temporary network issues)
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  throw new Error(`Transaction confirmation timeout after ${maxWaitTime}ms`);
}

/**
 * Network health check
 */
export async function checkNetworkHealth(): Promise<{
  healthy: boolean;
  latency?: number;
  error?: string;
}> {
  const startTime = Date.now();

  try {
    const client = initializeSuiClient();

    // Try to get chain identifier as a health check
    await client.getChainIdentifier();

    const latency = Date.now() - startTime;

    return {
      healthy: true,
      latency,
    };
  } catch (error) {
    return {
      healthy: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

// Re-export types are already exported above as interfaces
</file>

<file path="src/lib/sui-client.ts">
/**
 * Sui blockchain client for TodoNFT operations
 * Enhanced implementation with full Sui SDK integration and auto-generated configuration
 */

import { SuiClient } from '@mysten/sui/client';
import { Transaction } from '@mysten/sui/transactions';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { fromB64 } from '@mysten/sui/utils';
import { bcs } from '@mysten/sui/bcs';
import { loadAppConfig, type AppConfig } from './config-loader';

// Network configuration - removed in favor of config-loader
// Use loadAppConfig() to get network URLs dynamically

// TodoNFT contract configuration - fallback values if config not loaded
const TODO_NFT_CONFIG = {
  PACKAGE_ID:
    '0xe8d420d723b6813d1e001d8cba0dfc8613cbc814dedb4adcd41909f2e11daa8b', // Fallback - will be overridden by config
  MODULE_NAME: 'todo_nft',
  STRUCT_NAME: 'TodoNFT',
} as const;

export type NetworkType = 'mainnet' | 'testnet' | 'devnet' | 'localnet';

export interface Todo {
  id: string;
  title: string;
  description?: string;
  completed: boolean;
  priority: 'low' | 'medium' | 'high';
  tags?: string[];
  dueDate?: string;
  blockchainStored: boolean;
  objectId?: string; // Sui object ID when stored on chain
  imageUrl?: string;
  createdAt?: number;
  completedAt?: number;
  owner?: string;
  metadata?: string;
  isPrivate?: boolean;
}

export interface TodoList {
  name: string;
  todos: Todo[];
}

export interface SuiTodoNFT {
  id: {
    id: string;
  };
  title: string;
  description: string;
  image_url: string;
  completed: boolean;
  created_at: string;
  completed_at?: string;
  owner: string;
  metadata: string;
  is_private: boolean;
}

export interface TransactionResult {
  success: boolean;
  digest?: string;
  objectId?: string;
  error?: string;
}

export interface CreateTodoParams {
  title: string;
  description: string;
  imageUrl: string;
  metadata?: string;
  isPrivate?: boolean;
}

export interface UpdateTodoParams {
  objectId: string;
  title?: string;
  description?: string;
  imageUrl?: string;
  metadata?: string;
}

// Error classes for better error handling
export class SuiClientError extends Error {
  constructor(
    message: string,
    public code?: string
  ) {
    super(message);
    this.name = 'SuiClientError';
  }
}

export class TransactionError extends SuiClientError {
  constructor(
    message: string,
    public digest?: string
  ) {
    super(message, 'TRANSACTION_ERROR');
    this.name = 'TransactionError';
  }
}

export class WalletNotConnectedError extends SuiClientError {
  constructor() {
    super('Wallet not connected', 'WALLET_NOT_CONNECTED');
    this.name = 'WalletNotConnectedError';
  }
}

// Global Sui client instance
let suiClient: SuiClient | null = null;
let currentNetwork: NetworkType = 'testnet';
let appConfig: AppConfig | null = null;

// Remove simulated wallet connection - use wallet context instead
// let connected = false;
// let address = '';

// Safe storage check helper to avoid errors
const isStorageAvailable = () => {
  if (typeof window === 'undefined') return false;

  try {
    const testKey = '__storage_test__';
    window.localStorage.setItem(testKey, testKey);
    window.localStorage.removeItem(testKey);
    return true;
  } catch (e) {
    return false;
  }
};

/**
 * Initialize Sui client with auto-generated configuration
 */
export async function initializeSuiClientWithConfig(): Promise<SuiClient> {
  appConfig = await loadAppConfig();
  currentNetwork = appConfig.network.name as NetworkType;
  suiClient = new SuiClient({ url: appConfig.network.url });
  return suiClient;
}

/**
 * Initialize Sui client with network configuration (legacy)
 */
export async function initializeSuiClient(
  network: NetworkType = 'testnet'
): Promise<SuiClient> {
  // Try to load configuration first
  try {
    return await initializeSuiClientWithConfig();
  } catch (error) {
    // Fallback to direct network URL from config
    console.warn(
      'Failed to load app config, using fallback network configuration'
    );
    currentNetwork = network;
    // Use the network URLs from the config-loader fallback
    const networkUrls = {
      mainnet: 'https://fullnode.mainnet.sui.io:443',
      testnet: 'https://fullnode.testnet.sui.io:443',
      devnet: 'https://fullnode.devnet.sui.io:443',
      localnet: 'http://127.0.0.1:9000',
    };
    suiClient = new SuiClient({ url: networkUrls[network] });
    return suiClient;
  }
}

/**
 * Get or create Sui client instance
 */
export function getSuiClient(): SuiClient {
  if (!suiClient) {
    throw new Error(
      'Sui client not initialized. Call initializeSuiClient() first.'
    );
  }
  return suiClient;
}

/**
 * Get current app configuration
 */
export function getAppConfig(): AppConfig | null {
  return appConfig;
}

/**
 * Get the current package ID from configuration
 */
export function getPackageId(): string {
  if (appConfig?.deployment.packageId) {
    return appConfig.deployment.packageId;
  }
  // Fallback to hardcoded config
  return TODO_NFT_CONFIG.PACKAGE_ID;
}

/**
 * Switch to a different network
 */
export function switchNetwork(network: NetworkType): Promise<SuiClient> {
  return initializeSuiClient(network);
}

/**
 * Get current network
 */
export function getCurrentNetwork(): NetworkType {
  return currentNetwork;
}

// Remove placeholder wallet connection - use actual wallet context

// Remove local wallet state check - use wallet context

// Remove local wallet address - use wallet context

// Remove local wallet disconnect - use wallet context

/**
 * Transform Sui object data to Todo interface
 */
function transformSuiObjectToTodo(suiObject: SuiObjectResponse): Todo | null {
  if (
    !suiObject.data?.content ||
    suiObject.data.content.dataType !== 'moveObject'
  ) {
    return null;
  }

  const moveObject = suiObject.data.content as SuiMoveObject;
  const fields = moveObject.fields as any;

  if (!fields) {
    return null;
  }

  try {
    return {
      id: suiObject.data.objectId,
      objectId: suiObject.data.objectId,
      title: fields.title || 'Untitled',
      description: fields.description || '',
      completed: fields.completed === true,
      priority: 'medium', // Default priority, can be enhanced with metadata parsing
      tags: [], // Can be parsed from metadata
      blockchainStored: true,
      imageUrl: fields.image_url,
      createdAt: fields.created_at ? parseInt(fields.created_at) : Date.now(),
      completedAt: fields.completed_at
        ? parseInt(fields.completed_at)
        : undefined,
      owner: fields.owner,
      metadata: fields.metadata || '',
      isPrivate: fields.is_private === true,
    };
  } catch (error) {
    console.error('Error transforming Sui object to Todo:', error);
    return null;
  }
}

/**
 * Get TodoNFTs owned by a specific address
 */
export async function getTodosFromBlockchain(
  ownerAddress: string
): Promise<Todo[]> {
  try {
    const client = getSuiClient();

    if (!ownerAddress) {
      throw new WalletNotConnectedError();
    }

    // Get all objects owned by the address
    const response: PaginatedObjectsResponse = await client.getOwnedObjects({
      owner: ownerAddress,
      filter: {
        StructType: `${TODO_NFT_CONFIG.PACKAGE_ID}::${TODO_NFT_CONFIG.MODULE_NAME}::${TODO_NFT_CONFIG.STRUCT_NAME}`,
      },
      options: {
        showContent: true,
        showOwner: true,
        showType: true,
      },
    });

    // Transform Sui objects to Todo format
    const todos: Todo[] = response.data
      .map(transformSuiObjectToTodo)
      .filter((todo): todo is Todo => todo !== null);

    return todos;
  } catch (error) {
    console.error('Error fetching todos from blockchain:', error);
    if (error instanceof SuiClientError) {
      throw error;
    }
    throw new SuiClientError(
      `Failed to fetch todos: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}

/**
 * Create a TodoNFT transaction
 */
export function createTodoNFTTransaction(
  params: CreateTodoParams,
  senderAddress: string
): Transaction {
  const tx = new Transaction();
  tx.setSender(senderAddress);

  // Call the create_todo function from the smart contract
  tx.moveCall({
    target: `${TODO_NFT_CONFIG.PACKAGE_ID}::${TODO_NFT_CONFIG.MODULE_NAME}::create_todo`,
    arguments: [
      tx.pure(bcs.string().serialize(params.title)),
      tx.pure(bcs.string().serialize(params.description)),
      tx.pure(bcs.string().serialize(params.imageUrl)),
      tx.pure(bcs.string().serialize(params.metadata || '')),
      tx.pure(bcs.bool().serialize(params.isPrivate || false)),
    ],
  });

  return tx;
}

/**
 * Store todo on blockchain using transaction
 */
export async function storeTodoOnBlockchain(
  params: CreateTodoParams,
  signAndExecuteTransaction: (txb: Transaction) => Promise<{ digest: string; effects?: unknown }>,
  walletAddress: string
): Promise<TransactionResult> {
  try {
    if (!walletAddress) {
      throw new WalletNotConnectedError();
    }

    // Create transaction block
    const tx = createTodoNFTTransaction(params, walletAddress);

    // Execute transaction through wallet
    const result = await signAndExecuteTransaction(tx);

    if (result.digest) {
      // Get the created object ID from transaction effects
      const client = getSuiClient();
      const txResponse = await client.getTransactionBlock({
        digest: result.digest,
        options: {
          showEffects: true,
          showObjectChanges: true,
        },
      });

      // Find the created TodoNFT object
      const createdObject = txResponse.objectChanges?.find(
        change =>
          change.type === 'created' &&
          change.objectType?.includes(TODO_NFT_CONFIG.STRUCT_NAME)
      );

      return {
        success: true,
        digest: result.digest,
        objectId: (createdObject as any)?.objectId,
      };
    }

    return { success: false, error: 'Transaction failed without digest' };
  } catch (error) {
    console.error('Error storing todo on blockchain:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Create an update TodoNFT transaction
 */
export function updateTodoNFTTransaction(
  params: UpdateTodoParams,
  senderAddress: string
): Transaction {
  const tx = new Transaction();
  tx.setSender(senderAddress);

  // Call the update_todo function from the smart contract
  tx.moveCall({
    target: `${TODO_NFT_CONFIG.PACKAGE_ID}::${TODO_NFT_CONFIG.MODULE_NAME}::update_todo`,
    arguments: [
      tx.object(params.objectId),
      tx.pure(bcs.string().serialize(params.title || '')),
      tx.pure(bcs.string().serialize(params.description || '')),
      tx.pure(bcs.string().serialize(params.imageUrl || '')),
      tx.pure(bcs.string().serialize(params.metadata || '')),
    ],
  });

  return tx;
}

/**
 * Complete TodoNFT transaction
 */
export function completeTodoNFTTransaction(
  objectId: string,
  senderAddress: string
): Transaction {
  const tx = new Transaction();
  tx.setSender(senderAddress);

  // Call the complete_todo function from the smart contract
  tx.moveCall({
    target: `${TODO_NFT_CONFIG.PACKAGE_ID}::${TODO_NFT_CONFIG.MODULE_NAME}::complete_todo`,
    arguments: [tx.object(objectId)],
  });

  return tx;
}

/**
 * Delete TodoNFT transaction
 */
export function deleteTodoNFTTransaction(
  objectId: string,
  senderAddress: string
): Transaction {
  const tx = new Transaction();
  tx.setSender(senderAddress);

  // Call the delete_todo function from the smart contract
  tx.moveCall({
    target: `${TODO_NFT_CONFIG.PACKAGE_ID}::${TODO_NFT_CONFIG.MODULE_NAME}::delete_todo`,
    arguments: [tx.object(objectId)],
  });

  return tx;
}

/**
 * Update todo on blockchain
 */
export async function updateTodoOnBlockchain(
  params: UpdateTodoParams,
  signAndExecuteTransaction: (txb: Transaction) => Promise<{ digest: string; effects?: unknown }>,
  walletAddress: string
): Promise<TransactionResult> {
  try {
    if (!walletAddress) {
      throw new WalletNotConnectedError();
    }

    // Create transaction block
    const tx = updateTodoNFTTransaction(params, walletAddress);

    // Execute transaction through wallet
    const result = await signAndExecuteTransaction(tx);

    return {
      success: !!result.digest,
      digest: result.digest,
      error: result.digest ? undefined : 'Transaction failed',
    };
  } catch (error) {
    console.error('Error updating todo on blockchain:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Complete todo on blockchain
 */
export async function completeTodoOnBlockchain(
  objectId: string,
  signAndExecuteTransaction: (txb: Transaction) => Promise<{ digest: string; effects?: unknown }>,
  walletAddress: string
): Promise<TransactionResult> {
  try {
    if (!walletAddress) {
      throw new WalletNotConnectedError();
    }

    // Create transaction block
    const tx = completeTodoNFTTransaction(objectId, walletAddress);

    // Execute transaction through wallet
    const result = await signAndExecuteTransaction(tx);

    return {
      success: !!result.digest,
      digest: result.digest,
      error: result.digest ? undefined : 'Transaction failed',
    };
  } catch (error) {
    console.error('Error completing todo on blockchain:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Delete todo on blockchain
 */
export async function deleteTodoOnBlockchain(
  objectId: string,
  signAndExecuteTransaction: (txb: Transaction) => Promise<{ digest: string; effects?: unknown }>,
  walletAddress: string
): Promise<TransactionResult> {
  try {
    if (!walletAddress) {
      throw new WalletNotConnectedError();
    }

    // Create transaction block
    const tx = deleteTodoNFTTransaction(objectId, walletAddress);

    // Execute transaction through wallet
    const result = await signAndExecuteTransaction(tx);

    return {
      success: !!result.digest,
      digest: result.digest,
      error: result.digest ? undefined : 'Transaction failed',
    };
  } catch (error) {
    console.error('Error deleting todo on blockchain:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Get a specific TodoNFT by object ID
 */
export async function getTodoByObjectId(
  objectId: string
): Promise<Todo | null> {
  try {
    const client = getSuiClient();
    const response = await client.getObject({
      id: objectId,
      options: {
        showContent: true,
        showOwner: true,
        showType: true,
      },
    });

    return transformSuiObjectToTodo(response);
  } catch (error) {
    console.error('Error fetching todo by object ID:', error);
    throw new SuiClientError(
      `Failed to fetch todo: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}

/**
 * Batch fetch multiple TodoNFTs by object IDs
 */
export async function getTodosByObjectIds(
  objectIds: string[]
): Promise<Todo[]> {
  try {
    const client = getSuiClient();
    const response = await client.multiGetObjects({
      ids: objectIds,
      options: {
        showContent: true,
        showOwner: true,
        showType: true,
      },
    });

    return response
      .map(transformSuiObjectToTodo)
      .filter((todo): todo is Todo => todo !== null);
  } catch (error) {
    console.error('Error batch fetching todos:', error);
    throw new SuiClientError(
      `Failed to batch fetch todos: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}

/**
 * Get transaction status and details
 */
export async function getTransactionStatus(digest: string) {
  try {
    const client = getSuiClient();
    const response = await client.getTransactionBlock({
      digest,
      options: {
        showEffects: true,
        showEvents: true,
        showObjectChanges: true,
      },
    });

    return {
      status: response.effects?.status?.status || 'unknown',
      digest: response.digest,
      timestamp: response.timestampMs,
      objectChanges: response.objectChanges,
      events: response.events,
    };
  } catch (error) {
    console.error('Error getting transaction status:', error);
    throw new SuiClientError(
      `Failed to get transaction status: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}
</file>

<file path="src/lib/todo-service.ts">
/**
 * Service for managing local todo data
 * In a production app, this would integrate with the backend CLI
 */

import { Todo, TodoList } from './sui-client';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { Transaction } from '@mysten/sui/transactions';
import { PublicKey } from '@solana/web3.js';
import safeStorage, { isUsingFallbackStorage } from './safe-storage';
import { loadNetworkConfig, type AppConfig } from './config-loader';
import { walrusClient } from './walrus-client';

// Runtime configuration state
let runtimeConfig: AppConfig | null = null;

/**
 * Load runtime configuration for current network
 */
async function ensureConfigLoaded(): Promise<AppConfig> {
  if (!runtimeConfig) {
    const network = typeof window !== 'undefined' 
      ? (process.env.NEXT_PUBLIC_NETWORK || 'testnet')
      : 'testnet';
    
    runtimeConfig = await loadNetworkConfig(network);
    
    // Fallback config if load fails
    if (!runtimeConfig) {
      runtimeConfig = {
        network: {
          name: 'testnet',
          url: 'https://fullnode.testnet.sui.io',
          explorerUrl: 'https://testnet.suiexplorer.com',
        },
        walrus: {
          networkUrl: 'https://wal.testnet.sui.io',
          publisherUrl: 'https://publisher-testnet.walrus.space',
          aggregatorUrl: 'https://aggregator-testnet.walrus.space',
          apiPrefix: 'https://api-testnet.walrus.tech/1.0',
        },
        deployment: {
          packageId: '0xd6f97fc85796ee23adf60504a620631a0eea6947f85c4ca51e02245e9a4b57d7',
          digest: 'unknown',
          timestamp: new Date().toISOString(),
          deployerAddress: '0xca793690985183dc8e2180fd059d76f3b0644f5c2ecd3b01cdebe7d40b0cca39',
        },
        contracts: {
          todoNft: {
            packageId: '0xd6f97fc85796ee23adf60504a620631a0eea6947f85c4ca51e02245e9a4b57d7',
            moduleName: 'todo_nft',
            structName: 'TodoNFT',
          },
        },
        features: {
          aiEnabled: false,
          blockchainVerification: false,
          encryptedStorage: false,
        },
      };
    }
  }
  return runtimeConfig;
}

// Define wallet-aware service types
export interface WalletSigner {
  signTransaction?: (transaction: Transaction) => Promise<any>;
  signAndExecuteTransaction?: (transaction: Transaction) => Promise<any>;
  address?: string;
  publicKey?: PublicKey | string | null;
}

// Default data used when no data exists in storage
const defaultTodoLists: Record<string, TodoList> = {
  default: {
    name: 'Default',
    todos: [
      {
        id: '1',
        title: 'Set up blockchain wallet',
        completed: false,
        priority: 'high',
        tags: ['setup', 'blockchain'],
        blockchainStored: true,
        objectId: '0xabc123',
      },
      {
        id: '2',
        title: 'Design oceanic UI components',
        description: 'Create reusable Tailwind components with ocean theme',
        completed: true,
        priority: 'medium',
        tags: ['design', 'frontend'],
        blockchainStored: false,
      },
      {
        id: '3',
        title: 'Implement Sui blockchain connectivity',
        completed: false,
        priority: 'high',
        dueDate: '2023-12-01',
        blockchainStored: false,
      },
    ],
  },
  work: {
    name: 'Work',
    todos: [
      {
        id: '4',
        title: 'Test NFT todo transfers',
        completed: false,
        priority: 'medium',
        tags: ['testing', 'blockchain'],
        blockchainStored: false,
      },
    ],
  },
  personal: {
    name: 'Personal',
    todos: [],
  },
  shopping: {
    name: 'Shopping',
    todos: [],
  },
};

// Create a typed storage helper for wallet-scoped todo lists
// Structure: { [walletAddress]: { [listName]: TodoList } }
const walletTodoStorage = safeStorage.createTyped<
  Record<string, Record<string, TodoList>>
>('walrusTodoLists', {});

// Current in-memory reference to all wallet todo lists
let allWalletTodos: Record<string, Record<string, TodoList>> = {};

// Helper function to get wallet-specific storage key
function getWalletKey(address?: string): string {
  if (!address) return 'anonymous';
  return address.toLowerCase();
}

/**
 * Try to load todo lists from storage for all wallets
 */
function loadAllWalletTodos(): void {
  try {
    const storedTodos = walletTodoStorage.get();
    if (storedTodos && typeof storedTodos === 'object') {
      allWalletTodos = storedTodos;
    }

    if (isUsingFallbackStorage()) {
      console.info(
        `Using memory storage. Data will not persist between sessions.`
      );
    }
  } catch (e) {
    console.warn('Failed to load wallet todos from storage:', e);
  }
}

/**
 * Save all wallet todo lists to storage
 */
function saveAllWalletTodos(): void {
  try {
    walletTodoStorage.set(allWalletTodos);
  } catch (e) {
    console.warn('Failed to save wallet todos to storage:', e);
  }
}

/**
 * Get todos for a specific wallet, initializing with defaults if first time
 */
function getWalletTodos(address?: string): Record<string, TodoList> {
  const walletKey = getWalletKey(address);

  // Load from storage if not in memory
  if (!allWalletTodos[walletKey]) {
    loadAllWalletTodos();
  }

  // Initialize with default todos for new wallets
  if (!allWalletTodos[walletKey]) {
    allWalletTodos[walletKey] = { ...defaultTodoLists };
    saveAllWalletTodos();
  }

  return allWalletTodos[walletKey];
}

/**
 * Get all todo lists for a specific wallet
 */
export function getTodoLists(walletAddress?: string): string[] {
  const walletTodos = getWalletTodos(walletAddress);
  return Object.keys(walletTodos);
}

/**
 * Get a specific todo list for a wallet
 */
export function getTodoList(
  listName: string,
  walletAddress?: string
): TodoList | null {
  const walletTodos = getWalletTodos(walletAddress);
  return walletTodos[listName] || null;
}

/**
 * Get todos for a specific list and wallet
 */
export function getTodos(listName: string, walletAddress?: string): Todo[] {
  const walletTodos = getWalletTodos(walletAddress);
  return walletTodos[listName]?.todos || [];
}

/**
 * Add a new todo to a list for a specific wallet
 */
export function addTodo(
  listName: string,
  todo: Omit<Todo, 'id' | 'blockchainStored'>,
  walletAddress?: string
): Todo {
  const walletKey = getWalletKey(walletAddress);
  const walletTodos = getWalletTodos(walletAddress);

  if (!walletTodos[listName]) {
    walletTodos[listName] = {
      name: listName,
      todos: [],
    };
  }

  const newTodo: Todo = {
    ...todo,
    id: Date.now().toString(),
    blockchainStored: false,
  };

  walletTodos[listName].todos.push(newTodo);

  // Update the global state
  allWalletTodos[walletKey] = walletTodos;

  // Save changes
  saveAllWalletTodos();

  return newTodo;
}

/**
 * Update an existing todo for a specific wallet
 */
export function updateTodo(
  listName: string,
  updatedTodo: Todo,
  walletAddress?: string
): boolean {
  const walletKey = getWalletKey(walletAddress);
  const walletTodos = getWalletTodos(walletAddress);

  if (!walletTodos[listName]) return false;

  const index = walletTodos[listName].todos.findIndex(
    todo => todo.id === updatedTodo.id
  );
  if (index === -1) return false;

  walletTodos[listName].todos[index] = updatedTodo;

  // Update the global state
  allWalletTodos[walletKey] = walletTodos;

  // Save changes
  saveAllWalletTodos();

  return true;
}

/**
 * Delete a todo for a specific wallet
 */
export function deleteTodo(
  listName: string,
  todoId: string,
  walletAddress?: string
): boolean {
  const walletKey = getWalletKey(walletAddress);
  const walletTodos = getWalletTodos(walletAddress);

  if (!walletTodos[listName]) return false;

  const initialLength = walletTodos[listName].todos.length;
  walletTodos[listName].todos = walletTodos[listName].todos.filter(
    todo => todo.id !== todoId
  );

  // Update the global state
  allWalletTodos[walletKey] = walletTodos;

  // Save changes
  saveAllWalletTodos();

  return walletTodos[listName].todos.length !== initialLength;
}

/**
 * Create a new todo list for a specific wallet
 */
export function createTodoList(
  listName: string,
  walletAddress?: string
): boolean {
  const walletKey = getWalletKey(walletAddress);
  const walletTodos = getWalletTodos(walletAddress);

  if (walletTodos[listName]) return false;

  walletTodos[listName] = {
    name: listName,
    todos: [],
  };

  // Update the global state
  allWalletTodos[walletKey] = walletTodos;

  // Save changes
  saveAllWalletTodos();

  return true;
}

/**
 * Delete a todo list for a specific wallet
 */
export function deleteTodoList(
  listName: string,
  walletAddress?: string
): boolean {
  const walletKey = getWalletKey(walletAddress);
  const walletTodos = getWalletTodos(walletAddress);

  if (!walletTodos[listName] || listName === 'default') return false;

  delete walletTodos[listName];

  // Update the global state
  allWalletTodos[walletKey] = walletTodos;

  // Save changes
  saveAllWalletTodos();

  return true;
}

/**
 * Mark a todo as stored on blockchain for a specific wallet
 */
export function markTodoAsBlockchainStored(
  listName: string,
  todoId: string,
  objectId: string,
  walletAddress?: string
): boolean {
  const walletKey = getWalletKey(walletAddress);
  const walletTodos = getWalletTodos(walletAddress);

  if (!walletTodos[listName]) return false;

  const todoIndex = walletTodos[listName].todos.findIndex(
    todo => todo.id === todoId
  );
  if (todoIndex === -1) return false;

  walletTodos[listName].todos[todoIndex].blockchainStored = true;
  walletTodos[listName].todos[todoIndex].objectId = objectId;

  // Update the global state
  allWalletTodos[walletKey] = walletTodos;

  // Save changes
  saveAllWalletTodos();

  return true;
}

/**
 * Store a todo on the blockchain using wallet signer
 */
export async function storeTodoOnBlockchain(
  listName: string,
  todoId: string,
  signer?: WalletSigner,
  walletAddress?: string
): Promise<string | null> {
  const walletTodos = getWalletTodos(walletAddress);

  if (!walletTodos[listName]) return null;

  const todo = walletTodos[listName].todos.find(t => t.id === todoId);
  if (!todo) return null;

  // If no signer provided, operate in read-only mode
  if (!signer || !signer.signAndExecuteTransaction) {
    console.warn('No wallet signer available - running in read-only mode');
    return null;
  }

  try {
    // Load runtime configuration
    const config = await ensureConfigLoaded();

    // First, upload the todo data to Walrus
    const todoData = {
      title: todo.title,
      description: todo.description || '',
      priority: todo.priority,
      tags: todo.tags,
      dueDate: todo.dueDate,
      createdAt: new Date().toISOString(),
      localId: todo.id,
    };

    console.log('Uploading todo data to Walrus...');
    const walrusResult = await walrusClient.uploadJson(todoData, { epochs: 5 });
    console.log('Walrus upload successful:', walrusResult.blobId);

    // Create a transaction for storing the todo
    const tx = new Transaction();

    // Convert todo data to bytes for the Move contract
    const titleBytes = new TextEncoder().encode(todo.title);
    const descriptionBytes = new TextEncoder().encode(todo.description || '');
    // Use the Walrus blob URL as the image URL (storing metadata there)
    const imageUrlBytes = new TextEncoder().encode(
      walrusClient.getBlobUrl(walrusResult.blobId)
    );
    const metadataBytes = new TextEncoder().encode(
      JSON.stringify({
        priority: todo.priority,
        tags: todo.tags,
        dueDate: todo.dueDate,
        walrusBlobId: walrusResult.blobId,
      })
    );

    // Call the create_todo_nft function from the deployed contract
    tx.moveCall({
      target: `${config.deployment.packageId}::todo_nft::create_todo_nft`,
      arguments: [
        tx.pure.vector('u8', Array.from(titleBytes)),
        tx.pure.vector('u8', Array.from(descriptionBytes)),
        tx.pure.vector('u8', Array.from(imageUrlBytes)),
        tx.pure.vector('u8', Array.from(metadataBytes)),
        tx.pure.bool(false), // is_private
      ],
    });

    console.log('Executing transaction for todo:', todo.title);

    // Execute the transaction
    const result = await signer.signAndExecuteTransaction(tx);

    // Extract the created object ID from the transaction result
    const objectId = result.effects?.created?.[0]?.reference?.objectId || null;

    if (objectId) {
      // Mark the todo as stored
      markTodoAsBlockchainStored(listName, todoId, objectId, walletAddress);
      console.log('Todo NFT created with ID:', objectId);
    }

    return objectId;
  } catch (error) {
    console.error('Failed to store todo on blockchain:', error);
    return null;
  }
}

/**
 * Retrieve todos from blockchain storage
 */
export async function retrieveTodosFromBlockchain(
  address?: string
): Promise<Todo[]> {
  if (!address) {
    console.warn('No address provided - cannot retrieve blockchain todos');
    return [];
  }

  try {
    // Load runtime configuration
    const config = await ensureConfigLoaded();

    // Create a Sui client to query the blockchain
    const client = new SuiClient({ url: config.network.url });

    // Query for TodoNFT objects owned by the address
    const objects = await client.getOwnedObjects({
      owner: address,
      filter: {
        StructType: `${config.deployment.packageId}::todo_nft::TodoNFT`,
      },
      options: {
        showContent: true,
        showType: true,
      },
    });

    // Convert blockchain objects to Todo format
    const todos: Todo[] = [];

    for (const obj of objects.data) {
      if (obj.data?.content?.dataType === 'moveObject') {
        const fields = obj.data.content.fields as any;

        // Parse metadata if available
        let metadata = {
          priority: 'medium' as const,
          tags: [] as string[],
          dueDate: undefined as string | undefined,
          walrusBlobId: undefined as string | undefined,
        };
        try {
          if (fields.metadata) {
            metadata = JSON.parse(fields.metadata);
          }
        } catch (e) {
          console.warn('Failed to parse todo metadata:', e);
        }

        // If there's a Walrus blob ID, we can fetch additional data
        if (metadata.walrusBlobId) {
          try {
            const walrusData = await walrusClient.downloadJson(
              metadata.walrusBlobId
            );
            console.log('Fetched Walrus data for todo:', walrusData);
          } catch (e) {
            console.warn('Failed to fetch Walrus data:', e);
          }
        }

        todos.push({
          id: obj.data.objectId,
          title: fields.title || '',
          description: fields.description || '',
          completed: fields.completed || false,
          priority: metadata.priority,
          tags: metadata.tags,
          dueDate: metadata.dueDate,
          blockchainStored: true,
          objectId: obj.data.objectId,
        });
      }
    }

    console.log(
      `Retrieved ${todos.length} todos from blockchain for address:`,
      address
    );
    return todos;
  } catch (error) {
    console.error('Failed to retrieve todos from blockchain:', error);
    return [];
  }
}

/**
 * Complete a todo on the blockchain
 */
export async function completeTodoOnBlockchain(
  listName: string,
  todoId: string,
  signer?: WalletSigner,
  walletAddress?: string
): Promise<boolean> {
  const walletTodos = getWalletTodos(walletAddress);

  if (!walletTodos[listName]) return false;

  const todo = walletTodos[listName].todos.find(t => t.id === todoId);
  if (!todo || !todo.blockchainStored || !todo.objectId) {
    console.error('Todo not found or not stored on blockchain');
    return false;
  }

  if (!signer || !signer.signAndExecuteTransaction) {
    console.warn('No wallet signer available - cannot complete NFT');
    return false;
  }

  try {
    // Load runtime configuration
    const config = await ensureConfigLoaded();

    // Create a transaction to complete the todo
    const tx = new Transaction();

    // Call the complete_todo function from the contract
    tx.moveCall({
      target: `${config.deployment.packageId}::todo_nft::complete_todo`,
      arguments: [tx.object(todo.objectId)],
    });

    console.log('Marking todo as complete:', todo.objectId);

    // Execute the transaction
    const result = await signer.signAndExecuteTransaction(tx);
    console.log('Complete transaction result:', result);

    // Update local state after successful completion
    if (result.digest) {
      todo.completed = true;
      updateTodo(listName, todo, walletAddress);
      return true;
    }

    return false;
  } catch (error) {
    console.error('Failed to complete todo on blockchain:', error);
    return false;
  }
}

/**
 * Transfer a todo NFT to another address
 * This requires the todo to be stored on blockchain
 */
export async function transferTodoNFT(
  listName: string,
  todoId: string,
  toAddress: string,
  signer?: WalletSigner,
  walletAddress?: string
): Promise<boolean> {
  const walletTodos = getWalletTodos(walletAddress);

  if (!walletTodos[listName]) return false;

  const todo = walletTodos[listName].todos.find(t => t.id === todoId);
  if (!todo || !todo.blockchainStored || !todo.objectId) {
    console.error('Todo not found or not stored on blockchain');
    return false;
  }

  if (!signer || !signer.signAndExecuteTransaction) {
    console.warn('No wallet signer available - cannot transfer NFT');
    return false;
  }

  try {
    // Load runtime configuration
    const config = await ensureConfigLoaded();

    // Create a transfer transaction
    const tx = new Transaction();

    // Use the custom transfer function from the contract which emits events
    tx.moveCall({
      target: `${config.deployment.packageId}::todo_nft::transfer_todo_nft`,
      arguments: [tx.object(todo.objectId), tx.pure.address(toAddress)],
    });

    console.log('Transferring NFT:', todo.objectId, 'to:', toAddress);

    // Execute the transaction
    const result = await signer.signAndExecuteTransaction(tx);
    console.log('Transfer transaction result:', result);

    // Remove the todo from the sender's list after successful transfer
    if (result.digest) {
      deleteTodo(listName, todoId, walletAddress);
      return true;
    }

    return false;
  } catch (error) {
    console.error('Failed to transfer todo NFT:', error);
    return false;
  }
}
</file>

<file path="src/lib/wallet-errors.ts">
/**
 * Custom wallet error classes and handlers
 */

// Base wallet error class
export class WalletError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'WalletError';
  }
}

// Error when no wallet is selected
export class WalletNotSelectedError extends WalletError {
  constructor() {
    super('No wallet selected. Please select a wallet before connecting.');
    this.name = 'WalletNotSelectedError';
  }
}

// Error when wallet is not installed
export class WalletNotInstalledError extends WalletError {
  walletName: string;

  constructor(walletName: string) {
    super(
      `${walletName} wallet is not installed. Please install the extension first.`
    );
    this.name = 'WalletNotInstalledError';
    this.walletName = walletName;
  }
}

// Error when wallet is not supported in this environment
export class WalletNotSupportedError extends WalletError {
  walletName: string;
  environment: string;

  constructor(walletName: string, environment: string) {
    super(`${walletName} wallet is not supported in ${environment}.`);
    this.name = 'WalletNotSupportedError';
    this.walletName = walletName;
    this.environment = environment;
  }
}

// Error when wallet connection is rejected by user
export class WalletConnectionRejectedError extends WalletError {
  constructor() {
    super('Wallet connection was rejected. Please try again.');
    this.name = 'WalletConnectionRejectedError';
  }
}

// Error when wallet is already connected
export class WalletAlreadyConnectedError extends WalletError {
  constructor() {
    super('Wallet is already connected.');
    this.name = 'WalletAlreadyConnectedError';
  }
}

// Helper function to categorize common wallet errors
export function categorizeWalletError(error: unknown): WalletError {
  // If already one of our custom errors, return it
  if (error instanceof WalletError) {
    return error;
  }

  // Convert to string for pattern matching
  const message = error instanceof Error ? error.message : String(error);
  const lowerMessage = message.toLowerCase();

  // Common error patterns
  if (
    lowerMessage.includes('user rejected') ||
    lowerMessage.includes('user denied')
  ) {
    return new WalletConnectionRejectedError();
  }

  if (
    lowerMessage.includes('not selected') ||
    lowerMessage.includes('no wallet selected')
  ) {
    return new WalletNotSelectedError();
  }

  if (
    lowerMessage.includes('not installed') ||
    lowerMessage.includes('not detected')
  ) {
    const walletName = lowerMessage.includes('phantom')
      ? 'Phantom'
      : lowerMessage.includes('sui')
        ? 'Sui'
        : 'Wallet';
    return new WalletNotInstalledError(walletName);
  }

  // Check for Backpack-specific errors
  if (lowerMessage.includes('backpack') || lowerMessage.includes('xnft')) {
    if (
      lowerMessage.includes('not installed') ||
      lowerMessage.includes('not found') ||
      lowerMessage.includes('undefined')
    ) {
      return new WalletNotInstalledError('Backpack');
    }

    if (
      lowerMessage.includes('rejected') ||
      lowerMessage.includes('denied') ||
      lowerMessage.includes('declined')
    ) {
      return new WalletConnectionRejectedError();
    }
  }

  // If we can't categorize, return a generic WalletError
  return new WalletError(
    error instanceof Error ? error.message : 'Unknown wallet error occurred'
  );
}

// Get user-friendly error message and suggested action
export function getWalletErrorMessage(error: WalletError): {
  message: string;
  suggestion: string;
} {
  if (error instanceof WalletNotSelectedError) {
    return {
      message: 'No wallet selected',
      suggestion: 'Please select a wallet before connecting',
    };
  }

  if (error instanceof WalletNotInstalledError) {
    // Provide wallet-specific installation instructions
    const walletName = error.walletName;
    let installUrl = '';
    let suggestion = `Please install the ${walletName} browser extension first`;

    // Provide specific installation URLs based on wallet type
    if (walletName.includes('Phantom')) {
      installUrl = 'https://phantom.app/download';
      suggestion = `Please install the Phantom browser extension from ${installUrl}`;
    } else if (walletName.includes('Sui') || walletName.includes('Slush')) {
      installUrl =
        'https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil';
      suggestion = `Please install the Sui/Slush browser extension from the Chrome Web Store`;
    } else if (walletName.includes('Backpack')) {
      installUrl = 'https://www.backpack.app/download';
      suggestion = `Please install the Backpack browser extension from ${installUrl}`;
    }

    return {
      message: `${walletName} wallet not installed`,
      suggestion: suggestion,
    };
  }

  if (error instanceof WalletNotSupportedError) {
    return {
      message: `${error.walletName} not supported`,
      suggestion: `Try using a different browser or environment`,
    };
  }

  if (error instanceof WalletConnectionRejectedError) {
    return {
      message: 'Connection rejected',
      suggestion: 'Please approve the connection request in your wallet',
    };
  }

  if (error instanceof WalletAlreadyConnectedError) {
    return {
      message: 'Already connected',
      suggestion: 'Your wallet is already connected',
    };
  }

  // Default case
  return {
    message: error.message || 'Wallet error',
    suggestion: 'Please try again or use a different wallet',
  };
}
</file>

<file path="src/lib/wallet-safe-operations.ts">
/**
 * Safe wallet operations with comprehensive error handling
 * Prevents common wallet errors from crashing the application
 */

export type WalletOperationResult<T> = {
  success: boolean;
  data?: T;
  error?: string;
  isExpectedError?: boolean; // True for errors like "wallet not installed"
};

/**
 * Safely execute a wallet operation with comprehensive error handling
 */
export async function safeWalletOperation<T>(
  operation: () => Promise<T>,
  operationName: string = 'wallet operation'
): Promise<WalletOperationResult<T>> {
  try {
    const result = await operation();
    return {
      success: true,
      data: result,
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);

    // Categorize errors as expected or unexpected
    const isExpectedError =
      errorMessage.includes('select failed: wallet') ||
      errorMessage.includes('is not available') ||
      errorMessage.includes('UNKNOWN_ERROR') ||
      errorMessage.includes('KIT.UNKNOWN_ERROR') ||
      errorMessage.includes('not installed') ||
      errorMessage.includes('rejected') ||
      errorMessage.includes('cancelled') ||
      errorMessage.includes('Access to storage is not allowed');

    if (isExpectedError) {
      console.warn(
        `[SafeWallet] Expected error in ${operationName}:`,
        errorMessage
      );
    } else {
      console.error(
        `[SafeWallet] Unexpected error in ${operationName}:`,
        error
      );
    }

    return {
      success: false,
      error: errorMessage,
      isExpectedError,
    };
  }
}

/**
 * Check if a wallet is available before attempting operations
 */
export function isWalletAvailable(
  walletName: string,
  availableWallets: any[]
): boolean {
  if (!Array.isArray(availableWallets)) {
    console.warn(
      '[SafeWallet] Available wallets list is not an array:',
      availableWallets
    );
    return false;
  }

  return availableWallets.some(wallet => {
    if (!wallet || typeof wallet !== 'object') {
      return false;
    }

    // Check both name and label properties as different wallet kits use different property names
    return wallet.name === walletName || wallet.label === walletName;
  });
}

/**
 * Safely get available wallets with error handling
 */
export function safeGetWallets(walletKit: any): any[] {
  try {
    if (!walletKit) {
      return [];
    }

    // Try different methods that different wallet kits might use
    if (typeof walletKit.getWallets === 'function') {
      const result = walletKit.getWallets();
      return Array.isArray(result) ? result : [];
    }

    if (Array.isArray(walletKit.wallets)) {
      return walletKit.wallets;
    }

    if (typeof walletKit.configuredWallets === 'function') {
      const result = walletKit.configuredWallets();
      return Array.isArray(result) ? result : [];
    }

    // Check for Suiet wallet kit specific properties
    if (walletKit.store && typeof walletKit.store.getState === 'function') {
      const state = walletKit.store.getState();
      if (Array.isArray(state.wallets)) {
        return state.wallets;
      }
    }

    // Silently return empty array instead of warning to reduce console noise
    return [];
  } catch (error) {
    // Silently handle errors to reduce console noise
    return [];
  }
}

/**
 * Safely attempt to clear wallet data from storage
 */
export function safeClearWalletStorage(walletName?: string): void {
  if (typeof window === 'undefined') {
    return;
  }

  try {
    if (walletName) {
      localStorage.removeItem('lastConnectedWallet');
    }

    // Clear any other wallet-related storage
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (
        key &&
        (key.includes('wallet') ||
          key.includes('sui') ||
          key.includes('phantom'))
      ) {
        keysToRemove.push(key);
      }
    }

    keysToRemove.forEach(key => {
      try {
        localStorage.removeItem(key);
      } catch (e) {
        console.warn(`[SafeWallet] Failed to remove storage key ${key}:`, e);
      }
    });
  } catch (error) {
    console.warn('[SafeWallet] Error clearing wallet storage:', error);
  }
}

/**
 * Create a safer version of wallet select with validation
 */
export async function safeWalletSelect(
  walletKit: any,
  walletName: string
): Promise<WalletOperationResult<void>> {
  return safeWalletOperation(async () => {
    // First check if wallet is available
    const availableWallets = safeGetWallets(walletKit);

    if (!isWalletAvailable(walletName, availableWallets)) {
      throw new Error(
        `Wallet "${walletName}" is not available. Available wallets: ${availableWallets.map(w => w.name || w.label).join(', ')}`
      );
    }

    // Attempt to select the wallet
    if (typeof walletKit.select === 'function') {
      await walletKit.select(walletName);
    } else {
      throw new Error('Wallet kit does not support select operation');
    }
  }, `select wallet "${walletName}"`);
}
</file>

<file path="src/lib/walrus-client.ts">
/**
 * Direct Walrus HTTP client for browser-based storage
 * Implements blob upload/download without backend dependency
 */

import { loadAppConfig } from '@/lib/config-loader';

export interface WalrusUploadResponse {
  blobId: string;
  size: number;
  encodedSize: number;
  cost: number;
}

export interface WalrusBlob {
  id: string;
  data: Uint8Array;
  contentType?: string;
}

export class WalrusClient {
  private publisherUrl: string;
  private aggregatorUrl: string;
  private configPromise: Promise<void>;

  constructor() {
    // Set fallback URLs initially
    this.publisherUrl = 'https://publisher-testnet.walrus.space';
    this.aggregatorUrl = 'https://aggregator-testnet.walrus.space';
    
    // Load configuration asynchronously
    this.configPromise = this.loadConfig();
  }

  private async loadConfig(): Promise<void> {
    try {
      const config = await loadAppConfig();
      this.publisherUrl = config.walrus.publisherUrl;
      this.aggregatorUrl = config.walrus.aggregatorUrl;
    } catch (error) {
      console.warn('Failed to load Walrus config, using fallback URLs:', error);
    }
  }

  private async ensureConfigLoaded(): Promise<void> {
    await this.configPromise;
  }

  /**
   * Upload data to Walrus storage
   */
  async upload(
    data: Uint8Array | string,
    options?: {
      epochs?: number;
      contentType?: string;
    }
  ): Promise<WalrusUploadResponse> {
    await this.ensureConfigLoaded();
    try {
      // Convert string to Uint8Array if needed
      const blobData =
        typeof data === 'string' ? new TextEncoder().encode(data) : data;

      // Prepare the request
      const formData = new FormData();
      const blob = new Blob([blobData], {
        type: options?.contentType || 'application/octet-stream',
      });
      formData.append('file', blob);

      // Add epochs parameter if specified
      const url = new URL(`${this.publisherUrl}/v1/store`);
      if (options?.epochs) {
        url.searchParams.append('epochs', options.epochs.toString());
      }

      // Make the upload request
      const response = await fetch(url.toString(), {
        method: 'PUT',
        body: blobData,
        headers: {
          'Content-Type': options?.contentType || 'application/octet-stream',
        },
      });

      if (!response.ok) {
        const error = await response.text();
        throw new Error(`Upload failed: ${response.status} - ${error}`);
      }

      const result = await response.json();

      // Extract blob ID from response
      // Walrus returns either newlyCreated or alreadyCertified
      const blobInfo = result.newlyCreated || result.alreadyCertified;
      if (!blobInfo?.blobId) {
        throw new Error('Invalid response from Walrus');
      }

      return {
        blobId: blobInfo.blobId,
        size: blobInfo.size || blobData.length,
        encodedSize: blobInfo.encodedSize || blobData.length,
        cost: blobInfo.cost || 0,
      };
    } catch (error) {
      console.error('Walrus upload error:', error);
      throw error;
    }
  }

  /**
   * Download data from Walrus storage
   */
  async download(blobId: string): Promise<WalrusBlob> {
    await this.ensureConfigLoaded();
    try {
      const response = await fetch(`${this.aggregatorUrl}/v1/${blobId}`, {
        method: 'GET',
      });

      if (!response.ok) {
        throw new Error(`Download failed: ${response.status}`);
      }

      const data = await response.arrayBuffer();
      const contentType = response.headers.get('content-type') || undefined;

      return {
        id: blobId,
        data: new Uint8Array(data),
        contentType,
      };
    } catch (error) {
      console.error('Walrus download error:', error);
      throw error;
    }
  }

  /**
   * Upload JSON data
   */
  async uploadJson(
    data: unknown,
    options?: { epochs?: number }
  ): Promise<WalrusUploadResponse> {
    const jsonString = JSON.stringify(data);
    return this.upload(jsonString, {
      ...options,
      contentType: 'application/json',
    });
  }

  /**
   * Download and parse JSON data
   */
  async downloadJson<T = unknown>(blobId: string): Promise<T> {
    const blob = await this.download(blobId);
    const text = new TextDecoder().decode(blob.data);
    return JSON.parse(text);
  }

  /**
   * Upload an image file
   */
  async uploadImage(
    file: File,
    options?: { epochs?: number }
  ): Promise<WalrusUploadResponse> {
    const data = await file.arrayBuffer();
    return this.upload(new Uint8Array(data), {
      ...options,
      contentType: file.type,
    });
  }

  /**
   * Get a public URL for a blob
   */
  getBlobUrl(blobId: string): string {
    return `${this.aggregatorUrl}/v1/${blobId}`;
  }

  /**
   * Check if a blob exists
   */
  async exists(blobId: string): Promise<boolean> {
    await this.ensureConfigLoaded();
    try {
      const response = await fetch(`${this.aggregatorUrl}/v1/${blobId}`, {
        method: 'HEAD',
      });
      return response.ok;
    } catch {
      return false;
    }
  }

  /**
   * Delete blob by ID
   */
  async deleteBlob(blobId: string, signer: unknown): Promise<string> {
    // Stub: implement deletion logic if needed
    return blobId;
  }

  /**
   * Check if blob exists (alias)
   */
  async blobExists(blobId: string): Promise<boolean> {
    return this.exists(blobId);
  }

  /**
   * Get blob info
   */
  async getBlobInfo(blobId: string): Promise<{ size?: number }> {
    const blob = await this.download(blobId);
    return { size: blob.data.length };
  }

  /**
   * Calculate storage cost based on size and epochs
   */
  async calculateStorageCost(
    size: number,
    epochs: number
  ): Promise<{ totalCost: bigint; storageCost: bigint; writeCost: bigint }> {
    const writeCost = BigInt(size);
    const storageCost = BigInt(size) * BigInt(epochs);
    return { totalCost: writeCost + storageCost, storageCost, writeCost };
  }

  /**
   * Get WAL balance (stub)
   */
  async getWalBalance(): Promise<string> {
    return '0';
  }

  /**
   * Get storage usage (stub)
   */
  async getStorageUsage(): Promise<{ used: string; total: string }> {
    return { used: '0', total: '0' };
  }
}

// Singleton instance
export const walrusClient = new WalrusClient();

// Exporting a custom error for Walrus client operations
export class WalrusClientError extends Error {
  public code?: string;
  public cause?: Error;
  constructor(message: string, code?: string, cause?: Error) {
    super(message);
    this.name = 'WalrusClientError';
    this.code = code;
    if (cause) {
      this.cause = cause;
    }
  }
}

// Alias for the HTTP client
export type FrontendWalrusClient = WalrusClient;

// Supported network types for Walrus storage
export type WalrusNetwork = 'mainnet' | 'testnet' | 'devnet' | 'localnet';

// Result type for WalrusTodoStorage operations
export interface WalrusUploadResult {
  blobId: string;
  metadata: {
    size: number;
    [key: string]: unknown;
  };
}

// Content encoder stub for extra attributes
export class ContentEncoder {
  static encode(data: unknown): Uint8Array {
    return new TextEncoder().encode(JSON.stringify(data));
  }
}

// Error classes for retry and validation
export class WalrusRetryError extends WalrusClientError {
  constructor(message: string) {
    super(message, 'RETRY_ERROR');
    this.name = 'WalrusRetryError';
  }
}

export class WalrusValidationError extends WalrusClientError {
  constructor(message: string) {
    super(message, 'VALIDATION_ERROR');
    this.name = 'WalrusValidationError';
  }
}

// Abstraction for Todo storage operations
export class WalrusTodoStorage {
  private client: FrontendWalrusClient;
  constructor(network: WalrusNetwork) {
    this.client = walrusClient;
  }
  getClient(): FrontendWalrusClient {
    return this.client;
  }
  async storeTodo(
    data: unknown,
    signer: unknown,
    options: {
      epochs?: number;
      deletable?: boolean;
      attributes?: unknown;
      onProgress?: (p: number) => void;
    }
  ): Promise<WalrusUploadResult> {
    const result = await this.client.uploadJson(data, {
      epochs: options.epochs,
    });
    return {
      blobId: result.blobId,
      metadata: { size: result.encodedSize || result.size },
    };
  }
  /**
   * Retrieve JSON todo data from Walrus storage
   */
  async retrieveTodo(walrusBlobId: string): Promise<unknown> {
    return this.client.downloadJson(walrusBlobId);
  }
  async estimateTodoStorageCost(
    data: unknown,
    epochs: number
  ): Promise<{
    totalCost: bigint;
    sizeBytes: number;
    storageCost: bigint;
    writeCost: bigint;
  }> {
    const sizeBytes = JSON.stringify(data).length;
    const writeCost = BigInt(sizeBytes);
    const storageCost = BigInt(sizeBytes) * BigInt(epochs);
    return {
      totalCost: writeCost + storageCost,
      sizeBytes,
      storageCost,
      writeCost,
    };
  }
}
</file>

<file path="src/lib/walrus-error-handling.ts">
/**
 * Comprehensive Error Handling for Walrus Protocol Integration
 *
 * This module provides specialized error handling, recovery strategies,
 * and user-friendly error messages for Walrus Protocol operations.
 */

import { WalrusClientError } from './walrus-client';

// Error categories for better handling
export enum WalrusErrorCategory {
  NETWORK = 'network',
  AUTHENTICATION = 'authentication',
  STORAGE = 'storage',
  VALIDATION = 'validation',
  QUOTA = 'quota',
  PERMISSION = 'permission',
  UNKNOWN = 'unknown',
}

// Error severity levels
export enum ErrorSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical',
}

// User-facing error information
export interface UserErrorInfo {
  title: string;
  message: string;
  suggestion: string;
  canRetry: boolean;
  severity: ErrorSeverity;
  category: WalrusErrorCategory;
  technicalDetails?: string;
  helpUrl?: string;
}

// Recovery action interface
export interface RecoveryAction {
  label: string;
  action: () => Promise<void> | void;
  isPrimary?: boolean;
}

/**
 * Comprehensive error analyzer for Walrus operations
 */
export class WalrusErrorAnalyzer {
  /**
   * Analyze error and return user-friendly information
   */
  static analyzeError(error: unknown): UserErrorInfo {
    if (error instanceof WalrusClientError) {
      return this.analyzeWalrusClientError(error);
    }

    if (error instanceof Error) {
      return this.analyzeGenericError(error);
    }

    return this.createUnknownErrorInfo(String(error));
  }

  /**
   * Analyze WalrusClientError specifically
   */
  private static analyzeWalrusClientError(
    error: WalrusClientError
  ): UserErrorInfo {
    const code = error.code?.toLowerCase() || '';
    const message = error.message.toLowerCase();

    // Network-related errors
    if (
      code.includes('network') ||
      message.includes('network') ||
      message.includes('connection') ||
      message.includes('timeout')
    ) {
      return {
        title: 'Network Connection Error',
        message: 'Unable to connect to Walrus Protocol network.',
        suggestion:
          'Check your internet connection and try again. The Walrus network may be temporarily unavailable.',
        canRetry: true,
        severity: ErrorSeverity.MEDIUM,
        category: WalrusErrorCategory.NETWORK,
        technicalDetails: error.message,
        helpUrl: 'https://docs.walrus.site/troubleshooting/network',
      };
    }

    // Insufficient funds
    if (
      code.includes('funds') ||
      message.includes('insufficient') ||
      message.includes('balance') ||
      message.includes('wal')
    ) {
      return {
        title: 'Insufficient WAL Tokens',
        message:
          "You don't have enough WAL tokens to complete this storage operation.",
        suggestion:
          'Get more WAL tokens from the testnet faucet or check your wallet balance.',
        canRetry: false,
        severity: ErrorSeverity.HIGH,
        category: WalrusErrorCategory.QUOTA,
        technicalDetails: error.message,
        helpUrl: 'https://docs.walrus.site/usage/web-api#testnet-wal-faucet',
      };
    }

    // Authentication/signer errors
    if (
      code.includes('signer') ||
      message.includes('signer') ||
      message.includes('signature') ||
      message.includes('auth')
    ) {
      return {
        title: 'Wallet Authentication Error',
        message:
          'Failed to authenticate with your wallet for the storage operation.',
        suggestion:
          'Make sure your wallet is connected and try signing the transaction again.',
        canRetry: true,
        severity: ErrorSeverity.HIGH,
        category: WalrusErrorCategory.AUTHENTICATION,
        technicalDetails: error.message,
      };
    }

    // Blob not found errors
    if (
      code.includes('not_found') ||
      message.includes('not found') ||
      (message.includes('blob') && message.includes('exist'))
    ) {
      return {
        title: 'Todo Not Found',
        message: 'The requested todo could not be found in Walrus storage.',
        suggestion:
          "Check the blob ID and make sure the todo hasn't expired or been deleted.",
        canRetry: false,
        severity: ErrorSeverity.MEDIUM,
        category: WalrusErrorCategory.STORAGE,
        technicalDetails: error.message,
      };
    }

    // Validation errors
    if (
      code.includes('validation') ||
      message.includes('invalid') ||
      message.includes('size') ||
      message.includes('format')
    ) {
      return {
        title: 'Invalid Data',
        message: 'The todo data is invalid or exceeds size limits.',
        suggestion:
          'Check that your todo content is under 13MB and properly formatted.',
        canRetry: false,
        severity: ErrorSeverity.MEDIUM,
        category: WalrusErrorCategory.VALIDATION,
        technicalDetails: error.message,
      };
    }

    // Storage quota errors
    if (
      message.includes('quota') ||
      message.includes('limit') ||
      (message.includes('storage') && message.includes('exceeded'))
    ) {
      return {
        title: 'Storage Quota Exceeded',
        message: 'You have exceeded your storage quota on Walrus Protocol.',
        suggestion:
          'Delete some older todos or purchase additional storage capacity.',
        canRetry: false,
        severity: ErrorSeverity.HIGH,
        category: WalrusErrorCategory.QUOTA,
        technicalDetails: error.message,
      };
    }

    // Generic Walrus error
    return {
      title: 'Walrus Storage Error',
      message: 'An error occurred while communicating with Walrus Protocol.',
      suggestion: 'Please try again. If the problem persists, contact support.',
      canRetry: true,
      severity: ErrorSeverity.MEDIUM,
      category: WalrusErrorCategory.STORAGE,
      technicalDetails: error.message,
    };
  }

  /**
   * Analyze generic JavaScript errors
   */
  private static analyzeGenericError(error: Error): UserErrorInfo {
    const message = error.message.toLowerCase();

    // Network errors
    if (
      message.includes('fetch') ||
      message.includes('network') ||
      message.includes('cors') ||
      message.includes('timeout')
    ) {
      return {
        title: 'Network Error',
        message: 'A network error occurred while processing your request.',
        suggestion: 'Check your internet connection and try again.',
        canRetry: true,
        severity: ErrorSeverity.MEDIUM,
        category: WalrusErrorCategory.NETWORK,
        technicalDetails: error.message,
      };
    }

    // Permission errors
    if (
      message.includes('permission') ||
      message.includes('denied') ||
      message.includes('forbidden') ||
      message.includes('unauthorized')
    ) {
      return {
        title: 'Permission Denied',
        message: "You don't have permission to perform this operation.",
        suggestion:
          'Make sure your wallet is connected and you have the necessary permissions.',
        canRetry: false,
        severity: ErrorSeverity.HIGH,
        category: WalrusErrorCategory.PERMISSION,
        technicalDetails: error.message,
      };
    }

    // Generic error
    return {
      title: 'Unexpected Error',
      message: 'An unexpected error occurred.',
      suggestion: 'Please try again. If the problem persists, contact support.',
      canRetry: true,
      severity: ErrorSeverity.MEDIUM,
      category: WalrusErrorCategory.UNKNOWN,
      technicalDetails: error.message,
    };
  }

  /**
   * Create error info for unknown errors
   */
  private static createUnknownErrorInfo(errorString: string): UserErrorInfo {
    return {
      title: 'Unknown Error',
      message: 'An unknown error occurred.',
      suggestion: 'Please try again. If the problem persists, contact support.',
      canRetry: true,
      severity: ErrorSeverity.LOW,
      category: WalrusErrorCategory.UNKNOWN,
      technicalDetails: errorString,
    };
  }

  /**
   * Check if error is retryable
   */
  static isRetryable(error: unknown): boolean {
    const errorInfo = this.analyzeError(error);
    return errorInfo.canRetry;
  }

  /**
   * Get suggested retry delay based on error type
   */
  static getRetryDelay(error: unknown, attempt: number): number {
    const errorInfo = this.analyzeError(error);

    // Base delays by category (in milliseconds)
    const baseDelays = {
      [WalrusErrorCategory.NETWORK]: 1000,
      [WalrusErrorCategory.STORAGE]: 2000,
      [WalrusErrorCategory.AUTHENTICATION]: 1500,
      [WalrusErrorCategory.QUOTA]: 5000,
      [WalrusErrorCategory.PERMISSION]: 3000,
      [WalrusErrorCategory.VALIDATION]: 0, // Don't retry validation errors
      [WalrusErrorCategory.UNKNOWN]: 2000,
    };

    const baseDelay = baseDelays[errorInfo.category] || 2000;

    // Exponential backoff with jitter
    return baseDelay * Math.pow(2, attempt - 1) + Math.random() * 1000;
  }
}

/**
 * Error recovery manager
 */
export class WalrusErrorRecovery {
  /**
   * Get recovery actions for an error
   */
  static getRecoveryActions(
    error: unknown,
    context?: {
      refreshWallet?: () => Promise<void>;
      refreshBalance?: () => Promise<void>;
      retryOperation?: () => Promise<void>;
      switchNetwork?: () => Promise<void>;
    }
  ): RecoveryAction[] {
    const errorInfo = WalrusErrorAnalyzer.analyzeError(error);
    const actions: RecoveryAction[] = [];

    switch (errorInfo.category) {
      case WalrusErrorCategory.NETWORK:
        if (context?.retryOperation) {
          actions.push({
            label: 'Retry',
            action: context.retryOperation,
            isPrimary: true,
          });
        }
        if (context?.switchNetwork) {
          actions.push({
            label: 'Switch Network',
            action: context.switchNetwork,
          });
        }
        break;

      case WalrusErrorCategory.AUTHENTICATION:
        if (context?.refreshWallet) {
          actions.push({
            label: 'Reconnect Wallet',
            action: context.refreshWallet,
            isPrimary: true,
          });
        }
        break;

      case WalrusErrorCategory.QUOTA:
        if (context?.refreshBalance) {
          actions.push({
            label: 'Check Balance',
            action: context.refreshBalance,
            isPrimary: true,
          });
        }
        actions.push({
          label: 'Get Test Tokens',
          action: () => {
            window.open(
              'https://docs.walrus.site/usage/web-api#testnet-wal-faucet',
              '_blank'
            );
          },
        });
        break;

      case WalrusErrorCategory.STORAGE:
        if (context?.retryOperation && errorInfo.canRetry) {
          actions.push({
            label: 'Retry',
            action: context.retryOperation,
            isPrimary: true,
          });
        }
        break;

      default:
        if (context?.retryOperation && errorInfo.canRetry) {
          actions.push({
            label: 'Try Again',
            action: context.retryOperation,
            isPrimary: true,
          });
        }
        break;
    }

    // Always add a help action if help URL is available
    if (errorInfo.helpUrl) {
      actions.push({
        label: 'Get Help',
        action: () => {
          window.open(errorInfo.helpUrl, '_blank');
        },
      });
    }

    return actions;
  }

  /**
   * Auto-recovery for certain error types
   */
  static async attemptAutoRecovery(
    error: unknown,
    context: {
      refreshWallet?: () => Promise<void>;
      refreshBalance?: () => Promise<void>;
      retryOperation?: () => Promise<void>;
    }
  ): Promise<boolean> {
    const errorInfo = WalrusErrorAnalyzer.analyzeError(error);

    // Don't auto-recover from high severity errors
    if (
      errorInfo.severity === ErrorSeverity.HIGH ||
      errorInfo.severity === ErrorSeverity.CRITICAL
    ) {
      return false;
    }

    try {
      switch (errorInfo.category) {
        case WalrusErrorCategory.NETWORK:
          if (context.retryOperation) {
            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds
            await context.retryOperation();
            return true;
          }
          break;

        case WalrusErrorCategory.AUTHENTICATION:
          if (context.refreshWallet) {
            await context.refreshWallet();
            return true;
          }
          break;

        default:
          return false;
      }
    } catch (recoveryError) {
      console.warn('Auto-recovery failed:', recoveryError);
      return false;
    }

    return false;
  }
}

/**
 * Error logging and analytics
 */
export class WalrusErrorLogger {
  private static logs: Array<{
    timestamp: number;
    error: UserErrorInfo;
    context?: any;
  }> = [];

  /**
   * Log an error occurrence
   */
  static logError(error: unknown, context?: any): void {
    const errorInfo = WalrusErrorAnalyzer.analyzeError(error);

    this.logs.push({
      timestamp: Date.now(),
      error: errorInfo,
      context,
    });

    // Console log for development
    if (process.env.NODE_ENV === 'development') {
      console.group(` Walrus Error: ${errorInfo.title}`);
      console.error('Message:', errorInfo.message);
      console.warn('Suggestion:', errorInfo.suggestion);
      console.log('Category:', errorInfo.category);
      console.log('Severity:', errorInfo.severity);
      if (errorInfo.technicalDetails) {
        console.log('Technical Details:', errorInfo.technicalDetails);
      }
      if (context) {
        console.log('Context:', context);
      }
      console.groupEnd();
    }

    // Here you could send to analytics service in production
    // this.sendToAnalytics(errorInfo, context);
  }

  /**
   * Get error statistics
   */
  static getErrorStats(): {
    totalErrors: number;
    errorsByCategory: Record<WalrusErrorCategory, number>;
    errorsBySeverity: Record<ErrorSeverity, number>;
    recentErrors: number;
  } {
    const now = Date.now();
    const oneHourAgo = now - 60 * 60 * 1000;

    const recentErrors = this.logs.filter(
      log => log.timestamp > oneHourAgo
    ).length;

    const errorsByCategory = Object.values(WalrusErrorCategory).reduce(
      (acc, category) => {
        acc[category] = this.logs.filter(
          log => log.error.category === category
        ).length;
        return acc;
      },
      {} as Record<WalrusErrorCategory, number>
    );

    const errorsBySeverity = Object.values(ErrorSeverity).reduce(
      (acc, severity) => {
        acc[severity] = this.logs.filter(
          log => log.error.severity === severity
        ).length;
        return acc;
      },
      {} as Record<ErrorSeverity, number>
    );

    return {
      totalErrors: this.logs.length,
      errorsByCategory,
      errorsBySeverity,
      recentErrors,
    };
  }

  /**
   * Clear error logs
   */
  static clearLogs(): void {
    this.logs = [];
  }
}

// Export utility function for easy error handling
export function handleWalrusError(
  error: unknown,
  context?: any
): UserErrorInfo {
  WalrusErrorLogger.logError(error, context);
  return WalrusErrorAnalyzer.analyzeError(error);
}

// Classes and types are already exported above
</file>

<file path="src/lib/walrus-todo-integration.ts">
/**
 * Walrus Protocol Integration for Todo Management
 *
 * This module provides the two-step process:
 * 1. Upload todo content to Walrus decentralized storage
 * 2. Create Sui NFT with blob reference for ownership and transferability
 */

import { Transaction as TransactionBlock } from '@mysten/sui/transactions';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import type { Signer } from '@mysten/sui/cryptography';
import {
  FrontendWalrusClient,
  WalrusTodoStorage,
  ContentEncoder,
  WalrusClientError,
  WalrusRetryError,
  WalrusValidationError,
  type WalrusUploadResult,
  type WalrusNetwork,
} from './walrus-client';
import {
  storeTodoOnBlockchain,
  type CreateTodoParams,
  type TransactionResult,
  getSuiClient,
} from './sui-client';

// Extended Todo interface with Walrus integration
export interface WalrusTodo {
  id: string;
  title: string;
  description?: string;
  completed: boolean;
  priority: 'low' | 'medium' | 'high';
  tags?: string[];
  dueDate?: string;

  // Storage information
  walrusBlobId?: string; // Walrus blob ID for content
  suiObjectId?: string; // Sui NFT object ID for ownership
  blockchainStored: boolean; // Whether stored on blockchain

  // Metadata
  createdAt: number;
  updatedAt: number;
  owner?: string;
  storageEpochs?: number;
  storageSize?: number;
  isPrivate?: boolean;
}

export interface TodoStorageMetadata {
  walrusBlobId: string;
  suiObjectId?: string;
  storageSize: number;
  storageEpochs: number;
  storageCost: {
    total: bigint;
    storage: bigint;
    write: bigint;
  };
  uploadTimestamp: number;
  expiresAt?: number;
}

export interface WalrusTodoUploadOptions {
  epochs?: number;
  deletable?: boolean;
  isPrivate?: boolean;
  createNFT?: boolean;
  onProgress?: (step: string, progress: number) => void;
}

export interface WalrusTodoCreateResult {
  todo: WalrusTodo;
  walrusResult: WalrusUploadResult;
  suiResult?: TransactionResult;
  metadata: TodoStorageMetadata;
}

/**
 * Comprehensive Walrus + Sui integration for Todo management
 */
export class WalrusTodoManager {
  private walrusStorage: WalrusTodoStorage;
  private walrusClient: FrontendWalrusClient;
  private network: WalrusNetwork;

  constructor(network: WalrusNetwork = 'testnet') {
    this.network = network;
    this.walrusStorage = new WalrusTodoStorage(network);
    this.walrusClient = this.walrusStorage.getClient();
  }

  /**
   * Create todo with Walrus storage and optional NFT creation
   */
  async createTodo(
    todo: Omit<
      WalrusTodo,
      'id' | 'createdAt' | 'updatedAt' | 'blockchainStored'
    >,
    signer: Signer | Ed25519Keypair,
    signAndExecuteTransaction?: (txb: TransactionBlock) => Promise<any>,
    options: WalrusTodoUploadOptions = {}
  ): Promise<WalrusTodoCreateResult> {
    const {
      epochs = 5,
      deletable = true,
      isPrivate = false,
      createNFT = true,
      onProgress,
    } = options;

    // Generate unique ID
    const todoId = `todo_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // Create complete todo object
    const completeTodo: WalrusTodo = {
      ...todo,
      id: todoId,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      blockchainStored: false,
      isPrivate,
      storageEpochs: epochs,
    };

    try {
      // Step 1: Upload to Walrus
      onProgress?.('Uploading to Walrus storage...', 25);

      const walrusResult = await this.walrusStorage.storeTodo(
        completeTodo,
        signer,
        {
          epochs,
          deletable,
          attributes: {
            type: 'todo',
            title: completeTodo.title,
            priority: completeTodo.priority,
            private: String(isPrivate),
            created: new Date().toISOString(),
          },
          // Transform progress callback to match WalrusUploadOptions interface
          onProgress: onProgress
            ? progress => onProgress('Uploading...', 25 + progress * 0.5)
            : undefined,
        }
      );

      // Update todo with Walrus information
      completeTodo.walrusBlobId = walrusResult.blobId;
      completeTodo.storageSize = walrusResult.metadata.size;
      completeTodo.blockchainStored = true;

      onProgress?.('Upload to Walrus complete', 75);

      // Step 2: Create NFT (optional)
      let suiResult: TransactionResult | undefined;

      if (createNFT && signAndExecuteTransaction) {
        onProgress?.('Creating NFT on Sui blockchain...', 85);

        try {
          // Create NFT with blob reference
          const nftParams: CreateTodoParams = {
            title: completeTodo.title,
            description: completeTodo.description || '',
            imageUrl: `walrus://${walrusResult.blobId}`, // Use Walrus blob as image reference
            metadata: JSON.stringify({
              walrusBlobId: walrusResult.blobId,
              priority: completeTodo.priority,
              tags: completeTodo.tags,
              dueDate: completeTodo.dueDate,
              storageEpochs: epochs,
              createdAt: completeTodo.createdAt,
            }),
            isPrivate,
          };

          // Get address from signer
          let walletAddress = '';
          if (
            'getAddress' in signer &&
            typeof signer.getAddress === 'function'
          ) {
            walletAddress = await signer.getAddress();
          } else if (
            'toSuiAddress' in signer &&
            typeof signer.toSuiAddress === 'function'
          ) {
            walletAddress = signer.toSuiAddress();
          }

          suiResult = await storeTodoOnBlockchain(
            nftParams,
            signAndExecuteTransaction,
            walletAddress
          );

          if (suiResult.success) {
            completeTodo.suiObjectId = suiResult.objectId;
            onProgress?.('NFT creation complete', 100);
          } else {
            console.warn('Failed to create NFT:', suiResult.error);
            onProgress?.(
              'NFT creation failed, but Walrus storage successful',
              90
            );
          }
        } catch (error) {
          console.warn('NFT creation failed:', error);
          onProgress?.(
            'NFT creation failed, but Walrus storage successful',
            90
          );
        }
      } else {
        onProgress?.('Storage complete', 100);
      }

      // Calculate storage metadata
      const costInfo = await this.walrusClient.calculateStorageCost(
        walrusResult.metadata.size,
        epochs
      );

      const metadata: TodoStorageMetadata = {
        walrusBlobId: walrusResult.blobId,
        suiObjectId: completeTodo.suiObjectId,
        storageSize: walrusResult.metadata.size,
        storageEpochs: epochs,
        storageCost: {
          total: costInfo.totalCost,
          storage: costInfo.storageCost,
          write: costInfo.writeCost,
        },
        uploadTimestamp: Date.now(),
        expiresAt: walrusResult.metadata.expiresAt,
      };

      return {
        todo: completeTodo,
        walrusResult,
        suiResult,
        metadata,
      };
    } catch (error) {
      if (error instanceof WalrusClientError) {
        throw error;
      }
      throw new WalrusClientError(
        `Failed to create todo: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'TODO_CREATE_ERROR',
        error instanceof Error ? error : undefined
      );
    }
  }

  /**
   * Retrieve todo from Walrus storage
   */
  async retrieveTodo(walrusBlobId: string): Promise<WalrusTodo> {
    try {
      const todoData = await this.walrusStorage.retrieveTodo(walrusBlobId);

      // Ensure the retrieved data is a valid todo
      if (!todoData || typeof todoData !== 'object') {
        throw new WalrusClientError('Invalid todo data retrieved from storage');
      }

      return {
        blockchainStored: true,
        ...todoData,
        walrusBlobId, // Ensure blob ID is set
      };
    } catch (error) {
      if (error instanceof WalrusClientError) {
        throw error;
      }
      throw new WalrusClientError(
        `Failed to retrieve todo: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'TODO_RETRIEVE_ERROR',
        error instanceof Error ? error : undefined
      );
    }
  }

  /**
   * Update todo in Walrus storage (creates new blob)
   */
  async updateTodo(
    todo: WalrusTodo,
    signer: Signer | Ed25519Keypair,
    options: Partial<WalrusTodoUploadOptions> = {}
  ): Promise<WalrusUploadResult> {
    const updatedTodo: WalrusTodo = {
      ...todo,
      updatedAt: Date.now(),
    };

    try {
      // Transform the onProgress callback to match WalrusUploadOptions interface
      const { onProgress, ...restOptions } = options;
      const transformedOptions = {
        ...restOptions,
        ...(onProgress && {
          onProgress: (progress: number) => onProgress('storing', progress),
        }),
      };

      return await this.walrusStorage.storeTodo(updatedTodo, signer, {
        epochs: todo.storageEpochs || 5,
        deletable: true,
        attributes: {
          type: 'todo-update',
          title: updatedTodo.title,
          priority: updatedTodo.priority,
          originalBlobId: todo.walrusBlobId || '',
          updated: new Date().toISOString(),
        },
        ...transformedOptions,
      });
    } catch (error) {
      if (error instanceof WalrusClientError) {
        throw error;
      }
      throw new WalrusClientError(
        `Failed to update todo: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'TODO_UPDATE_ERROR',
        error instanceof Error ? error : undefined
      );
    }
  }

  /**
   * Delete todo from Walrus (if deletable)
   */
  async deleteTodo(
    walrusBlobId: string,
    signer: Signer | Ed25519Keypair
  ): Promise<string> {
    try {
      return await this.walrusClient.deleteBlob(walrusBlobId, signer);
    } catch (error) {
      if (error instanceof WalrusClientError) {
        throw error;
      }
      throw new WalrusClientError(
        `Failed to delete todo: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'TODO_DELETE_ERROR',
        error instanceof Error ? error : undefined
      );
    }
  }

  /**
   * Get storage information for a todo
   */
  async getTodoStorageInfo(walrusBlobId: string): Promise<{
    exists: boolean;
    blobInfo?: any;
    storageCost?: { total: bigint; storage: bigint; write: bigint };
  }> {
    try {
      const exists = await this.walrusClient.blobExists(walrusBlobId);

      if (!exists) {
        return { exists: false };
      }

      const blobInfo = await this.walrusClient.getBlobInfo(walrusBlobId);

      // Estimate storage cost based on blob size
      let storageCost;
      try {
        const size = blobInfo.size || 1024; // Default size estimate
        const cost = await this.walrusClient.calculateStorageCost(size, 5);
        storageCost = {
          total: cost.totalCost,
          storage: cost.storageCost,
          write: cost.writeCost,
        };
      } catch (error) {
        console.warn('Failed to calculate storage cost:', error);
      }

      return {
        exists: true,
        blobInfo,
        storageCost,
      };
    } catch (error) {
      console.error('Error getting todo storage info:', error);
      return { exists: false };
    }
  }

  /**
   * Batch operations for multiple todos
   */
  async createMultipleTodos(
    todos: Array<
      Omit<WalrusTodo, 'id' | 'createdAt' | 'updatedAt' | 'blockchainStored'>
    >,
    signer: Signer | Ed25519Keypair,
    signAndExecuteTransaction?: (txb: TransactionBlock) => Promise<any>,
    options: WalrusTodoUploadOptions = {}
  ): Promise<WalrusTodoCreateResult[]> {
    const results: WalrusTodoCreateResult[] = [];
    const { onProgress } = options;

    for (let i = 0; i < todos.length; i++) {
      const todo = todos[i];
      onProgress?.(
        `Creating todo ${i + 1} of ${todos.length}`,
        (i / todos.length) * 100
      );

      try {
        const result = await this.createTodo(
          todo,
          signer,
          signAndExecuteTransaction,
          {
            ...options,
            onProgress: undefined, // Avoid nested progress callbacks
          }
        );
        results.push(result);
      } catch (error) {
        console.error(`Failed to create todo ${i + 1}:`, error);
        // Continue with other todos even if one fails
      }
    }

    onProgress?.('Batch creation complete', 100);
    return results;
  }

  /**
   * Check storage costs before operations
   */
  async estimateStorageCosts(
    todos: Array<
      Omit<WalrusTodo, 'id' | 'createdAt' | 'updatedAt' | 'blockchainStored'>
    >,
    epochs: number = 5
  ): Promise<{
    totalCost: bigint;
    totalSize: number;
    perTodoCost: Array<{ totalCost: bigint; size: number }>;
  }> {
    let totalCost = BigInt(0);
    let totalSize = 0;
    const perTodoCost: Array<{ totalCost: bigint; size: number }> = [];

    for (const todo of todos) {
      const estimate = await this.walrusStorage.estimateTodoStorageCost(
        todo,
        epochs
      );
      totalCost += estimate.totalCost;
      totalSize += estimate.sizeBytes;
      perTodoCost.push({
        totalCost: estimate.totalCost,
        size: estimate.sizeBytes,
      });
    }

    return {
      totalCost,
      totalSize,
      perTodoCost,
    };
  }

  /**
   * Get current WAL balance
   */
  async getWalBalance(): Promise<string> {
    return this.walrusClient.getWalBalance();
  }

  /**
   * Get storage usage information
   */
  async getStorageUsage(): Promise<{ used: string; total: string }> {
    return this.walrusClient.getStorageUsage();
  }
}

// Export singleton instance for convenience
export const walrusTodoManager = new WalrusTodoManager();

// Export utility functions
export { ContentEncoder };

// Export error classes
export { WalrusClientError, WalrusRetryError, WalrusValidationError };

// Export types from walrus-client that are not already exported
export type { WalrusNetwork };
</file>

<file path="src/styles/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 203, 240, 248; /* ocean-foam */
  --background-end-rgb: 144, 224, 239; /* ocean-light */
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 51, 102; /* ocean-deep */
    --background-end-rgb: 0, 119, 182; /* ocean-medium */
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
  min-height: 100vh;
}

@layer components {
  .ocean-card {
    @apply bg-white/30 dark:bg-ocean-deep/40 backdrop-blur-md rounded-xl p-6 shadow-dreamy border border-ocean-foam/50 dark:border-ocean-light/20;
  }
  
  .wave-animation {
    @apply relative overflow-hidden before:absolute before:inset-0 before:bg-ocean-wave before:bg-repeat-x before:bg-bottom before:opacity-10 before:dark:opacity-5;
  }
  
  .ocean-button {
    @apply bg-ocean-medium hover:bg-ocean-deep text-white font-semibold py-2 px-4 rounded-lg shadow-dreamy transition-all duration-300 ease-in-out transform hover:-translate-y-1 hover:shadow-underwater;
  }
  
  .ocean-input {
    @apply bg-white/50 dark:bg-ocean-deep/30 border border-ocean-light/50 dark:border-ocean-light/20 rounded-lg px-4 py-2 shadow-inner outline-none focus:ring-2 focus:ring-dream-teal transition-all duration-300;
  }
  
  .floating-element {
    @apply animate-float transition-all duration-300;
  }
}
</file>

<file path="src/types/blockchain-events.ts">
/**
 * TypeScript type definitions for blockchain events
 * Comprehensive types for TodoNFT event handling
 */

// Core event data types from smart contract
export interface TodoNFTCreatedEventData {
  todo_id: string;
  title: string;
  owner: string;
  timestamp: string;
}

export interface TodoNFTCompletedEventData {
  todo_id: string;
  timestamp: string;
}

export interface TodoNFTUpdatedEventData {
  todo_id: string;
  title?: string;
  description?: string;
  timestamp: string;
}

export interface TodoNFTDeletedEventData {
  todo_id: string;
  timestamp: string;
}

export interface TodoNFTTransferredEventData {
  todo_id: string;
  from: string;
  to: string;
  timestamp: string;
}

// Union type for all event data
export type TodoNFTEventData =
  | TodoNFTCreatedEventData
  | TodoNFTCompletedEventData
  | TodoNFTUpdatedEventData
  | TodoNFTDeletedEventData
  | TodoNFTTransferredEventData;

// Typed event objects
export interface TodoNFTCreatedEvent {
  type: 'created';
  data: TodoNFTCreatedEventData;
  rawEvent: unknown; // Original SuiEvent
}

export interface TodoNFTCompletedEvent {
  type: 'completed';
  data: TodoNFTCompletedEventData;
  rawEvent: unknown;
}

export interface TodoNFTUpdatedEvent {
  type: 'updated';
  data: TodoNFTUpdatedEventData;
  rawEvent: unknown;
}

export interface TodoNFTDeletedEvent {
  type: 'deleted';
  data: TodoNFTDeletedEventData;
  rawEvent: unknown;
}

export interface TodoNFTTransferredEvent {
  type: 'transferred';
  data: TodoNFTTransferredEventData;
  rawEvent: unknown;
}

// Union type for all events
export type TodoNFTEvent =
  | TodoNFTCreatedEvent
  | TodoNFTCompletedEvent
  | TodoNFTUpdatedEvent
  | TodoNFTDeletedEvent
  | TodoNFTTransferredEvent;

// Event listener types
export type TodoNFTEventListener<T = TodoNFTEvent> = (event: T) => void;
export type TodoNFTEventListenerMap = {
  created: TodoNFTEventListener<TodoNFTCreatedEvent>;
  completed: TodoNFTEventListener<TodoNFTCompletedEvent>;
  updated: TodoNFTEventListener<TodoNFTUpdatedEvent>;
  deleted: TodoNFTEventListener<TodoNFTDeletedEvent>;
  transferred: TodoNFTEventListener<TodoNFTTransferredEvent>;
  '*': TodoNFTEventListener<TodoNFTEvent>;
};

// Connection state types
export interface EventConnectionState {
  connected: boolean;
  connecting: boolean;
  error: Error | null;
  lastReconnectAttempt: number;
  reconnectAttempts: number;
  subscriptionCount: number;
}

// Event subscription configuration
export interface EventSubscriptionConfig {
  packageId?: string;
  eventTypes?: TodoNFTEventType[];
  maxReconnectAttempts?: number;
  reconnectDelay?: number;
  autoReconnect?: boolean;
  owner?: string;
}

// Event type enumeration
export type TodoNFTEventType =
  | 'TodoNFTCreated'
  | 'TodoNFTCompleted'
  | 'TodoNFTUpdated'
  | 'TodoNFTDeleted'
  | 'TodoNFTTransferred';

// Event filter options
export interface EventFilterOptions {
  eventType?: TodoNFTEventType | TodoNFTEventType[];
  owner?: string;
  todoId?: string;
  fromDate?: Date;
  toDate?: Date;
}

// React hook return types
export interface UseBlockchainEventsReturn {
  connectionState: EventConnectionState;
  startSubscription: () => Promise<void>;
  stopSubscription: () => void;
  restartSubscription: () => Promise<void>;
  addEventListener: (
    eventType: keyof TodoNFTEventListenerMap,
    listener: TodoNFTEventListener
  ) => () => void;
  isConnected: boolean;
  isConnecting: boolean;
  error: Error | null;
}

export interface UseTodoEventsReturn extends UseBlockchainEventsReturn {
  recentEvents: TodoNFTEvent[];
  clearRecentEvents: () => void;
}

export interface UseTodoStateSyncReturn extends UseBlockchainEventsReturn {
  syncedTodos: Todo[];
}

// Notification types
export interface TodoEventNotification {
  id: string;
  message: string;
  type: TodoNFTEvent['type'];
  timestamp: number;
  todoId?: string;
  autoRemove?: boolean;
}

// Component prop types
export interface BlockchainEventStatusProps {
  className?: string;
  showReconnectButton?: boolean;
  showDetails?: boolean;
  compact?: boolean;
}

export interface RealtimeTodoListProps {
  initialTodos: Todo[];
  listName: string;
  onTodoUpdate?: (todos: Todo[]) => void;
  onTodoComplete?: (todo: Todo) => void;
  onTodoDelete?: (todoId: string) => void;
  className?: string;
  showEventIndicator?: boolean;
  owner?: string;
}

// Event manager interface
export interface IBlockchainEventManager {
  initialize(): Promise<void>;
  subscribeToEvents(owner?: string): Promise<void>;
  unsubscribeAll(): void;
  addEventListener(
    eventType: keyof TodoNFTEventListenerMap,
    listener: TodoNFTEventListener
  ): () => void;
  removeEventListener(
    eventType: keyof TodoNFTEventListenerMap,
    listener: TodoNFTEventListener
  ): void;
  getConnectionState(): EventConnectionState;
  destroy(): void;
}

// Utility types for event processing
export interface EventProcessingResult<T = any> {
  success: boolean;
  data?: T;
  error?: Error;
}

export interface EventTransformOptions {
  includeRawEvent?: boolean;
  transformTimestamp?: boolean;
  validateData?: boolean;
}

// Import Todo type from existing file
import type { Todo } from '@/lib/sui-client';

// Re-export for convenience
export type { Todo };
</file>

<file path="src/types/todo.ts">
/**
 * Todo types for frontend
 */

export type StorageLocation = 'local' | 'blockchain' | 'both';

export interface Todo {
  /** Unique identifier for the todo */
  id: string;
  /** Title of the todo item */
  title: string;
  /** Detailed description of the todo item */
  description?: string;
  /** Whether the todo is completed */
  completed: boolean;
  /** Priority level of the todo */
  priority: 'high' | 'medium' | 'low';
  /** Due date of the todo in YYYY-MM-DD format */
  dueDate?: string;
  /** Tags associated with the todo for categorization and filtering */
  tags: string[];
  /** Creation timestamp (ISO string) */
  createdAt: string;
  /** Last update timestamp (ISO string) */
  updatedAt: string;
  /** Completion timestamp (ISO string), only set when completed is true */
  completedAt?: string;
  /** Whether the todo is private (stored only locally) */
  private: boolean;
  /** Where the todo is stored (local, blockchain, or both) */
  storageLocation?: StorageLocation;
  /** Walrus blob ID for decentralized storage */
  walrusBlobId?: string;
  /** Sui NFT object ID referencing this todo */
  nftObjectId?: string;
  /** URL to the todo image stored on Walrus */
  imageUrl?: string;
  /** Category of the todo item */
  category?: string;
  /** Name of the list the todo belongs to */
  listName?: string;
  /** Sync timestamp for API server integration */
  syncedAt?: string;
}

export interface TodoList {
  /** Unique identifier for the todo list */
  id: string;
  /** Name of the todo list */
  name: string;
  /** Owner's identifier (typically blockchain address) */
  owner: string;
  /** Array of todo items in the list */
  todos: Todo[];
  /** Version number for the list, increments with changes */
  version: number;
  /** List of users who can access this list (blockchain addresses) */
  collaborators?: string[];
  /** Creation timestamp (ISO string) */
  createdAt: string;
  /** Last update timestamp (ISO string) */
  updatedAt: string;
  /** Walrus blob ID for decentralized storage of the list */
  walrusBlobId?: string;
  /** Sui object ID for this list on the Sui blockchain */
  suiObjectId?: string;
}
</file>

<file path="src/types/wallet.ts">
/**
 * Wallet type definitions for the WalTodo application
 */

// Define supported wallet types
export type WalletType = 'sui' | 'phantom' | 'slush' | 'backpack' | null;

// Define network types
export type NetworkType = 'mainnet' | 'testnet' | 'devnet' | 'localnet';

// Re-export from existing context to maintain compatibility
export type { WalletContextValue } from '@/contexts/WalletContext';

// Slush wallet account interface (based on StashedWalletAdapter)
export interface SlushAccount {
  address: string;
  publicKey: Uint8Array;
  chains: string[];
  features: string[];
}

// Backpack wallet account interface (via Solana Wallet Standard)
export interface BackpackAccount {
  address: string;
  publicKey: Uint8Array | string;
  chains: string[];
  features?: string[];
  network?: NetworkType;
}

// Extended Backpack wallet capabilities interface
export interface BackpackWalletCapabilities {
  supportedChains: string[];
  supportedFeatures: string[];
  multiChain: boolean;
  isBackpack: boolean;
}

// Generic transaction result interface
export interface TransactionResult {
  digest?: string;
  signature?: string | Uint8Array;
  status?: 'success' | 'failure';
  error?: string;
  timestamp?: number;
  blockHeight?: number;
}

// Network configuration interface
export interface NetworkConfig {
  name: NetworkType;
  endpoint: string;
  chainId?: string;
  displayName: string;
  explorer: string;
  explorerTemplate: string; // URL template for explorer links with {address} and {tx} placeholders
  active?: boolean;
}

// Common wallet feature flags
export interface WalletFeatures {
  supportsNetworkSwitching: boolean;
  supportsSignMessage: boolean;
  supportsTransactionSigning: boolean;
  supportsMultipleChains: boolean;
  supportsDappInteraction: boolean;
}
</file>

<file path="src/types/window.d.ts">
interface Window {
  // Sui wallets
  suiWallet?: {
    connect: () => Promise<{ publicKey: string | Uint8Array }>;
    disconnect: () => Promise<void>;
    signAndExecuteTransaction: (transaction: unknown) => Promise<{ digest: string; effects?: unknown }>;
    executeMoveCall: (transaction: unknown) => Promise<{ digest: string; effects?: unknown }>;
    signTransaction: (transaction: unknown) => Promise<{ signature: Uint8Array; transactionBlockBytes: Uint8Array }>;
    signMessage: (message: Uint8Array) => Promise<{ signature: Uint8Array }>;
    getAccounts: () => Promise<string[]>;
    [key: string]: unknown;
  };
  ethereum?: {
    isSuiWallet?: boolean;
    [key: string]: unknown;
  };
  martian?: {
    sui?: {
      connect: () => Promise<{ publicKey: string | Uint8Array }>;
      disconnect: () => Promise<void>;
      signAndExecuteTransaction: (transaction: unknown) => Promise<{ digest: string; effects?: unknown }>;
      getAccounts: () => Promise<string[]>;
      [key: string]: unknown;
    };
    [key: string]: unknown;
  };
  suiet?: {
    connect: () => Promise<{ publicKey: string | Uint8Array }>;
    disconnect: () => Promise<void>;
    signAndExecuteTransaction: (transaction: unknown) => Promise<{ digest: string; effects?: unknown }>;
    getAccounts: () => Promise<string[]>;
    [key: string]: unknown;
  };

  // Solana wallets
  phantom?: {
    solana?: {
      isPhantom: boolean;
      connect: (options?: {
        onlyIfTrusted?: boolean;
      }) => Promise<{ publicKey: string | Uint8Array }>;
      disconnect: () => Promise<void>;
      signTransaction: (transaction: unknown) => Promise<{ signature: Uint8Array; transactionBytes: Uint8Array }>;
      signAllTransactions: (transactions: unknown[]) => Promise<{ signature: Uint8Array; transactionBytes: Uint8Array }[]>;
      signMessage: (
        message: Uint8Array,
        encoding?: string
      ) => Promise<{ signature: Uint8Array }>;
      on: (event: string, callback: (...args: unknown[]) => void) => void;
      off: (event: string, callback: (...args: unknown[]) => void) => void;
      [key: string]: unknown;
    };
    [key: string]: unknown;
  };
  solana?: {
    isPhantom?: boolean;
    isSolflare?: boolean;
    isBackpack?: boolean;
    connect: (options?: {
      onlyIfTrusted?: boolean;
    }) => Promise<{ publicKey: string | Uint8Array }>;
    disconnect: () => Promise<void>;
    signTransaction: (transaction: unknown) => Promise<{ signature: Uint8Array; transactionBytes: Uint8Array }>;
    signAllTransactions: (transactions: unknown[]) => Promise<{ signature: Uint8Array; transactionBytes: Uint8Array }[]>;
    signMessage: (
      message: Uint8Array,
      encoding?: string
    ) => Promise<{ signature: Uint8Array }>;
    on: (event: string, callback: (...args: unknown[]) => void) => void;
    off: (event: string, callback: (...args: unknown[]) => void) => void;
    request: (request: { method: string; params?: unknown }) => Promise<unknown>;
    [key: string]: unknown;
  };

  // Backpack wallet - multiple possible interfaces
  xnft?: {
    solana?: {
      publicKey: string;
      isBackpack: boolean;
      connect: (options?: {
        onlyIfTrusted?: boolean;
      }) => Promise<{ publicKey: string | Uint8Array }>;
      disconnect: () => Promise<void>;
      signTransaction: (transaction: unknown) => Promise<{ signature: Uint8Array; transactionBytes: Uint8Array }>;
      signAllTransactions: (transactions: unknown[]) => Promise<{ signature: Uint8Array; transactionBytes: Uint8Array }[]>;
      signMessage: (
        message: Uint8Array,
        encoding?: string
      ) => Promise<{ signature: Uint8Array }>;
      on: (event: string, callback: (...args: unknown[]) => void) => void;
      off: (event: string, callback: (...args: unknown[]) => void) => void;
      [key: string]: unknown;
    };
    ethereum?: {
      publicKey: string;
      signTransaction: (transaction: unknown) => Promise<{ signature: Uint8Array; transactionBytes: Uint8Array }>;
      [key: string]: unknown;
    };
    sui?: {
      publicKey: string;
      connect: () => Promise<{ publicKey: string | Uint8Array }>;
      disconnect: () => Promise<void>;
      getAccounts: () => Promise<string[]>;
      [key: string]: unknown;
    };
    request: (request: { method: string; params?: unknown }) => Promise<unknown>;
    [key: string]: unknown;
  };

  // Alternative Backpack interface
  backpack?: {
    connect: (options?: {
      onlyIfTrusted?: boolean;
    }) => Promise<{ publicKey: string | Uint8Array }>;
    disconnect: () => Promise<void>;
    signTransaction: (transaction: unknown) => Promise<{ signature: Uint8Array; transactionBytes: Uint8Array }>;
    signAllTransactions: (transactions: unknown[]) => Promise<{ signature: Uint8Array; transactionBytes: Uint8Array }[]>;
    signMessage: (
      message: Uint8Array,
      encoding?: string
    ) => Promise<{ signature: Uint8Array }>;
    on: (event: string, callback: (...args: unknown[]) => void) => void;
    off: (event: string, callback: (...args: unknown[]) => void) => void;
    request: (request: { method: string; params?: unknown }) => Promise<unknown>;
    isBackpack: boolean;
    publicKey?: string | Uint8Array;
    [key: string]: unknown;
  };
}
</file>

<file path=".eslintrc.js">
module.exports = {
  root: true,
  extends: ['next', 'next/core-web-vitals'],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2022,
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true,
    },
  },
  rules: {
    'react/no-unescaped-entities': 'off',
    '@next/next/no-page-custom-font': 'off',
  },
  settings: {
    next: {
      rootDir: __dirname,
    },
    react: {
      version: 'detect',
    },
  },
};
</file>

<file path=".gitignore">
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path=".npmrc">
# Frontend-specific configuration
registry=https://registry.npmjs.org/
strict-peer-dependencies=false
auto-install-peers=true
</file>

<file path=".prettierrc.json">
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "endOfLine": "lf",
  "jsxSingleQuote": true,
  "overrides": [
    {
      "files": "*.{ts,tsx}",
      "options": {
        "parser": "typescript"
      }
    },
    {
      "files": "*.{js,jsx}",
      "options": {
        "parser": "babel"
      }
    },
    {
      "files": "*.json",
      "options": {
        "printWidth": 120
      }
    }
  ]
}
</file>

<file path="enable-simple-wallet.sh">
#!/bin/bash

# Script to enable simplified wallet context for development

echo " Switching to simplified wallet implementation..."

# Make sure we have the file
if [ ! -f src/contexts/SimpleWalletContext.tsx ]; then
  echo " SimpleWalletContext.tsx not found. Aborting."
  exit 1
fi

# Add import statement to layout.tsx
echo " Updating app layout..."
sed -i '' 's/import { AppWalletProvider } from ".*"/import { SimpleWalletProvider } from "@\/contexts\/SimpleWalletContext"/' src/app/layout.tsx
sed -i '' 's/<AppWalletProvider>/<SimpleWalletProvider>/' src/app/layout.tsx
sed -i '' 's/<\/AppWalletProvider>/<\/SimpleWalletProvider>/' src/app/layout.tsx

# Update import in WalletConnectButton
echo " Updating WalletConnectButton..."
sed -i '' 's/import { useWalletContext } from ".*"/import { useWalletContext } from "@\/contexts\/SimpleWalletContext"/' src/components/WalletConnectButton.tsx

echo " Switched to simplified wallet implementation."
echo " Please restart your development server now with:"
echo "   npm run dev:clean"
</file>

<file path="fix-all.sh">
#!/bin/bash

# All-in-one fix script for Next.js development issues

echo " Running complete fix for Next.js application..."

# Make script executable
chmod +x "$(dirname "$0")/fix-all.sh"
chmod +x "$(dirname "$0")/reset-next.sh"
chmod +x "$(dirname "$0")/enable-simple-wallet.sh"

# 1. Stop any running Next.js processes
echo " Stopping any running Next.js processes..."
pkill -f "node.*next" || true

# 2. Clean caches and artifacts
echo " Cleaning all caches and artifacts..."
rm -rf .next
rm -rf node_modules/.cache
rm -rf .next.lock

# 3. Install required dependencies
echo " Installing required dependencies..."
npm install --save-dev style-loader
npm install --save-dev mini-css-extract-plugin@latest

# 4. Create ultrasimple config for Next.js
echo " Creating ultrasimple Next.js config..."
cat > .simple-next.config.js << 'EOF'
/** @type {import('next').NextConfig} */
module.exports = {
  output: undefined,
  reactStrictMode: false,
  swcMinify: false,
  images: {
    domains: ['localhost', '192.168.8.204'],
  },
  experimental: {}
};
EOF

# 5. Switch to simple wallet implementation
echo " Switching to simple wallet implementation..."
./enable-simple-wallet.sh

# 6. Set optimal environment variables
echo " Setting optimal environment variables..."
export NODE_ENV=development
export NEXT_TELEMETRY_DISABLED=1
export NEXT_RUNTIME=nodejs
export NEXT_CONFIG_FILE=.simple-next.config.js
export NEXT_TURBO=0
export NODE_OPTIONS="--max-old-space-size=8192 --no-warnings"
export PORT=3002

# 7. Start the development server
echo " Starting Next.js development server..."
npx next dev --port 3002

echo " Server should be running now!"
</file>

<file path="fix-dev-server.sh">
#!/bin/bash

# Script to fix Next.js development server issues
# Cleans caches and restarts the server properly

echo " Cleaning Next.js cache and fixing development server..."

# Make script executable
chmod +x "$(dirname "$0")/fix-dev-server.sh"

# Stop any running Next.js processes
echo " Stopping any running Next.js processes..."
pkill -f "node.*next" || true

# Clean Next.js cache
echo "  Removing .next directory..."
rm -rf .next
rm -rf node_modules/.cache
rm -rf .next.lock

# Handle node_modules problems
echo " Checking node_modules structure..."
if [ -f "node_modules/.pnpm/style-loader" ]; then
  echo "  Installing style-loader for CSS MIME type fix..."
  npm install --save-dev style-loader
fi

# Save current Next.js config
echo " Backing up next.config.js..."
if [ -f "next.config.js" ]; then
  cp next.config.js next.config.js.bak
fi

# Check for port conflicts
PORT=3002
if lsof -Pi :$PORT -sTCP:LISTEN -t >/dev/null ; then
    echo "  Port $PORT is already in use. Killing process..."
    lsof -Pi :$PORT -sTCP:LISTEN -t | xargs kill -9 || true
fi

# Retry with alternate port if needed
if lsof -Pi :$PORT -sTCP:LISTEN -t >/dev/null ; then
    PORT=3003
    echo "  Using alternate port $PORT instead..."
fi

# Make sure node_modules are up to date
echo " Checking for missing dependencies..."
if [ ! -d "node_modules" ] || [ ! -f "node_modules/.pnpm/lock.yaml" ]; then
    echo " Installing dependencies..."
    npm install
fi

# Fix output configuration in dev mode
echo "  Setting development-specific environment variables..."
export NODE_ENV="development"
export NEXT_DISABLE_SOURCEMAPS=1
export NEXT_TELEMETRY_DISABLED=1

# Increase Node memory allowance
echo " Setting increased memory limits..."
export NODE_OPTIONS="--max-old-space-size=8192 --no-warnings"

# Use development mode with turbo disabled
echo " Starting Next.js dev server in clean mode on port $PORT..."
PORT=$PORT NODE_ENV=development NEXT_TURBO=0 npx next dev --no-lint --port $PORT

echo " Server started successfully!"
</file>

<file path="INSTALLATION.md">
# Frontend-v2 Installation Guide

This document explains how to install and work with the Next.js frontend for the Walrus Todo application.

## Prerequisites

- Node.js LTS (18.x) 
- pnpm (8.x)

## Installation Steps

### 1. Clean Install

If you're setting up the frontend for the first time or experiencing installation issues:

```bash
# Clean up existing node_modules
cd packages/frontend-v2
rm -rf node_modules

# Clean pnpm store (optional)
pnpm store prune

# Install dependencies
pnpm install
```

### 2. Working with Workspace

This frontend is part of a pnpm workspace. If the root project has TypeScript errors during installation, you can still work with the frontend independently:

```bash
# Install only frontend dependencies
cd packages/frontend-v2
pnpm install --ignore-scripts

# Or if the workspace install fails, use CI mode
CI=true pnpm install
```

## Development

Start the development server:

```bash
pnpm dev
```

The server runs on http://localhost:3000 by default. If that port is in use, it will automatically use port 3001.

## Building

Create a production build:

```bash
pnpm build
```

## Linting

Run ESLint:

```bash
pnpm lint

# Fix lint issues automatically
pnpm lint:fix
```

## Troubleshooting

### Port Conflicts

If you see "Port 3000 is in use", the dev server will automatically use port 3001.

### TypeScript Errors in Root Project

The root project's TypeScript errors during `pnpm install` won't prevent the frontend from working. The frontend has its own TypeScript configuration and can be built independently.

### Network Issues During Install

If you experience timeouts during package installation:

1. Try using a different network
2. Use CI mode to disable prompts: `CI=true pnpm install`
3. Install packages one by one: `pnpm add <package-name>`

## Environment Configuration

The project includes `.npmrc` files for proper workspace configuration:

- Root `.npmrc`: Configures workspace-wide settings like `shamefully-hoist=true`
- Frontend `.npmrc`: Ensures proper package resolution

## CI/CD Integration

For CI pipelines, use:

```bash
# Install dependencies
CI=true pnpm install --filter @walrus-todo/frontend

# Build
pnpm --filter @walrus-todo/frontend build

# Lint
pnpm --filter @walrus-todo/frontend lint
```

## Additional Resources

- See the main [README.md](./README.md) for feature documentation
- Check [WALLET_INTEGRATION.md](./WALLET_INTEGRATION.md) for wallet setup
- Use [Next.js documentation](https://nextjs.org/docs) for framework-specific questions
</file>

<file path="jest.setup.js">
// Import Jest DOM extensions
import '@testing-library/jest-dom';

// Mock Next.js router
jest.mock('next/router', () => ({
  useRouter: () => ({
    pathname: '/',
    push: jest.fn(),
    replace: jest.fn(),
    prefetch: jest.fn(),
    back: jest.fn(),
  }),
}));

// Mock Next.js image component
jest.mock('next/image', () => ({
  __esModule: true,
  default: props => {
    // eslint-disable-next-line @next/next/no-img-element
    return <img {...props} alt={props.alt || ''} />;
  },
}));

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(), // Deprecated
    removeListener: jest.fn(), // Deprecated
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
});

// Mock IntersectionObserver
class MockIntersectionObserver {
  constructor(callback) {
    this.callback = callback;
    this.observe = jest.fn();
    this.unobserve = jest.fn();
    this.disconnect = jest.fn();
  }
}

Object.defineProperty(window, 'IntersectionObserver', {
  writable: true,
  value: MockIntersectionObserver,
});

// Suppress console errors during tests
const originalError = console.error;
console.error = (...args) => {
  // Suppress specific Next.js errors that occur in tests
  const errorStr = String(args[0]);
  if (
    errorStr.includes('Warning: ReactDOM.render is no longer supported') ||
    errorStr.includes('Warning: useLayoutEffect does nothing on the server') ||
    errorStr.includes(
      'Error: Uncaught [Error: Expected server HTML to contain a matching'
    )
  ) {
    return;
  }
  originalError(...args);
};

// Mock ResizeObserver
class MockResizeObserver {
  constructor(callback) {
    this.callback = callback;
    this.observe = jest.fn();
    this.unobserve = jest.fn();
    this.disconnect = jest.fn();
  }
}

Object.defineProperty(window, 'ResizeObserver', {
  writable: true,
  value: MockResizeObserver,
});
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  images: {
    domains: ['localhost', '192.168.8.204'],
    remotePatterns: [
      {
        protocol: 'http',
        hostname: 'localhost',
        port: process.env.PORT || '3000',
      },
      {
        protocol: 'http',
        hostname: '192.168.8.204',
        port: process.env.PORT || '3000',
      },
    ],
  },
  // Disable standalone output to fix MIME type issues with static assets
  // output: process.env.NODE_ENV === 'production' ? 'standalone' : undefined,

  // Increase timeout for static generation
  staticPageGenerationTimeout: 180,

  webpack: (config, { isServer, dev, webpack }) => {
    // Fix for node-fetch encoding issue
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        fs: false,
        net: false,
        tls: false,
        encoding: false,
      };
    }

    // Suppress wallet extension console errors during development
    if (dev && !isServer) {
      config.plugins.push(
        new webpack.DefinePlugin({
          __SUPPRESS_WALLET_ERRORS__: JSON.stringify(true),
        })
      );
    }

    return config;
  },

  // Configure runtime to handle client-side operations correctly
  experimental: {
    // Configure server actions
    serverActions: {
      bodySizeLimit: '2mb',
    },
  },

  // Allow development origins (dynamic port support)
  allowedDevOrigins: (function () {
    const port = process.env.PORT || '3000';
    return [`192.168.8.204:${port}`, `localhost:${port}`];
  })(),

  // Define custom headers to help with caching and security
  async headers() {
    return [
      {
        // Apply to all routes except static assets
        source: '/((?!_next/static|favicon.ico).*)',
        headers: [
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'X-Frame-Options',
            value: 'SAMEORIGIN',
          },
        ],
      },
      {
        // Proper caching for static assets
        source: '/_next/static/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ];
  },

  // Fix for development server restarts
  onDemandEntries: {
    // Keep pages in memory for longer
    maxInactiveAge: 60 * 60 * 1000, // 1 hour
    pagesBufferLength: 5,
  },
};

module.exports = nextConfig;
</file>

<file path="package.json">
{
  "name": "@walrus-todo/frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "pnpm run setup-config && node scripts/start-with-available-port.js dev",
    "dev:simple": "pnpm run setup-config && next dev",
    "build": "pnpm run setup-config && next build",
    "start": "node scripts/start-with-available-port.js start",
    "start:fixed-port": "next start",
    "dev:fixed-port": "pnpm run setup-config && next dev",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "fix-dev": "sh ./fix-dev-server.sh",
    "clean": "rm -rf .next node_modules/.cache",
    "dev:clean": "pnpm run clean && node scripts/start-with-available-port.js dev",
    "setup-config": "node setup-config.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "dependencies": {
    "@heroicons/react": "^2.0.18",
    "@mysten/dapp-kit": "^0.16.3",
    "@mysten/sui": "^1.30.1",
    "@mysten/walrus": "^0.1.1",
    "@solana/wallet-adapter-base": "^0.9.26",
    "@solana/wallet-adapter-phantom": "^0.9.0",
    "@solana/wallet-adapter-react": "^0.15.0",
    "@solana/wallet-adapter-solflare": "^0.6.31",
    "@solana/wallet-adapter-wallets": "^0.19.36",
    "@solana/wallet-standard-features": "^1.3.0",
    "@solana/web3.js": "^1.95.0",
    "@suiet/wallet-kit": "^0.4.1",
    "@tanstack/react-query": "^5.76.1",
    "@wallet-standard/features": "^1.1.0",
    "encoding": "^0.1.13",
    "nanoid": "^5.1.5",
    "next": "^15.3.2",
    "react": "18.3.1",
    "react-dom": "18.3.1"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/preset-env": "^7.27.2",
    "@babel/preset-react": "^7.27.1",
    "@babel/preset-typescript": "^7.27.1",
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^14.2.1",
    "@types/jest": "^29.5.12",
    "@types/node": "22.0.0",
    "@types/react": "18.3.1",
    "@types/react-dom": "18.3.1",
    "autoprefixer": "10.4.20",
    "eslint": "^9.0.0",
    "eslint-config-next": "15.3.2",
    "get-port": "^7.1.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "pino-pretty": "^13.0.0",
    "postcss": "8.4.30",
    "sinon": "^19.0.0",
    "style-loader": "^4.0.0",
    "tailwindcss": "3.4.0",
    "typescript": "5.8.3"
  },
  "jest": {
    "testEnvironment": "jsdom",
    "moduleNameMapper": {
      "^@/(.*)$": "<rootDir>/src/$1"
    },
    "setupFilesAfterEnv": [
      "<rootDir>/jest.setup.js"
    ],
    "testPathIgnorePatterns": [
      "<rootDir>/node_modules/",
      "<rootDir>/.next/"
    ],
    "transform": {
      "^.+\\.(js|jsx|ts|tsx)$": [
        "babel-jest",
        {
          "presets": [
            "next/babel"
          ]
        }
      ]
    },
    "modulePaths": [
      "<rootDir>"
    ]
  }
}
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="README-BLOCKCHAIN-EVENTS.md">
# Sui Blockchain Real-time Event System

This implementation provides real-time blockchain event subscriptions for TodoNFT smart contracts using the Sui blockchain. The system enables automatic frontend updates when blockchain events occur, creating a seamless Web3 user experience.

##  Architecture Overview

The system consists of four main layers:

1. **Event Manager** - Core blockchain event subscription and connection management
2. **React Hooks** - React integration with automatic state management
3. **UI Components** - Visual indicators and real-time updates
4. **Integration Layer** - Seamless integration with existing components

##  File Structure

```
src/
 lib/
    blockchain-events.ts      # Core event manager and utilities
 hooks/
    useBlockchainEvents.ts    # React hooks for event subscriptions
    useInactivityTimer.ts     # Inactivity timer for wallet sessions
 components/
    BlockchainEventStatus.tsx # Event connection status components
    RealtimeTodoList.tsx      # Enhanced todo list with real-time updates
    todo-list.tsx             # Updated existing todo list component
 types/
    blockchain-events.ts      # TypeScript definitions
 examples/
    blockchain-events-usage.tsx # Usage examples and demos
 __tests__/
     hooks/
         useBlockchainEvents.test.tsx # Comprehensive tests
```

##  Quick Start

### 1. Basic Event Subscription

```typescript
import { useBlockchainEvents } from '@/hooks/useBlockchainEvents';

function MyComponent() {
  const { isConnected, startSubscription, stopSubscription } = useBlockchainEvents({
    autoStart: true,
    owner: walletAddress,
    enableReconnect: true,
  });

  return (
    <div>
      Status: {isConnected ? 'Connected' : 'Disconnected'}
    </div>
  );
}
```

### 2. Handle Todo Events

```typescript
import { useTodoEvents } from '@/hooks/useBlockchainEvents';

function TodoEventHandler() {
  const { recentEvents } = useTodoEvents({
    autoStart: true,
    onTodoCreated: (todo) => console.log('New todo:', todo),
    onTodoCompleted: (todo) => console.log('Todo completed:', todo),
    onTodoUpdated: (todo) => console.log('Todo updated:', todo),
    onTodoDeleted: (todoId) => console.log('Todo deleted:', todoId),
  });

  return <div>Recent events: {recentEvents.length}</div>;
}
```

### 3. Automatic State Synchronization

```typescript
import { useTodoStateSync } from '@/hooks/useBlockchainEvents';

function SyncedTodoList() {
  const [todos, setTodos] = useState<Todo[]>([]);
  
  const { syncedTodos } = useTodoStateSync({
    todos,
    onTodoChange: (updatedTodos) => setTodos(updatedTodos),
    owner: walletAddress,
    autoStart: true,
  });

  return (
    <div>
      {syncedTodos.map(todo => (
        <div key={todo.id}>{todo.title}</div>
      ))}
    </div>
  );
}
```

### 4. Real-time Todo List Component

```typescript
import { RealtimeTodoList } from '@/components/RealtimeTodoList';

function MyTodoPage() {
  const [todos, setTodos] = useState<Todo[]>([]);
  
  return (
    <RealtimeTodoList
      initialTodos={todos}
      listName="My Todos"
      onTodoUpdate={(updatedTodos) => setTodos(updatedTodos)}
      onTodoComplete={async (todo) => {
        await completeTodoOnBlockchain(todo.objectId!);
      }}
      onTodoDelete={async (todoId) => {
        await deleteTodoFromBlockchain(todoId);
      }}
      showEventIndicator={true}
    />
  );
}
```

##  Key Features

### Real-time Event Handling
- **TodoNFTCreated** - New todo NFT creation events
- **TodoNFTCompleted** - Todo completion events
- **TodoNFTUpdated** - Todo metadata update events
- **TodoNFTDeleted** - Todo deletion events
- **TodoNFTTransferred** - NFT ownership transfer events

### Connection Management
- **Auto-reconnection** - Automatic reconnection on network issues
- **Error handling** - Comprehensive error handling and recovery
- **Connection status** - Visual indicators for connection state
- **Health monitoring** - Periodic connection health checks

### State Synchronization
- **Optimistic updates** - Immediate UI updates with blockchain confirmation
- **Automatic syncing** - State automatically syncs with blockchain events
- **Conflict resolution** - Handles conflicts between local and blockchain state
- **Memory management** - Proper cleanup to prevent memory leaks

### TypeScript Support
- **Full type safety** - Complete TypeScript definitions
- **Event type guards** - Type-safe event handling
- **Generic hooks** - Flexible, reusable hook patterns
- **Interface compatibility** - Consistent interfaces across components

##  Configuration Options

### Event Manager Configuration

```typescript
const config = {
  packageId: '0x123...', // TodoNFT package ID
  eventTypes: ['TodoNFTCreated', 'TodoNFTCompleted'], // Filter specific events
  maxReconnectAttempts: 5, // Maximum reconnection attempts
  reconnectDelay: 3000, // Base reconnection delay (ms)
  autoReconnect: true, // Enable automatic reconnection
};
```

### Hook Options

```typescript
// useBlockchainEvents options
const eventOptions = {
  autoStart: true, // Start subscriptions automatically
  owner: walletAddress, // Filter events by owner
  enableReconnect: true, // Enable reconnection on failure
};

// useTodoEvents options
const todoOptions = {
  autoStart: true,
  owner: walletAddress,
  onTodoCreated: (todo) => { /* handler */ },
  onTodoUpdated: (todo) => { /* handler */ },
  onTodoCompleted: (todo) => { /* handler */ },
  onTodoDeleted: (todoId) => { /* handler */ },
};
```

##  UI Components

### BlockchainEventStatus
Shows detailed connection status with reconnection options:

```typescript
<BlockchainEventStatus 
  showReconnectButton={true}
  showDetails={true}
  className="mb-4"
/>
```

### BlockchainEventIndicator
Compact status indicator for headers/navbars:

```typescript
<BlockchainEventIndicator className="ml-4" />
```

### RealtimeTodoList
Enhanced todo list with real-time updates:

```typescript
<RealtimeTodoList
  initialTodos={todos}
  listName="My Todos"
  onTodoUpdate={handleTodoUpdate}
  showEventIndicator={true}
/>
```

##  Event Flow

1. **Connection Setup**
   - Initialize SuiClient
   - Subscribe to TodoNFT events
   - Set up event filters

2. **Event Processing**
   - Receive blockchain events
   - Parse event data
   - Transform to local format

3. **State Updates**
   - Update local state
   - Notify React components
   - Trigger UI updates

4. **Error Handling**
   - Detect connection issues
   - Attempt reconnection
   - Show user feedback

##  Testing

The implementation includes comprehensive tests covering:

- **Hook behavior** - Event subscription and state management
- **Error scenarios** - Connection failures and recovery
- **State synchronization** - Automatic state updates
- **Memory management** - Proper cleanup on unmount

Run tests with:
```bash
npm test -- --testPathPattern=useBlockchainEvents
```

##  Troubleshooting

### Common Issues

1. **Events not received**
   - Verify wallet connection
   - Check network configuration
   - Ensure correct package ID

2. **Connection drops**
   - Check WebSocket support
   - Verify network stability
   - Review reconnection settings

3. **Memory leaks**
   - Ensure proper cleanup
   - Check useEffect dependencies
   - Verify event listener removal

4. **Type errors**
   - Update TypeScript definitions
   - Check import paths
   - Verify interface compatibility

### Debug Information

Enable debug logging by adding to your environment:
```bash
NEXT_PUBLIC_NODE_ENV=development
```

Check browser console for detailed logs:
- Event subscriptions
- Connection status
- Error messages
- Performance metrics

##  Performance Considerations

### Optimization Strategies

1. **Event Filtering**
   - Use owner filters to reduce network traffic
   - Subscribe only to needed event types
   - Implement client-side filtering for complex queries

2. **State Management**
   - Use optimistic updates for better UX
   - Implement proper memoization
   - Avoid unnecessary re-renders

3. **Memory Management**
   - Clean up subscriptions on unmount
   - Use proper dependency arrays
   - Implement event throttling

4. **Network Efficiency**
   - Configure appropriate reconnection delays
   - Use exponential backoff for retries
   - Monitor connection health

##  Integration with Existing Code

### Update TodoList Component

The existing `todo-list.tsx` has been enhanced with:
- Real-time event subscriptions
- Blockchain status indicators
- Optimistic UI updates
- Explorer links for on-chain todos

### Wallet Context Integration

The event system integrates with the existing wallet context:
- Automatic subscription on wallet connect
- Proper cleanup on disconnect
- Address-based event filtering

### Local Storage Sync

Events are synchronized with local storage:
- Persistent state across sessions
- Fallback for offline functionality
- Conflict resolution strategies

##  Future Enhancements

Potential improvements and extensions:

1. **Event Persistence**
   - Store events in local database
   - Implement event replay functionality
   - Add event search and filtering

2. **Advanced Filtering**
   - Complex query builders
   - Time-based filters
   - Multi-criteria filtering

3. **Batch Operations**
   - Handle multiple events together
   - Optimize network requests
   - Implement transaction batching

4. **Analytics Integration**
   - Track event patterns
   - Performance monitoring
   - User behavior analysis

##  Additional Resources

- [Integration Guide](../docs/blockchain-event-integration-guide.md)
- [Usage Examples](./src/examples/blockchain-events-usage.tsx)
- [Type Definitions](./src/types/blockchain-events.ts)
- [Test Suite](./src/__tests__/hooks/useBlockchainEvents.test.tsx)

##  Contributing

When contributing to the event system:

1. **Follow TypeScript best practices**
2. **Add comprehensive tests**
3. **Update documentation**
4. **Consider performance implications**
5. **Test with actual blockchain transactions**

##  License

This blockchain event system is part of the Walrus Todo application and follows the same license terms.
</file>

<file path="README.md">
# Walrus Todo Web3 Frontend

A modern, oceanic-themed Web3 frontend for the Walrus Todo application built with Next.js and Tailwind CSS.

## Features

- Dreamy oceanic design with glass-morphism cards
- Responsive layout for all device sizes
- Integration with Sui blockchain for NFT todos
- Dual wallet support: Sui ecosystem and Phantom (Solana)
- Unified wallet context for seamless integration
- Animated UI elements with wave and floating effects
- Resilient local storage with fallbacks for restricted environments

## Getting Started

### Installation

First, install dependencies:

```bash
# From this directory
pnpm install

# If the root workspace has TypeScript errors, use:
CI=true pnpm install

# For clean installation
rm -rf node_modules && pnpm install
```

For detailed installation instructions, see [INSTALLATION.md](./INSTALLATION.md).

### Development

Run the development server:

```bash
pnpm dev
```

The server will automatically find and use an available port starting from 3000. If port 3000 is occupied, it will try 3001, 3002, etc. The server will display the actual port being used in the console.

For simple development without automatic port detection:

```bash
pnpm run dev:simple
```

### Production

Start the production server:

```bash
pnpm start
```

Like the development server, this will automatically find an available port and display the URL in the console.

### Alternative Scripts

If you need to use a specific port for testing or development, you can use the fixed-port scripts:

```bash
# Development server on port 3000 (fails if port is occupied)
pnpm run dev:fixed-port

# Production server on port 3000 (fails if port is occupied)  
pnpm run start:fixed-port

# Or set a specific port
PORT=3005 pnpm run dev:fixed-port
```

### Building

Create a production build:

```bash
pnpm build
```

### Linting

Run ESLint to check code quality:

```bash
pnpm lint
pnpm lint:fix  # Auto-fix issues
```

## Design System

This frontend uses a custom oceanic theme with:

- Ocean-inspired color palette (deep blues, teals, light foam colors)
- Glass-morphism cards with backdrop blur
- Subtle animations including floating elements and waves
- Responsive components optimized for all device sizes
- System font stack for optimal performance and availability

### Color Palette

- `ocean-deep`: #003366 - Deep blue for primary elements and dark backgrounds
- `ocean-medium`: #0077b6 - Medium blue for buttons and interactive elements
- `ocean-light`: #90e0ef - Light blue for hover states and accents
- `ocean-foam`: #caf0f8 - Very light blue for backgrounds and subtle elements
- `dream-purple`: #7209b7 - Purple for special elements and NFT indicators
- `dream-violet`: #9d4edd - Light purple for accents
- `dream-teal`: #48bfe3 - Teal for highlights and gradients
- `coral`: #ff7f50 - Accent color for attention-grabbing elements
- `sand`: #f5e1c0 - Neutral warm color for contrast

## Pages

### Home (/)
- Hero section with animated logo
- Feature highlights with glass-morphism cards
- Wallet connection button and simulation

### Dashboard (/dashboard)
- Todo list management interface
- Create new todos with priority, tags, due date
- Toggle todo completion
- List selection sidebar

### Blockchain (/blockchain)
- View NFT todos stored on the blockchain
- Display object IDs and transaction information
- Link to blockchain explorer

## Components

- `Navbar` - Navigation and wallet connection
- `TodoList` - Display and manage todo items
- `CreateTodoForm` - Form for creating new todos
- `WalletConnectButton` - Unified wallet connection UI
- `WalletContextProvider` - Global wallet state management

## Wallet Integration

### Supported Wallets

1. **Sui Ecosystem Wallets**:
   - Sui Wallet
   - Suiet
   - Martian
   - Other wallets compatible with `@mysten/dapp-kit`

2. **Phantom Wallet** (Solana):
   - Used for cross-chain compatibility
   - Future integration with Solana ecosystem

### Wallet Setup

1. Install a supported wallet extension in your browser
2. Connect your wallet using the button in the navigation bar
3. Approve transaction requests for blockchain operations

### Wallet Context

The app uses a unified wallet context that provides:
- Connect/disconnect functionality
- Address display
- Transaction signing capabilities
- Cross-wallet compatibility

## Integration with Backend

This frontend integrates with the Walrus Todo CLI backend for:

- Todo storage on the blockchain
- NFT representation of todos
- Wallet connectivity for blockchain transactions
- Data synchronization between local and blockchain storage
- Signer integration for authenticated operations

## Storage System

The frontend implements a robust storage system with:

- In-memory state management for core functionality
- Conditional localStorage persistence when available
- Graceful fallbacks for environments where storage access is restricted
- Storage availability detection and error handling

## Project Structure

- `src/app` - Next.js App Router pages
- `src/components` - Reusable React components
  - `src/components/WalletConnectButton.tsx` - Wallet connection UI
- `src/styles` - CSS and Tailwind configuration
- `src/lib` - Utility functions and blockchain integration
  - `src/lib/sui-client.ts` - Blockchain interaction simulation
  - `src/lib/todo-service.ts` - Todo data management with wallet integration
  - `src/lib/walletContext.tsx` - Unified wallet state management
- `public` - Static assets including images

## Browser Compatibility

The application is designed to work in various environments:

- Modern browsers (Chrome, Firefox, Safari, Edge)
- Mobile browsers with responsive design
- Environments with restricted localStorage access
- Server-side rendering compatible components

## Production Deployment

Build the application for production:

```bash
pnpm build
```

Then start the production server:

```bash
pnpm start
```

## Parent Project Integration

This frontend is part of the Walrus Todo monorepo and can be run from the root directory with:

```bash
# Install dependencies
pnpm run nextjs:install

# Run development server
pnpm run nextjs

# Build for production
pnpm run nextjs:build
```

## Troubleshooting

### MIME Type Issues

If you encounter errors like "Refused to apply style because its MIME type is not a supported stylesheet MIME type":

1. **Clear your browser cache** completely (Ctrl/Cmd + Shift + R)
2. **Clear Next.js cache**: `rm -rf .next && pnpm build`
3. **Check the console** for any build errors before starting the server

These issues are typically caused by cached or corrupted static assets and should resolve after clearing caches.

### Storage Access Errors

The application includes comprehensive error handling for storage access issues. These warnings in the console are expected in restricted environments:

- `Access to storage is not allowed from this context`
- Storage-related promise rejections

The app will continue to work normally using in-memory fallbacks.
</file>

<file path="reset-next.sh">
#!/bin/bash

# Script to reset and restart Next.js dev server when things go wrong
# This fixes common issues with the development server

echo " Complete Next.js reset..."

# Stop any running Next.js servers
echo " Stopping current servers..."
pkill -f "node.*next" || true

# Clean caches and build artifacts
echo " Cleaning caches and build artifacts..."
rm -rf .next
rm -rf node_modules/.cache
rm -rf .next.lock

# Clear NPM cache for Next.js
echo " Clearing npm cache for Next.js..."
npm cache clean --force next react react-dom

# Install required dev dependencies
echo " Installing essential dev dependencies..."
npm install --save-dev style-loader
npm install --no-save mini-css-extract-plugin@latest

# Set development environment
echo " Setting development environment..."
export NODE_ENV="development"
export NEXT_DISABLE_SOURCEMAPS=1
export NEXT_TELEMETRY_DISABLED=1
export NEXT_RUNTIME="nodejs"
export PORT=3002

# Simplify Next.js configuration for development
echo " Creating simplified development config..."
cat > .next.config.simple.js << 'EOF'
/** @type {import('next').NextConfig} */
module.exports = {
  reactStrictMode: true,
  images: {
    domains: ['localhost', '192.168.8.204'],
  },
  webpack: (config) => {
    if (!config.resolve) config.resolve = {};
    if (!config.resolve.fallback) config.resolve.fallback = {};
    
    config.resolve.fallback = {
      ...config.resolve.fallback,
      fs: false,
      net: false,
      tls: false,
      encoding: false,
    };
    
    // Disable code splitting completely
    config.optimization = {
      ...config.optimization,
      splitChunks: false,
      runtimeChunk: false,
    };
    
    return config;
  },
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'no-cache, no-store, must-revalidate',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          }
        ],
      }
    ];
  }
};
EOF

# Launch the development server with simplified config
echo " Starting Next.js server with clean slate..."
NEXT_CONFIG_FILE=.next.config.simple.js NEXT_TURBO=0 NODE_OPTIONS="--max-old-space-size=8192 --no-warnings" npx next dev --port $PORT

echo " Next.js dev server restarted successfully!"
</file>

<file path="setup-config.js">
#!/usr/bin/env node

/**
 * Configuration Setup Script for Frontend
 *
 * Copies auto-generated configuration files from src/config to public/config
 * so they can be loaded dynamically at runtime.
 */

const fs = require('fs');
const path = require('path');

const CONFIG_SOURCE_DIR = path.join(__dirname, 'src', 'config');
const CONFIG_PUBLIC_DIR = path.join(__dirname, 'public', 'config');

/**
 * Ensures a directory exists
 */
function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    console.log(`Created directory: ${dir}`);
  }
}

/**
 * Copies JSON config files to public directory
 */
function copyConfigFiles() {
  ensureDir(CONFIG_PUBLIC_DIR);

  if (!fs.existsSync(CONFIG_SOURCE_DIR)) {
    console.log(
      'No config directory found - run "waltodo deploy" first to generate configurations'
    );
    return;
  }

  const files = fs.readdirSync(CONFIG_SOURCE_DIR);
  const jsonFiles = files.filter(file => file.endsWith('.json'));

  if (jsonFiles.length === 0) {
    console.log(
      'No JSON config files found - run "waltodo deploy" first to generate configurations'
    );
    return;
  }

  jsonFiles.forEach(file => {
    const sourcePath = path.join(CONFIG_SOURCE_DIR, file);
    const destPath = path.join(CONFIG_PUBLIC_DIR, file);

    try {
      fs.copyFileSync(sourcePath, destPath);
      console.log(`Copied ${file} to public/config/`);
    } catch (error) {
      console.error(`Failed to copy ${file}:`, error.message);
    }
  });

  console.log(`\nConfiguration setup complete! Found configs for:`);
  jsonFiles.forEach(file => {
    const network = file.replace('.json', '');
    console.log(`  - ${network} network`);
  });
}

/**
 * Main execution
 */
function main() {
  console.log('Setting up frontend configuration...\n');
  copyConfigFiles();
}

if (require.main === module) {
  main();
}

module.exports = { copyConfigFiles };
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    fontFamily: {
      sans: [
        'ui-sans-serif',
        'system-ui',
        '-apple-system',
        'BlinkMacSystemFont',
        '"Segoe UI"',
        'Roboto',
        '"Helvetica Neue"',
        'Arial',
        'sans-serif',
      ],
    },
    extend: {
      colors: {
        // Oceanic dreamy palette
        'ocean-deep': '#003366',
        'ocean-medium': '#0077b6',
        'ocean-light': '#90e0ef',
        'ocean-foam': '#caf0f8',
        'dream-purple': '#7209b7',
        'dream-violet': '#9d4edd',
        'dream-teal': '#48bfe3',
        coral: '#ff7f50',
        sand: '#f5e1c0',
      },
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
        'ocean-wave': 'url("/images/ocean-wave.svg")',
      },
      animation: {
        wave: 'wave 8s ease-in-out infinite',
        float: 'float 6s ease-in-out infinite',
      },
      keyframes: {
        wave: {
          '0%, 100%': { transform: 'translateY(0)' },
          '50%': { transform: 'translateY(-20px)' },
        },
        float: {
          '0%, 100%': { transform: 'translateY(0) rotate(0deg)' },
          '50%': { transform: 'translateY(-10px) rotate(2deg)' },
        },
      },
      boxShadow: {
        dreamy: '0 4px 30px rgba(0, 105, 148, 0.3)',
        underwater: '0 8px 32px rgba(144, 224, 239, 0.3)',
      },
    },
  },
  plugins: [],
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

</files>
