import { 
  ProgressiveImageLoader, 
  preloadImages,
  type ImagePreloadOptions 
} from './image-optimization';
import { getImageUrl as getWalrusImageUrl } from '@/lib/walrus-client';

// Configuration for Walrus image optimization
const WALRUS_IMAGE_CONFIG = {
  // Maximum concurrent image loads
  maxConcurrent: 3,
  // Retry configuration for Walrus network errors
  retryConfig: {
    maxRetries: 5,
    initialDelay: 1000,
    maxDelay: 10000,
    backoffFactor: 2,
  },
  // Cache duration for Walrus images (7 days)
  cacheDuration: 7 * 24 * 60 * 60 * 1000,
};

/**
 * Optimized loader for Walrus images with retry logic
 */
export class WalrusImageLoader extends ProgressiveImageLoader {
  private walrusBlobId?: string;
  private retryAttempts = 0;

  constructor(blobIdOrUrl: string) {
    // Convert blob ID to URL if needed
    const url = blobIdOrUrl.startsWith('blob:') || blobIdOrUrl.includes('aggregator')
      ? blobIdOrUrl
      : getWalrusImageUrl(blobIdOrUrl);
    
    super(url);
    
    // Extract blob ID for tracking
    if (blobIdOrUrl.includes('blobId=')) {
      this.walrusBlobId = new URL(blobIdOrUrl).searchParams.get('blobId') || undefined;
    } else if (!blobIdOrUrl.startsWith('http')) {
      this.walrusBlobId = blobIdOrUrl;
    }
  }

  async load(options: ImagePreloadOptions = {}): Promise<any> {
    try {
      return await super.load(options);
    } catch (error) {
      // Enhanced retry logic for Walrus network issues
      if (this.retryAttempts < WALRUS_IMAGE_CONFIG.retryConfig.maxRetries) {
        this.retryAttempts++;
        const delay = Math.min(
          WALRUS_IMAGE_CONFIG.retryConfig.initialDelay * 
          Math.pow(WALRUS_IMAGE_CONFIG.retryConfig.backoffFactor, this.retryAttempts - 1),
          WALRUS_IMAGE_CONFIG.retryConfig.maxDelay
        );
        
        console.warn(
          `Walrus image load failed, retrying in ${delay}ms (attempt ${this.retryAttempts}/${WALRUS_IMAGE_CONFIG.retryConfig.maxRetries})`,
          this.walrusBlobId
        );
        
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.load(options);
      }
      
      throw error;
    }
  }
}

/**
 * Batch load multiple Walrus images with concurrency control
 */
export async function batchLoadWalrusImages(
  blobIds: string[],
  options: ImagePreloadOptions = {}
): Promise<Map<string, { success: boolean; url?: string; error?: string }>> {
  const results = new Map<string, { success: boolean; url?: string; error?: string }>();
  const queue = [...blobIds];
  const inProgress = new Set<Promise<void>>();

  async function processNext(): Promise<void> {
    if (queue.length === 0) return;
    
    const blobId = queue.shift()!;
    const loader = new WalrusImageLoader(blobId);
    
    try {
      const result = await loader.load(options);
      results.set(blobId, { success: true, url: result.src });
    } catch (error) {
      results.set(blobId, { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
    }
  }

  // Process images with concurrency limit
  while (queue.length > 0 || inProgress.size > 0) {
    while (inProgress.size < WALRUS_IMAGE_CONFIG.maxConcurrent && queue.length > 0) {
      const promise = processNext();
      inProgress.add(promise);
      promise.finally(() => inProgress.delete(promise));
    }
    
    if (inProgress.size > 0) {
      await Promise.race(inProgress);
    }
  }

  return results;
}

/**
 * Preload Walrus images for a list of todos
 */
export async function preloadTodoImages(
  todos: Array<{ id: string; imageUrl?: string; walrusBlobId?: string }>,
  options: { 
    priority?: 'high' | 'low' | 'auto';
    maxImages?: number;
  } = {}
): Promise<void> {
  const imageUrls = todos
    .filter(todo => todo.imageUrl || todo.walrusBlobId)
    .slice(0, options.maxImages || 10)
    .map(todo => {
      if (todo.walrusBlobId) {
        return getWalrusImageUrl(todo.walrusBlobId);
      }
      return todo.imageUrl!;
    });

  if (imageUrls.length === 0) return;

  // Use the enhanced Walrus batch loader
  await batchLoadWalrusImages(imageUrls, { priority: options.priority });
}

/**
 * Hook for optimized Walrus image loading
 */
export function useWalrusImage(blobIdOrUrl: string | undefined, options: ImagePreloadOptions = {}) {
  const [state, setState] = useState({
    isLoading: true,
    hasError: false,
    imageUrl: undefined as string | undefined,
    blurDataUrl: undefined as string | undefined,
  });

  useEffect(() => {
    if (!blobIdOrUrl) {
      setState({
        isLoading: false,
        hasError: false,
        imageUrl: undefined,
        blurDataUrl: undefined,
      });
      return;
    }

    let isMounted = true;
    const loader = new WalrusImageLoader(blobIdOrUrl);

    loader.load(options)
      .then(result => {
        if (isMounted) {
          setState({
            isLoading: false,
            hasError: false,
            imageUrl: result.src,
            blurDataUrl: loader.getState().blurDataUrl,
          });
        }
      })
      .catch(error => {
        if (isMounted) {
          console.error('Failed to load Walrus image:', error);
          setState(prev => ({
            ...prev,
            isLoading: false,
            hasError: true,
          }));
        }
      });

    return () => {
      isMounted = false;
    };
  }, [blobIdOrUrl, options.priority]);

  return state;
}

/**
 * Component for displaying Walrus-stored images with optimization
 */
export function WalrusOptimizedImage({
  blobId,
  alt,
  className,
  width,
  height,
  priority = 'auto',
  onLoad,
  onError,
}: {
  blobId: string;
  alt: string;
  className?: string;
  width?: number;
  height?: number;
  priority?: 'high' | 'low' | 'auto';
  onLoad?: () => void;
  onError?: () => void;
}) {
  const { isLoading, hasError, imageUrl, blurDataUrl } = useWalrusImage(blobId, { priority });

  if (hasError) {
    return (
      <div 
        className={`flex items-center justify-center bg-gray-100 dark:bg-gray-800 ${className}`}
        style={{ width, height }}
      >
        <div className="text-center p-4">
          <svg
            className="w-12 h-12 mx-auto text-gray-400"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
            />
          </svg>
          <p className="mt-2 text-sm text-gray-500">Failed to load Walrus image</p>
          <p className="text-xs text-gray-400 mt-1">Blob ID: {blobId.slice(0, 8)}...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="relative" style={{ width, height }}>
      {/* Blur placeholder */}
      {isLoading && blurDataUrl && (
        <img
          src={blurDataUrl}
          alt=""
          className={`absolute inset-0 w-full h-full object-cover filter blur-lg scale-110 ${className}`}
          aria-hidden="true"
        />
      )}
      
      {/* Loading spinner */}
      {isLoading && !blurDataUrl && (
        <div className={`flex items-center justify-center bg-gray-100 dark:bg-gray-800 ${className}`}>
          <div className="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin" />
        </div>
      )}
      
      {/* Main image */}
      {imageUrl && (
        <img
          src={imageUrl}
          alt={alt}
          className={`${className} ${isLoading ? 'opacity-0' : 'opacity-100'} transition-opacity duration-300`}
          onLoad={() => {
            onLoad?.();
          }}
          onError={() => {
            onError?.();
          }}
          loading="lazy"
          decoding="async"
        />
      )}
    </div>
  );
}

// Re-export for convenience
import { useState, useEffect } from 'react';
export { getImagePerformanceMetrics, clearImageCaches } from './image-optimization';