"use strict";exports.id=612,exports.ids=[612],exports.modules={40677:(e,t,r)=>{r.d(t,{U:()=>s});var a=r(926),o=r(43467);function s(){let[e,t]=(0,a.useState)(!1),r=(0,o.tN)();return e?r?{...r,isLoading:!1}:{connected:!1,connecting:!1,account:null,address:null,chainId:null,name:null,network:"testnet",error:null,isLoading:!1,connect:()=>{},disconnect:()=>{},signAndExecuteTransaction:async()=>{throw Error("Wallet not initialized")},clearError:()=>{},openModal:()=>{},closeModal:()=>{},resetSession:()=>{},resetActivityTimer:()=>{},switchNetwork:()=>{},addTransaction:()=>{},trackTransaction:async()=>{throw Error("Wallet not initialized")},sessionExpired:!1,lastActivity:0,transactionHistory:[],currentNetwork:"testnet",isModalOpen:!1}:{connected:!1,connecting:!1,account:null,address:null,chainId:null,name:null,network:"testnet",error:null,isLoading:!0,connect:()=>{},disconnect:()=>{},signAndExecuteTransaction:async()=>{throw Error("Wallet not ready")},clearError:()=>{},openModal:()=>{},closeModal:()=>{},resetSession:()=>{},resetActivityTimer:()=>{},switchNetwork:()=>{},addTransaction:()=>{},trackTransaction:async()=>{throw Error("Wallet not ready")},sessionExpired:!1,lastActivity:0,transactionHistory:[],currentNetwork:"testnet",isModalOpen:!1}}},50612:(e,t,r)=>{r.d(t,{p:()=>i});var a=r(926),o=r(29238),s=r(11470);class n{constructor(e="testnet"){this.network=e,this.walrusStorage=new o.zg(e),this.walrusClient=this.walrusStorage.getClient()}async createTodo(e,t,r,a={}){let{epochs:n=5,deletable:l=!0,isPrivate:i=!1,createNFT:c=!0,onProgress:d}=a,g=`todo_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,u={...e,id:g,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),blockchainStored:!1,isPrivate:i,storageEpochs:n};try{let e;d?.("Uploading to Walrus storage...",25);let a=await this.walrusStorage.storeTodo(u,t,{epochs:n,deletable:l,attributes:{type:"todo",title:u.title,priority:u.priority,private:String(i),created:new Date().toISOString()},onProgress:d?e=>d("Uploading...",25+.5*e):void 0});if(u.walrusBlobId=a.blobId,u.storageSize=a.metadata.size,u.blockchainStored=!0,d?.("Upload to Walrus complete",75),c&&r){d?.("Creating NFT on Sui blockchain...",85);try{let o={title:u.title,description:u.description||"",imageUrl:`walrus://${a.blobId}`,metadata:JSON.stringify({walrusBlobId:a.blobId,priority:u.priority,tags:u.tags,dueDate:u.dueDate,storageEpochs:n,createdAt:u.createdAt}),isPrivate:i},l="";"getAddress"in t&&"function"==typeof t.getAddress?l=await t.getAddress():"toSuiAddress"in t&&"function"==typeof t.toSuiAddress&&(l=t.toSuiAddress()),(e=await (0,s.storeTodoOnBlockchain)(o,r,l)).success?(u.suiObjectId=e.objectId,d?.("NFT creation complete",100)):(console.warn("Failed to create NFT:",e.error),d?.("NFT creation failed, but Walrus storage successful",90))}catch(e){console.warn("NFT creation failed:",e),d?.("NFT creation failed, but Walrus storage successful",90)}}else d?.("Storage complete",100);let o=await this.walrusClient.calculateStorageCost(a.metadata.size,n),g={walrusBlobId:a.blobId,suiObjectId:u.suiObjectId,storageSize:a.metadata.size,storageEpochs:n,storageCost:{total:o.totalCost,storage:o.storageCost,write:o.writeCost},uploadTimestamp:new Date().toISOString(),expiresAt:a.metadata.expiresAt&&("string"==typeof a.metadata.expiresAt||"number"==typeof a.metadata.expiresAt)?new Date(a.metadata.expiresAt).toISOString():void 0};return{todo:u,walrusResult:a,suiResult:e,metadata:g}}catch(e){if(e instanceof o.AQ)throw e;throw new o.AQ(`Failed to create todo: ${e instanceof Error?e.message:"Unknown error"}`,"TODO_CREATE_ERROR",e instanceof Error?e:void 0)}}async retrieveTodo(e){try{let t=await this.walrusStorage.retrieveTodo(e);if(!t||"object"!=typeof t)throw new o.AQ("Invalid todo data retrieved from storage");return{...t,blockchainStored:!0,walrusBlobId:e}}catch(e){if(e instanceof o.AQ)throw e;throw new o.AQ(`Failed to retrieve todo: ${e instanceof Error?e.message:"Unknown error"}`,"TODO_RETRIEVE_ERROR",e instanceof Error?e:void 0)}}async updateTodo(e,t,r={}){let a={...e,updatedAt:new Date().toISOString()};try{let{onProgress:o,...s}=r,n={...s,...o&&{onProgress:e=>o("storing",e)}};return await this.walrusStorage.storeTodo(a,t,{epochs:e.storageEpochs||5,deletable:!0,attributes:{type:"todo-update",title:a.title,priority:a.priority,originalBlobId:e.walrusBlobId||"",updated:new Date().toISOString()},...n})}catch(e){if(e instanceof o.AQ)throw e;throw new o.AQ(`Failed to update todo: ${e instanceof Error?e.message:"Unknown error"}`,"TODO_UPDATE_ERROR",e instanceof Error?e:void 0)}}async deleteTodo(e,t){try{return await this.walrusClient.deleteBlob(e,t)}catch(e){if(e instanceof o.AQ)throw e;throw new o.AQ(`Failed to delete todo: ${e instanceof Error?e.message:"Unknown error"}`,"TODO_DELETE_ERROR",e instanceof Error?e:void 0)}}async getTodoStorageInfo(e){try{let t;if(!await this.walrusClient.blobExists(e))return{exists:!1};let r=await this.walrusClient.getBlobInfo(e);try{let e=r.size||1024,a=await this.walrusClient.calculateStorageCost(e,5);t={total:a.totalCost,storage:a.storageCost,write:a.writeCost}}catch(e){console.warn("Failed to calculate storage cost:",e)}return{exists:!0,blobInfo:r,storageCost:t}}catch(e){return console.error("Error getting todo storage info:",e),{exists:!1}}}async createMultipleTodos(e,t,r,a={}){let o=[],{onProgress:s}=a;for(let n=0;n<e.length;n++){let l=e[n];s?.(`Creating todo ${n+1} of ${e.length}`,n/e.length*100);try{let e=await this.createTodo(l,t,r,{...a,onProgress:void 0});o.push(e)}catch(e){console.error(`Failed to create todo ${n+1}:`,e)}}return s?.("Batch creation complete",100),o}async estimateStorageCosts(e,t=5){let r=BigInt(0),a=0,o=[];for(let s of e){let e=await this.walrusStorage.estimateTodoStorageCost(s,t);r+=e.totalCost,a+=e.sizeBytes,o.push({totalCost:e.totalCost,size:e.sizeBytes})}return{totalCost:r,totalSize:a,perTodoCost:o}}async getWalBalance(){return this.walrusClient.getWalBalance()}async getStorageUsage(){return this.walrusClient.getStorageUsage()}}new n;var l=r(40677);function i(e={}){let{network:t="testnet",autoRefreshBalance:r=!0,autoRefreshUsage:s=!0,refreshInterval:i=3e4}=e,c=(0,l.U)(),d=c?.connected||!1,g=c?.address||null;c?.error;let u=c?.signAndExecuteTransaction,[p,w]=(0,a.useState)({loading:!1,uploading:!1,downloading:!1,deleting:!1,progress:0,progressMessage:"",error:null,walBalance:null,storageUsage:null}),y=(0,a.useRef)(null),h=(0,a.useCallback)(()=>(y.current||(y.current=new n(t)),y.current),[t]),b=(0,a.useCallback)((e,t)=>{let r;return r=e instanceof o.AQ?e:new o.AQ(`${t} failed: ${e instanceof Error?e.message:"Unknown error"}`,"OPERATION_ERROR",e instanceof Error?e:void 0),w(e=>({...e,error:r,loading:!1})),r},[]),f=(0,a.useCallback)((e,t)=>{w(r=>({...r,progress:Math.min(100,Math.max(0,t)),progressMessage:e}))},[]),C=(0,a.useCallback)(async(e,t={})=>{if(!d||!g)return b(Error("Wallet not connected"),"Create Todo"),null;w(e=>({...e,uploading:!0,loading:!0,error:null,progress:0,progressMessage:"Starting upload..."}));try{let r=h();if(!u)throw Error("Wallet signing capability not available");let a=await r.createTodo(e,{signData:async e=>({signature:new Uint8Array(64),publicKey:new Uint8Array(32)}),getAddress:()=>g,toSuiAddress:()=>g},u,{...t,onProgress:f});return w(e=>({...e,uploading:!1,loading:!1,progress:100,progressMessage:"Upload complete"})),a}catch(e){return w(e=>({...e,uploading:!1})),b(e,"Create Todo"),null}},[d,g,u,h,b,f]),S=(0,a.useCallback)(async e=>{w(e=>({...e,downloading:!0,loading:!0,error:null,progressMessage:"Retrieving todo..."}));try{let t=h(),r=await t.retrieveTodo(e);return w(e=>({...e,downloading:!1,loading:!1,progressMessage:"Retrieval complete"})),r}catch(e){return w(e=>({...e,downloading:!1})),b(e,"Retrieve Todo"),null}},[h,b]),E=(0,a.useCallback)(async(e,t={})=>{if(!d||!g)return b(Error("Wallet not connected"),"Update Todo"),!1;w(e=>({...e,uploading:!0,loading:!0,error:null,progressMessage:"Updating todo..."}));try{let r=h();return await r.updateTodo(e,{signData:async e=>({signature:new Uint8Array(64),publicKey:new Uint8Array(32)}),getAddress:()=>g,toSuiAddress:()=>g},t),w(e=>({...e,uploading:!1,loading:!1,progressMessage:"Update complete"})),!0}catch(e){return w(e=>({...e,uploading:!1})),b(e,"Update Todo"),!1}},[d,g,h,b]),A=(0,a.useCallback)(async e=>{if(!d||!g)return b(Error("Wallet not connected"),"Delete Todo"),!1;w(e=>({...e,deleting:!0,loading:!0,error:null,progressMessage:"Deleting todo..."}));try{let t=h();return await t.deleteTodo(e,{signData:async e=>({signature:new Uint8Array(64),publicKey:new Uint8Array(32)}),getAddress:()=>g,toSuiAddress:()=>g}),w(e=>({...e,deleting:!1,loading:!1,progressMessage:"Deletion complete"})),!0}catch(e){return w(e=>({...e,deleting:!1})),b(e,"Delete Todo"),!1}},[d,g,h,b]),T=(0,a.useCallback)(async(e,t={})=>{if(!d||!g)return b(Error("Wallet not connected"),"Create Multiple Todos"),[];w(e=>({...e,uploading:!0,loading:!0,error:null,progress:0,progressMessage:"Starting batch upload..."}));try{let r=h();if(!u)throw Error("Wallet signing capability not available");let a=await r.createMultipleTodos(e,{signData:async e=>({signature:new Uint8Array(64),publicKey:new Uint8Array(32)}),getAddress:()=>g,toSuiAddress:()=>g},u,{...t,onProgress:f});return w(e=>({...e,uploading:!1,loading:!1,progress:100,progressMessage:"Batch upload complete"})),a}catch(e){return w(e=>({...e,uploading:!1})),b(e,"Create Multiple Todos"),[]}},[d,g,u,h,b,f]),m=(0,a.useCallback)(async e=>{w(e=>({...e,loading:!0,error:null}));try{let t=h(),r=await t.getTodoStorageInfo(e);return w(e=>({...e,loading:!1})),r}catch(e){return b(e,"Get Storage Info"),null}},[h,b]),I=(0,a.useCallback)(async(e,t=5)=>{w(e=>({...e,loading:!0,error:null}));try{let r=h(),a=await r.estimateStorageCosts(e,t);return w(e=>({...e,loading:!1})),a}catch(e){return b(e,"Estimate Storage Costs"),null}},[h,b]),k=(0,a.useCallback)(async()=>{try{let e=h(),t=await e.getWalBalance();w(e=>({...e,walBalance:t}))}catch(e){console.warn("Failed to refresh WAL balance:",e)}},[h]),U=(0,a.useCallback)(async()=>{try{let e=h(),t=await e.getStorageUsage();w(e=>({...e,storageUsage:t}))}catch(e){console.warn("Failed to refresh storage usage:",e)}},[h]),v=(0,a.useCallback)(async()=>{try{let e=h(),t=e.walrusClient||e.walrusStorage?.getClient?.();return t&&"function"==typeof t.getWalBalance&&await t.getWalBalance(),{success:!0}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Connection test failed"}}},[h]),O=(0,a.useCallback)(async(e,t={})=>{try{let t=h(),r=t.walrusClient||t.walrusStorage?.getClient?.();if(r&&"function"==typeof r.upload){let t=await r.upload(e,{epochs:1});return{success:!0,blobId:t.blobId}}throw Error("Walrus client not available")}catch(e){return{success:!1,error:e instanceof Error?e.message:"Upload failed"}}},[h]),M=(0,a.useCallback)(async e=>{try{let t=h(),r=t.walrusClient||t.walrusStorage?.getClient?.();if(r&&"function"==typeof r.download){let t=await r.download(e);return{success:!0,data:t.data}}throw Error("Walrus client not available")}catch(e){return{success:!1,error:e instanceof Error?e.message:"Retrieval failed"}}},[h]),D=(0,a.useCallback)(async(e,t={})=>{if(!d||!g)return b(Error("Wallet not connected"),"Upload Image"),null;w(e=>({...e,uploading:!0,loading:!0,error:null,progress:0,progressMessage:"Uploading image..."}));try{let r=h(),a=r.walrusClient||r.walrusStorage?.getClient?.();if(a&&"function"==typeof a.uploadImage){t?.onProgress?.(20);let r=await a.uploadImage(e,{epochs:t.epochs||5});t?.onProgress?.(80);let o=a.getBlobUrl?.(r.blobId)||`walrus://${r.blobId}`;return w(e=>({...e,uploading:!1,loading:!1,progress:100,progressMessage:"Image uploaded successfully"})),t?.onProgress?.(100),{blobId:r.blobId,url:o}}throw Error("Image upload not supported")}catch(e){return w(e=>({...e,uploading:!1})),b(e,"Upload Image"),null}},[d,g,h,b]),R=(0,a.useCallback)(()=>{w(e=>({...e,error:null}))},[]),W=(0,a.useCallback)(()=>{w({loading:!1,uploading:!1,downloading:!1,deleting:!1,progress:0,progressMessage:"",error:null,walBalance:null,storageUsage:null})},[]);return{...p,createTodo:C,retrieveTodo:S,updateTodo:E,deleteTodo:A,createMultipleTodos:T,getTodoStorageInfo:m,estimateStorageCosts:I,testConnection:v,uploadBlob:O,retrieveBlob:M,uploadImage:D,refreshWalBalance:k,refreshStorageUsage:U,clearError:R,reset:W}}}};