"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9183],{59183:function(e,t,r){r.d(t,{h6:function(){return m},u6:function(){return w}});var a=r(22585),o=r(6229),n=r(98436),i=r(19132),l=r(51705),s=r(25288);let c=new Map,d=new Map,u={maxRetries:3,retryDelay:1e3,backoffMultiplier:2};async function f(e){let t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u;for(let a=0;a<r.maxRetries;a++)try{return await e()}catch(e){if((t=e instanceof Error?e:Error(String(e))).message.includes("Wallet not connected")||t.message.includes("User rejected"))throw t;if(a<r.maxRetries-1){let e=r.retryDelay*Math.pow(r.backoffMultiplier,a);await new Promise(t=>setTimeout(t,e))}}throw t}function g(e,t){let r;if(!e)return;let a="".concat(e,"_").concat((null==t?void 0:t.size)||"full"),o=d.get(a);if(o)return o;if(e.startsWith("walrus://")){let a=e.replace("walrus://","");if(r=l.$4.getBlobUrl(a),(null==t?void 0:t.size)&&"full"!==t.size){let e=new URL(r);"thumbnail"===t.size?(e.searchParams.set("w","150"),e.searchParams.set("h","150"),e.searchParams.set("q","85")):"preview"===t.size&&(e.searchParams.set("w","300"),e.searchParams.set("h","300"),e.searchParams.set("q","90")),r=e.toString()}}else r=e;return d.set(a,r),r}async function h(e,t){try{if(!e)throw Error("Wallet not connected");return await f(async()=>await (0,i.wi)(async r=>{var a,o,n,l;let d,u;try{let e=await (0,s.qn)();d=(null==e?void 0:null===(a=e.deployment)||void 0===a?void 0:a.packageId)||(0,i.$6)()}catch(e){console.warn("Failed to load app config, using fallback package ID:",e),d=(0,i.$6)()}try{u=await r.getOwnedObjects({owner:e,filter:{StructType:"".concat(d,"::todo_nft::TodoNFT")},options:{showContent:!0,showOwner:!0,showType:!0,showDisplay:!0},cursor:null==t?void 0:t.cursor,limit:(null==t?void 0:t.limit)||50})}catch(a){console.warn("Failed to fetch with specific struct type, trying broader search:",a),(u=await r.getOwnedObjects({owner:e,options:{showContent:!0,showOwner:!0,showType:!0,showDisplay:!0},cursor:null==t?void 0:t.cursor,limit:(null==t?void 0:t.limit)||100})).data=u.data.filter(e=>{var t;let r=null===(t=e.data)||void 0===t?void 0:t.type;return r&&(r.includes("::todo_nft::TodoNFT")||r.includes("TodoNFT")||r.includes(d))})}let f=[],h=[];for(let e of u.data)try{let t=function(e){try{if(!e.data)return console.warn("SuiObject has no data field"),null;if(!e.data.content)return console.warn("SuiObject data has no content field"),null;if("moveObject"!==e.data.content.dataType)return console.warn("SuiObject content dataType is ".concat(e.data.content.dataType,", expected 'moveObject'")),null;let t=e.data.content.fields;if(!t)return console.warn("SuiObject moveObject has no fields"),null;let r=e.data.objectId,a=t.title||t.name||"Untitled Todo",o=t.description||t.desc||"",n=!1;"boolean"==typeof t.completed?n=t.completed:"string"==typeof t.completed?n="true"===t.completed.toLowerCase():"boolean"==typeof t.is_completed&&(n=t.is_completed);let i=!1;"boolean"==typeof t.is_private?i=t.is_private:"boolean"==typeof t.private&&(i=t.private);let l={};try{l=function(e){if(!e)return{};try{let t=JSON.parse(e);return{priority:t.priority||"medium",tags:Array.isArray(t.tags)?t.tags:[],checklist:Array.isArray(t.checklist)?t.checklist:[],notes:t.notes||"",links:Array.isArray(t.links)?t.links:[],attachments:Array.isArray(t.attachments)?t.attachments:[]}}catch(e){return{}}}(t.metadata)}catch(e){console.warn("Failed to parse metadata:",e)}let{priority:s,tags:d,checklist:u,notes:f,links:h,attachments:m}=l,w=g(t.image_url||t.imageUrl),y=g(t.image_url||t.imageUrl,{size:"thumbnail"}),p=g(t.image_url||t.imageUrl,{size:"preview"}),v=t.image_url||t.imageUrl;v&&"string"==typeof v&&v.startsWith("walrus://")&&v.replace("walrus://","");let b=e=>{if(!e)return new Date().toISOString();if("string"==typeof e&&e.includes("T"))return e;if("number"==typeof e)return new Date(1e3*e).toISOString();if("string"==typeof e){let t=parseInt(e);if(!isNaN(t))return new Date(t>1e12?t:1e3*t).toISOString()}return new Date().toISOString()},E={id:r,objectId:r,title:a,description:o,completed:n,priority:s||"medium",tags:d||[],blockchainStored:!0,imageUrl:w,createdAt:b(t.created_at||t.createdAt),completedAt:n?b(t.completed_at||t.completedAt):void 0,owner:t.owner||"",metadata:t.metadata||"",isPrivate:i};if(r)try{c.set(r,{data:E,timestamp:Date.now(),imageUrl:w,thumbnailUrl:y,previewUrl:p,metadata:{title:t.title||t.name,description:t.description||t.desc,image_url:t.image_url||t.imageUrl,completed:n,created_at:parseInt(String(t.created_at||t.createdAt||Date.now()/1e3)),completed_at:n&&(t.completed_at||t.completedAt)?parseInt(String(t.completed_at||t.completedAt)):void 0,owner:t.owner||"",metadata:t.metadata||"",is_private:i,attributes:[{trait_type:"Priority",value:s||"medium"},{trait_type:"Status",value:n?"Completed":"Pending"},{trait_type:"Private",value:i},...d&&d.length>0?[{trait_type:"Tags",value:d.join(", ")}]:[]]}})}catch(e){console.warn("Failed to cache NFT data:",e)}return E}catch(r){var t;return console.error("Error transforming Sui object to Todo:",{objectId:null===(t=e.data)||void 0===t?void 0:t.objectId,error:r instanceof Error?r.message:String(r),suiObject:JSON.stringify(e,null,2)}),null}}(e);t?f.push(t):h.push({objectId:(null===(o=e.data)||void 0===o?void 0:o.objectId)||"unknown",error:"Transform returned null"})}catch(t){console.warn("Failed to transform object:",{objectId:null===(n=e.data)||void 0===n?void 0:n.objectId,error:t instanceof Error?t.message:String(t)}),h.push({objectId:(null===(l=e.data)||void 0===l?void 0:l.objectId)||"unknown",error:t instanceof Error?t.message:String(t)})}h.length>0&&console.warn("Failed to transform ".concat(h.length," objects:"),h);let m=f;if(null==t?void 0:t.filter){let{completed:e,priority:r,tags:a}=t.filter;void 0!==e&&(m=m.filter(t=>t.completed===e)),r&&(m=m.filter(e=>e.priority===r)),a&&a.length>0&&(m=m.filter(e=>a.some(t=>{var r;return null===(r=e.tags)||void 0===r?void 0:r.includes(t)})))}return{todos:m,hasNextPage:u.hasNextPage,nextCursor:u.nextCursor||void 0}}))}catch(t){throw console.error("Error fetching todos from blockchain:",{ownerAddress:e,error:t instanceof Error?t.message:String(t),stack:t instanceof Error?t.stack:void 0}),t}}function m(e){let t=(0,o.tN)(),l=(null==t?void 0:t.connected)||!1,s=(null==t?void 0:t.address)||null,u=(null==t?void 0:t.trackTransaction)||null,g=(null==t?void 0:t.error)||null,m=(0,a.useMemo)(()=>(null==t?void 0:t.clearError)||(()=>{}),[null==t?void 0:t.clearError]),[w,y]=(0,a.useState)({todos:[],loading:!1,error:null,networkHealth:!0,refreshing:!1,hasNextPage:!1,nextCursor:void 0}),[p,v]=(0,a.useState)((null==e?void 0:e.network)||"testnet"),[b,E]=(0,a.useState)({}),k=(0,a.useMemo)(()=>!!(l&&s&&!g),[l,s,g]),T=(0,a.useCallback)(e=>{y(t=>({...t,error:e}))},[]),x=(0,a.useCallback)(e=>{y(t=>({...t,loading:e}))},[]),A=(0,a.useCallback)(e=>{y(t=>({...t,refreshing:e}))},[]),S=(0,a.useCallback)(()=>{T(null),m()},[T,m]),I=(0,a.useCallback)(async()=>{try{y(e=>({...e,networkHealth:!0}))}catch(e){y(e=>({...e,networkHealth:!1})),T("Health check failed: ".concat(e instanceof Error?e.message:"Unknown error"))}},[T]),C=(0,a.useCallback)(e=>{if(e)for(let[t]of(c.delete(e),Array.from(d.entries())))t.includes(e)&&d.delete(t);else c.size,d.size,c.clear(),d.clear()},[]),j=(0,a.useCallback)(async e=>{e.filter(e=>e.imageUrl&&e.imageUrl.startsWith("http")).map(e=>e.imageUrl).forEach(e=>{new Image().src=e})},[]),D=(0,a.useCallback)(async()=>{if(!s){try{let e=(0,n.LC)("default");y(t=>({...t,todos:e,hasNextPage:!1,nextCursor:void 0}))}catch(e){console.warn("Failed to load local todos:",e),y(e=>({...e,todos:[],hasNextPage:!1,nextCursor:void 0}))}return}A(!0),T(null);try{C();let{todos:e,hasNextPage:t,nextCursor:r}=await h(s,{filter:b,limit:50}),a=[];try{a=(0,n.LC)("default",s)}catch(e){console.warn("Failed to fetch local todos:",e)}let o=new Map;a.forEach(e=>{o.set(e.id,e)}),e.forEach(e=>{o.set(e.id,e)});let i=Array.from(o.values());i.sort((e,t)=>{let r=new Date(e.createdAt||0).getTime();return new Date(t.createdAt||0).getTime()-r}),y(e=>({...e,todos:i,hasNextPage:t,nextCursor:r,error:null}));try{await j(i)}catch(e){console.warn("Failed to prefetch images:",e)}}catch(t){let e=t instanceof Error?t.message:"Failed to fetch todos";console.error("Error fetching todos:",{address:s,error:e,stack:t instanceof Error?t.stack:void 0}),T(e);try{let e=(0,n.LC)("default",s);y(t=>({...t,todos:e,hasNextPage:!1,nextCursor:void 0,error:t.error}))}catch(e){console.error("Failed to load local todos as fallback:",e),y(e=>({...e,todos:[],hasNextPage:!1,nextCursor:void 0,error:e.error}))}}finally{A(!1)}},[s,b,p,T,A,j,C]),O=(0,a.useCallback)(async()=>{if(s&&w.hasNextPage&&w.nextCursor){x(!0),T(null);try{let{todos:e,hasNextPage:t,nextCursor:r}=await h(s,{cursor:w.nextCursor,filter:b,limit:50});y(a=>({...a,todos:[...a.todos,...e],hasNextPage:t,nextCursor:r})),j(e)}catch(e){T(e instanceof Error?e.message:"Failed to load more todos")}finally{x(!1)}}},[s,w.hasNextPage,w.nextCursor,b,T,x,j]),_=(0,a.useCallback)(async e=>{E(e)},[]),P=(0,a.useCallback)(async e=>{x(!0),T(null);try{v(e),k&&await D()}catch(t){T("Failed to switch to ".concat(e," network"))}finally{x(!1)}},[k,D,T,x]),F=(0,a.useCallback)(async e=>{x(!0),T(null);try{let r=JSON.stringify({priority:e.priority||"medium",tags:e.tags||[],dueDate:e.dueDate instanceof Date?e.dueDate.toISOString():e.dueDate}),a=(0,n.rk)("default",{title:e.title,description:e.description,completed:!1,priority:e.priority||"medium",tags:e.tags,dueDate:e.dueDate instanceof Date?e.dueDate.toISOString():e.dueDate},s||void 0);if(k&&s&&(null==t?void 0:t.signAndExecuteTransaction)){null==t||t.signAndExecuteTransaction;let o={title:e.title,description:e.description,priority:e.priority,tags:e.tags,dueDate:e.dueDate,imageUrl:e.imageUrl,metadata:r,isPrivate:e.isPrivate},l=(0,i.storeTodoOnBlockchain)(o,t.signAndExecuteTransaction,s),c=u?await u(l,"Create Todo NFT"):await l;if(c.success&&c.objectId)return a.objectId=c.objectId,a.blockchainStored=!0,(0,n.CU)("default",a,s),await D(),{success:!0,digest:c.digest,objectId:c.objectId}}return await D(),{success:!0,digest:a.id}}catch(t){let e=t instanceof Error?t.message:"Failed to create todo";return T(e),{success:!1,error:e}}finally{x(!1)}},[k,s,u,D,T,x,null==t?void 0:t.signAndExecuteTransaction]),N=(0,a.useCallback)(async e=>{if(!k||!s||!(null==t?void 0:t.signAndExecuteTransaction))throw Error("Wallet not connected");x(!0),T(null);try{let a=w.todos.find(t=>t.objectId===e.objectId);if(!a)throw Error("Todo not found");let o=JSON.stringify({priority:e.priority||a.priority||"medium",tags:e.tags||a.tags||[],dueDate:e.dueDate||a.dueDate}),n={...e,metadata:o},i=await f(async()=>{let{updateTodoOnBlockchain:e}=await Promise.resolve().then(r.bind(r,19132));return await e(n,t.signAndExecuteTransaction,s)});return i.success&&(y(t=>({...t,todos:t.todos.map(t=>t.objectId===e.objectId?{...t,title:e.title||t.title,description:e.description||t.description,priority:e.priority||t.priority,tags:e.tags||t.tags,dueDate:e.dueDate?e.dueDate instanceof Date?e.dueDate.toISOString():e.dueDate:t.dueDate,metadata:o,updatedAt:new Date().toISOString()}:t)})),c.delete(e.objectId)),i}catch(t){let e=t instanceof Error?t.message:"Failed to update todo";return T(e),{success:!1,error:e}}finally{x(!1)}},[k,s,w.todos,T,x,null==t?void 0:t.signAndExecuteTransaction]),U=(0,a.useCallback)(async e=>{x(!0),T(null);try{let a=w.todos.find(t=>t.id===e||t.objectId===e);if(!a)throw Error("Todo not found");if(a.completed=!0,a.completedAt=new Date().toISOString(),(0,n.CU)("default",a,s||void 0),a.blockchainStored&&a.objectId&&k&&s&&(null==t?void 0:t.signAndExecuteTransaction)){null==t||t.signAndExecuteTransaction;let e=f(async()=>{let{completeTodoOnBlockchain:e}=await Promise.resolve().then(r.bind(r,19132));if(!a.objectId)throw Error("Todo objectId is required for blockchain completion");return await e(a.objectId,t.signAndExecuteTransaction,s)});if(!(u?await u(e,"Complete Todo NFT"):await e).success)throw Error("Failed to complete todo on blockchain")}return await D(),{success:!0,digest:a.objectId||a.id}}catch(t){let e=t instanceof Error?t.message:"Failed to complete todo";return T(e),{success:!1,error:e}}finally{x(!1)}},[w.todos,k,s,u,D,T,x,null==t?void 0:t.signAndExecuteTransaction]),W=(0,a.useCallback)(async e=>{x(!0),T(null);try{let t=w.todos.find(t=>t.id===e||t.objectId===e);if(!t)throw Error("Todo not found");if(t.blockchainStored)throw Error("Blockchain todos cannot be deleted, only transferred to another address");if((0,n.aS)("default",t.id,s||void 0))return await D(),{success:!0,digest:t.id};return{success:!1,error:"Failed to delete todo"}}catch(t){let e=t instanceof Error?t.message:"Failed to delete todo";return T(e),{success:!1,error:e}}finally{x(!1)}},[w.todos,s,D,T,x]);(0,a.useEffect)(()=>{if(!k)return;let e=!0;return(async()=>{e&&(await D(),e&&await I())})(),()=>{e=!1}},[k,s,b,D,I]),(0,a.useEffect)(()=>{s&&C()},[s,C]),(0,a.useEffect)(()=>{if(!k)return;let e=setInterval(()=>{I()},3e4);return()=>clearInterval(e)},[k,I]);let z={createTodo:F,updateTodo:N,completeTodo:U,deleteTodo:W,refreshTodos:D,loadMore:O,filterTodos:_,switchToNetwork:P,checkHealth:I,clearError:S,invalidateCache:C};return{...w,...z,state:w,actions:z,network:p,isWalletReady:k,refetch:D}}function w(){let[e,t]=(0,a.useState)(!1),[n,i]=(0,a.useState)(null),[l,s]=(0,a.useState)(null),c=(0,o.tN)(),d=(null==c?void 0:c.connected)||!1,u=(null==c?void 0:c.address)||null,f=(0,a.useCallback)(async e=>{t(!0),i(null),s(null);try{let t=await e();return s(t),t}catch(e){throw i(e instanceof Error?e.message:"Operation failed"),e}finally{t(!1)}},[]),g=(0,a.useCallback)(()=>{i(null),s(null)},[]),h=(0,a.useCallback)(async e=>{var t;if(!d||!u||!(null==c?void 0:c.signAndExecuteTransaction))throw Error("Wallet not connected");if(!(null===(t=e.title)||void 0===t?void 0:t.trim()))throw Error("Title is required");if(e.title.length>100)throw Error("Title must be 100 characters or less");return f(async()=>{let{storeTodoOnBlockchain:t}=await Promise.resolve().then(r.bind(r,19132));return await t(e,c.signAndExecuteTransaction,u)})},[d,u,null==c?void 0:c.signAndExecuteTransaction,f]),m=(0,a.useCallback)(async e=>{if(!d||!u||!(null==c?void 0:c.signAndExecuteTransaction))throw Error("Wallet not connected");return f(async()=>{let{updateTodoOnBlockchain:t}=await Promise.resolve().then(r.bind(r,19132));return await t(e,c.signAndExecuteTransaction,u)})},[d,u,null==c?void 0:c.signAndExecuteTransaction,f]),w=(0,a.useCallback)(async e=>{if(!d||!u||!(null==c?void 0:c.signAndExecuteTransaction))throw Error("Wallet not connected");return f(async()=>{let{completeTodoOnBlockchain:t}=await Promise.resolve().then(r.bind(r,19132));return await t(e,c.signAndExecuteTransaction,u)})},[d,u,null==c?void 0:c.signAndExecuteTransaction,f]),y=(0,a.useCallback)(async e=>{if(!d||!u||!(null==c?void 0:c.signAndExecuteTransaction))throw Error("Wallet not connected");return f(async()=>{let{deleteTodoOnBlockchain:t}=await Promise.resolve().then(r.bind(r,19132));return await t(e,c.signAndExecuteTransaction,u)})},[d,u,null==c?void 0:c.signAndExecuteTransaction,f]),p=(0,a.useCallback)(async(e,t)=>{if(!d||!u||!(null==c?void 0:c.signAndExecuteTransaction))throw Error("Wallet not connected");if(!t||t.length<10||!t.startsWith("0x"))throw Error("Invalid recipient address");return f(async()=>{let{transferTodoNFT:a}=await Promise.resolve().then(r.bind(r,98436)),o=await a("default",e,t,{signAndExecuteTransaction:c.signAndExecuteTransaction,address:u},u);return{success:o,digest:void 0,objectId:o?e:void 0,error:o?void 0:"Transfer failed"}})},[d,u,null==c?void 0:c.signAndExecuteTransaction,f]);return{loading:e,error:n,result:l,executeOperation:f,clearState:g,createTodo:h,updateTodo:m,completeTodo:w,deleteTodo:y,transferTodo:p}}}}]);